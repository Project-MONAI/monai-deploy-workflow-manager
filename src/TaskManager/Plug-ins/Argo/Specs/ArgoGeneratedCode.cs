/*
 * Copyright 2022 MONAI Consortium
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"

namespace Argo
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial interface IArgoGeneratedClient
    {
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<WorkflowList> ArchivedWorkflowService_ListArchivedWorkflowsAsync(string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, string namePrefix);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<WorkflowList> ArchivedWorkflowService_ListArchivedWorkflowsAsync(string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, string namePrefix, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<LabelKeys> ArchivedWorkflowService_ListArchivedWorkflowLabelKeysAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<LabelKeys> ArchivedWorkflowService_ListArchivedWorkflowLabelKeysAsync(System.Threading.CancellationToken cancellationToken);

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<LabelValues> ArchivedWorkflowService_ListArchivedWorkflowLabelValuesAsync(string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<LabelValues> ArchivedWorkflowService_ListArchivedWorkflowLabelValuesAsync(string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Workflow> ArchivedWorkflowService_GetArchivedWorkflowAsync(string uid);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Workflow> ArchivedWorkflowService_GetArchivedWorkflowAsync(string uid, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ArchivedWorkflowDeletedResponse> ArchivedWorkflowService_DeleteArchivedWorkflowAsync(string uid);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ArchivedWorkflowDeletedResponse> ArchivedWorkflowService_DeleteArchivedWorkflowAsync(string uid, System.Threading.CancellationToken cancellationToken);

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ClusterWorkflowTemplateList> ClusterWorkflowTemplateService_ListClusterWorkflowTemplatesAsync(string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ClusterWorkflowTemplateList> ClusterWorkflowTemplateService_ListClusterWorkflowTemplatesAsync(string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ClusterWorkflowTemplate> ClusterWorkflowTemplateService_CreateClusterWorkflowTemplateAsync(ClusterWorkflowTemplateCreateRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ClusterWorkflowTemplate> ClusterWorkflowTemplateService_CreateClusterWorkflowTemplateAsync(ClusterWorkflowTemplateCreateRequest body, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ClusterWorkflowTemplate> ClusterWorkflowTemplateService_LintClusterWorkflowTemplateAsync(ClusterWorkflowTemplateLintRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ClusterWorkflowTemplate> ClusterWorkflowTemplateService_LintClusterWorkflowTemplateAsync(ClusterWorkflowTemplateLintRequest body, System.Threading.CancellationToken cancellationToken);

        /// <param name="getOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ClusterWorkflowTemplate> ClusterWorkflowTemplateService_GetClusterWorkflowTemplateAsync(string name, string getOptions_resourceVersion);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="getOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ClusterWorkflowTemplate> ClusterWorkflowTemplateService_GetClusterWorkflowTemplateAsync(string name, string getOptions_resourceVersion, System.Threading.CancellationToken cancellationToken);

        /// <param name="name">DEPRECATED: This field is ignored.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ClusterWorkflowTemplate> ClusterWorkflowTemplateService_UpdateClusterWorkflowTemplateAsync(string name, ClusterWorkflowTemplateUpdateRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="name">DEPRECATED: This field is ignored.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ClusterWorkflowTemplate> ClusterWorkflowTemplateService_UpdateClusterWorkflowTemplateAsync(string name, ClusterWorkflowTemplateUpdateRequest body, System.Threading.CancellationToken cancellationToken);

        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ClusterWorkflowTemplateDeleteResponse> ClusterWorkflowTemplateService_DeleteClusterWorkflowTemplateAsync(string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ClusterWorkflowTemplateDeleteResponse> ClusterWorkflowTemplateService_DeleteClusterWorkflowTemplateAsync(string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun, System.Threading.CancellationToken cancellationToken);

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CronWorkflowList> CronWorkflowService_ListCronWorkflowsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CronWorkflowList> CronWorkflowService_ListCronWorkflowsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CronWorkflow> CronWorkflowService_CreateCronWorkflowAsync(string @namespace, CreateCronWorkflowRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CronWorkflow> CronWorkflowService_CreateCronWorkflowAsync(string @namespace, CreateCronWorkflowRequest body, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CronWorkflow> CronWorkflowService_LintCronWorkflowAsync(string @namespace, LintCronWorkflowRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CronWorkflow> CronWorkflowService_LintCronWorkflowAsync(string @namespace, LintCronWorkflowRequest body, System.Threading.CancellationToken cancellationToken);

        /// <param name="getOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CronWorkflow> CronWorkflowService_GetCronWorkflowAsync(string @namespace, string name, string getOptions_resourceVersion);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="getOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CronWorkflow> CronWorkflowService_GetCronWorkflowAsync(string @namespace, string name, string getOptions_resourceVersion, System.Threading.CancellationToken cancellationToken);

        /// <param name="name">DEPRECATED: This field is ignored.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CronWorkflow> CronWorkflowService_UpdateCronWorkflowAsync(string @namespace, string name, UpdateCronWorkflowRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="name">DEPRECATED: This field is ignored.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CronWorkflow> CronWorkflowService_UpdateCronWorkflowAsync(string @namespace, string name, UpdateCronWorkflowRequest body, System.Threading.CancellationToken cancellationToken);

        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CronWorkflowDeletedResponse> CronWorkflowService_DeleteCronWorkflowAsync(string @namespace, string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CronWorkflowDeletedResponse> CronWorkflowService_DeleteCronWorkflowAsync(string @namespace, string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CronWorkflow> CronWorkflowService_ResumeCronWorkflowAsync(string @namespace, string name, CronWorkflowResumeRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CronWorkflow> CronWorkflowService_ResumeCronWorkflowAsync(string @namespace, string name, CronWorkflowResumeRequest body, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CronWorkflow> CronWorkflowService_SuspendCronWorkflowAsync(string @namespace, string name, CronWorkflowSuspendRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<CronWorkflow> CronWorkflowService_SuspendCronWorkflowAsync(string @namespace, string name, CronWorkflowSuspendRequest body, System.Threading.CancellationToken cancellationToken);

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<EventSourceList> EventSourceService_ListEventSourcesAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<EventSourceList> EventSourceService_ListEventSourcesAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<EventSource> EventSourceService_CreateEventSourceAsync(string @namespace, CreateEventSourceRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<EventSource> EventSourceService_CreateEventSourceAsync(string @namespace, CreateEventSourceRequest body, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<EventSource> EventSourceService_GetEventSourceAsync(string @namespace, string name);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<EventSource> EventSourceService_GetEventSourceAsync(string @namespace, string name, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<EventSource> EventSourceService_UpdateEventSourceAsync(string @namespace, string name, UpdateEventSourceRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<EventSource> EventSourceService_UpdateEventSourceAsync(string @namespace, string name, UpdateEventSourceRequest body, System.Threading.CancellationToken cancellationToken);

        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<EventSourceDeletedResponse> EventSourceService_DeleteEventSourceAsync(string @namespace, string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<EventSourceDeletedResponse> EventSourceService_DeleteEventSourceAsync(string @namespace, string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun, System.Threading.CancellationToken cancellationToken);

        /// <param name="namespace">The namespace for the io.argoproj.workflow.v1alpha1. This can be empty if the client has cluster scoped permissions.
        /// <br/>If empty, then the event is "broadcast" to workflow event binding in all namespaces.</param>
        /// <param name="discriminator">Optional discriminator for the io.argoproj.workflow.v1alpha1. This should almost always be empty.
        /// <br/>Used for edge-cases where the event payload alone is not provide enough information to discriminate the event.
        /// <br/>This MUST NOT be used as security mechanism, e.g. to allow two clients to use the same access token, or
        /// <br/>to support webhooks on unsecured server. Instead, use access tokens.
        /// <br/>This is made available as `discriminator` in the event binding selector (`/spec/event/selector)`</param>
        /// <param name="body">The event itself can be any data.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<EventResponse> EventService_ReceiveEventAsync(string @namespace, string discriminator, Item body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="namespace">The namespace for the io.argoproj.workflow.v1alpha1. This can be empty if the client has cluster scoped permissions.
        /// <br/>If empty, then the event is "broadcast" to workflow event binding in all namespaces.</param>
        /// <param name="discriminator">Optional discriminator for the io.argoproj.workflow.v1alpha1. This should almost always be empty.
        /// <br/>Used for edge-cases where the event payload alone is not provide enough information to discriminate the event.
        /// <br/>This MUST NOT be used as security mechanism, e.g. to allow two clients to use the same access token, or
        /// <br/>to support webhooks on unsecured server. Instead, use access tokens.
        /// <br/>This is made available as `discriminator` in the event binding selector (`/spec/event/selector)`</param>
        /// <param name="body">The event itself can be any data.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<EventResponse> EventService_ReceiveEventAsync(string @namespace, string discriminator, Item body, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<InfoResponse> InfoService_GetInfoAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<InfoResponse> InfoService_GetInfoAsync(System.Threading.CancellationToken cancellationToken);

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PipelineList> PipelineService_ListPipelinesAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<PipelineList> PipelineService_ListPipelinesAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken);

        /// <param name="getOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Pipeline> PipelineService_GetPipelineAsync(string @namespace, string name, string getOptions_resourceVersion);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="getOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Pipeline> PipelineService_GetPipelineAsync(string @namespace, string name, string getOptions_resourceVersion, System.Threading.CancellationToken cancellationToken);

        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeletePipelineResponse> PipelineService_DeletePipelineAsync(string @namespace, string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeletePipelineResponse> PipelineService_DeletePipelineAsync(string @namespace, string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestartPipelineResponse> PipelineService_RestartPipelineAsync(string @namespace, string name);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<RestartPipelineResponse> PipelineService_RestartPipelineAsync(string @namespace, string name, System.Threading.CancellationToken cancellationToken);

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SensorList> SensorService_ListSensorsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SensorList> SensorService_ListSensorsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Sensor> SensorService_CreateSensorAsync(string @namespace, CreateSensorRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Sensor> SensorService_CreateSensorAsync(string @namespace, CreateSensorRequest body, System.Threading.CancellationToken cancellationToken);

        /// <param name="getOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Sensor> SensorService_GetSensorAsync(string @namespace, string name, string getOptions_resourceVersion);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="getOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Sensor> SensorService_GetSensorAsync(string @namespace, string name, string getOptions_resourceVersion, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Sensor> SensorService_UpdateSensorAsync(string @namespace, string name, UpdateSensorRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Sensor> SensorService_UpdateSensorAsync(string @namespace, string name, UpdateSensorRequest body, System.Threading.CancellationToken cancellationToken);

        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeleteSensorResponse> SensorService_DeleteSensorAsync(string @namespace, string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<DeleteSensorResponse> SensorService_DeleteSensorAsync(string @namespace, string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun, System.Threading.CancellationToken cancellationToken);

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response> EventSourceService_WatchEventSourcesAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response> EventSourceService_WatchEventSourcesAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken);

        /// <param name="name">optional - only return entries for this event source.</param>
        /// <param name="eventSourceType">optional - only return entries for this event source type (e.g. `webhook`).</param>
        /// <param name="eventName">optional - only return entries for this event name (e.g. `example`).</param>
        /// <param name="grep">optional - only return entries where `msg` matches this regular expression.</param>
        /// <param name="podLogOptions_container">The container for which to stream logs. Defaults to only container if there is one container in the pod.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_follow">Follow the log stream of the pod. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_previous">Return previous terminated container logs. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value
        /// <br/>precedes the time a pod was started, only logs since the pod start will be returned.
        /// <br/>If this value is in the future, no logs will be returned.
        /// <br/>Only one of sinceSeconds or sinceTime may be specified.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_sinceTime_seconds">Represents seconds of UTC time since Unix epoch
        /// <br/>1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
        /// <br/>9999-12-31T23:59:59Z inclusive.</param>
        /// <param name="podLogOptions_sinceTime_nanos">Non-negative fractions of a second at nanosecond resolution. Negative
        /// <br/>second values with fractions must still have non-negative nanos values
        /// <br/>that count forward in time. Must be from 0 to 999,999,999
        /// <br/>inclusive. This field may be limited in precision depending on context.</param>
        /// <param name="podLogOptions_timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
        /// <br/>of log output. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_tailLines">If set, the number of lines from the end of the logs to show. If not specified,
        /// <br/>logs are shown from the creation of the container or sinceSeconds or sinceTime
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_limitBytes">If set, the number of bytes to read from the server before terminating the
        /// <br/>log output. This may not display a complete final line of logging, and may return
        /// <br/>slightly more or slightly less than the specified limit.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_insecureSkipTLSVerifyBackend">insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
        /// <br/>serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
        /// <br/>and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
        /// <br/>kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
        /// <br/>connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
        /// <br/>the actual log data coming from the real kubelet).
        /// <br/>+optional.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response2> EventSourceService_EventSourcesLogsAsync(string @namespace, string name, string eventSourceType, string eventName, string grep, string podLogOptions_container, bool? podLogOptions_follow, bool? podLogOptions_previous, string podLogOptions_sinceSeconds, string podLogOptions_sinceTime_seconds, int? podLogOptions_sinceTime_nanos, bool? podLogOptions_timestamps, string podLogOptions_tailLines, string podLogOptions_limitBytes, bool? podLogOptions_insecureSkipTLSVerifyBackend);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="name">optional - only return entries for this event source.</param>
        /// <param name="eventSourceType">optional - only return entries for this event source type (e.g. `webhook`).</param>
        /// <param name="eventName">optional - only return entries for this event name (e.g. `example`).</param>
        /// <param name="grep">optional - only return entries where `msg` matches this regular expression.</param>
        /// <param name="podLogOptions_container">The container for which to stream logs. Defaults to only container if there is one container in the pod.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_follow">Follow the log stream of the pod. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_previous">Return previous terminated container logs. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value
        /// <br/>precedes the time a pod was started, only logs since the pod start will be returned.
        /// <br/>If this value is in the future, no logs will be returned.
        /// <br/>Only one of sinceSeconds or sinceTime may be specified.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_sinceTime_seconds">Represents seconds of UTC time since Unix epoch
        /// <br/>1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
        /// <br/>9999-12-31T23:59:59Z inclusive.</param>
        /// <param name="podLogOptions_sinceTime_nanos">Non-negative fractions of a second at nanosecond resolution. Negative
        /// <br/>second values with fractions must still have non-negative nanos values
        /// <br/>that count forward in time. Must be from 0 to 999,999,999
        /// <br/>inclusive. This field may be limited in precision depending on context.</param>
        /// <param name="podLogOptions_timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
        /// <br/>of log output. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_tailLines">If set, the number of lines from the end of the logs to show. If not specified,
        /// <br/>logs are shown from the creation of the container or sinceSeconds or sinceTime
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_limitBytes">If set, the number of bytes to read from the server before terminating the
        /// <br/>log output. This may not display a complete final line of logging, and may return
        /// <br/>slightly more or slightly less than the specified limit.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_insecureSkipTLSVerifyBackend">insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
        /// <br/>serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
        /// <br/>and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
        /// <br/>kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
        /// <br/>connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
        /// <br/>the actual log data coming from the real kubelet).
        /// <br/>+optional.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response2> EventSourceService_EventSourcesLogsAsync(string @namespace, string name, string eventSourceType, string eventName, string grep, string podLogOptions_container, bool? podLogOptions_follow, bool? podLogOptions_previous, string podLogOptions_sinceSeconds, string podLogOptions_sinceTime_seconds, int? podLogOptions_sinceTime_nanos, bool? podLogOptions_timestamps, string podLogOptions_tailLines, string podLogOptions_limitBytes, bool? podLogOptions_insecureSkipTLSVerifyBackend, System.Threading.CancellationToken cancellationToken);

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response3> WorkflowService_WatchEventsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response3> WorkflowService_WatchEventsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken);

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response4> PipelineService_WatchPipelinesAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response4> PipelineService_WatchPipelinesAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken);

        /// <param name="name">optional - only return entries for this pipeline.</param>
        /// <param name="stepName">optional - only return entries for this step.</param>
        /// <param name="grep">optional - only return entries which match this expresssion.</param>
        /// <param name="podLogOptions_container">The container for which to stream logs. Defaults to only container if there is one container in the pod.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_follow">Follow the log stream of the pod. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_previous">Return previous terminated container logs. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value
        /// <br/>precedes the time a pod was started, only logs since the pod start will be returned.
        /// <br/>If this value is in the future, no logs will be returned.
        /// <br/>Only one of sinceSeconds or sinceTime may be specified.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_sinceTime_seconds">Represents seconds of UTC time since Unix epoch
        /// <br/>1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
        /// <br/>9999-12-31T23:59:59Z inclusive.</param>
        /// <param name="podLogOptions_sinceTime_nanos">Non-negative fractions of a second at nanosecond resolution. Negative
        /// <br/>second values with fractions must still have non-negative nanos values
        /// <br/>that count forward in time. Must be from 0 to 999,999,999
        /// <br/>inclusive. This field may be limited in precision depending on context.</param>
        /// <param name="podLogOptions_timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
        /// <br/>of log output. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_tailLines">If set, the number of lines from the end of the logs to show. If not specified,
        /// <br/>logs are shown from the creation of the container or sinceSeconds or sinceTime
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_limitBytes">If set, the number of bytes to read from the server before terminating the
        /// <br/>log output. This may not display a complete final line of logging, and may return
        /// <br/>slightly more or slightly less than the specified limit.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_insecureSkipTLSVerifyBackend">insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
        /// <br/>serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
        /// <br/>and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
        /// <br/>kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
        /// <br/>connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
        /// <br/>the actual log data coming from the real kubelet).
        /// <br/>+optional.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response5> PipelineService_PipelineLogsAsync(string @namespace, string name, string stepName, string grep, string podLogOptions_container, bool? podLogOptions_follow, bool? podLogOptions_previous, string podLogOptions_sinceSeconds, string podLogOptions_sinceTime_seconds, int? podLogOptions_sinceTime_nanos, bool? podLogOptions_timestamps, string podLogOptions_tailLines, string podLogOptions_limitBytes, bool? podLogOptions_insecureSkipTLSVerifyBackend);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="name">optional - only return entries for this pipeline.</param>
        /// <param name="stepName">optional - only return entries for this step.</param>
        /// <param name="grep">optional - only return entries which match this expresssion.</param>
        /// <param name="podLogOptions_container">The container for which to stream logs. Defaults to only container if there is one container in the pod.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_follow">Follow the log stream of the pod. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_previous">Return previous terminated container logs. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value
        /// <br/>precedes the time a pod was started, only logs since the pod start will be returned.
        /// <br/>If this value is in the future, no logs will be returned.
        /// <br/>Only one of sinceSeconds or sinceTime may be specified.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_sinceTime_seconds">Represents seconds of UTC time since Unix epoch
        /// <br/>1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
        /// <br/>9999-12-31T23:59:59Z inclusive.</param>
        /// <param name="podLogOptions_sinceTime_nanos">Non-negative fractions of a second at nanosecond resolution. Negative
        /// <br/>second values with fractions must still have non-negative nanos values
        /// <br/>that count forward in time. Must be from 0 to 999,999,999
        /// <br/>inclusive. This field may be limited in precision depending on context.</param>
        /// <param name="podLogOptions_timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
        /// <br/>of log output. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_tailLines">If set, the number of lines from the end of the logs to show. If not specified,
        /// <br/>logs are shown from the creation of the container or sinceSeconds or sinceTime
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_limitBytes">If set, the number of bytes to read from the server before terminating the
        /// <br/>log output. This may not display a complete final line of logging, and may return
        /// <br/>slightly more or slightly less than the specified limit.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_insecureSkipTLSVerifyBackend">insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
        /// <br/>serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
        /// <br/>and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
        /// <br/>kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
        /// <br/>connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
        /// <br/>the actual log data coming from the real kubelet).
        /// <br/>+optional.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response5> PipelineService_PipelineLogsAsync(string @namespace, string name, string stepName, string grep, string podLogOptions_container, bool? podLogOptions_follow, bool? podLogOptions_previous, string podLogOptions_sinceSeconds, string podLogOptions_sinceTime_seconds, int? podLogOptions_sinceTime_nanos, bool? podLogOptions_timestamps, string podLogOptions_tailLines, string podLogOptions_limitBytes, bool? podLogOptions_insecureSkipTLSVerifyBackend, System.Threading.CancellationToken cancellationToken);

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response6> SensorService_WatchSensorsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response6> SensorService_WatchSensorsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken);

        /// <param name="name">optional - only return entries for this sensor name.</param>
        /// <param name="triggerName">optional - only return entries for this trigger.</param>
        /// <param name="grep">option - only return entries where `msg` contains this regular expressions.</param>
        /// <param name="podLogOptions_container">The container for which to stream logs. Defaults to only container if there is one container in the pod.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_follow">Follow the log stream of the pod. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_previous">Return previous terminated container logs. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value
        /// <br/>precedes the time a pod was started, only logs since the pod start will be returned.
        /// <br/>If this value is in the future, no logs will be returned.
        /// <br/>Only one of sinceSeconds or sinceTime may be specified.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_sinceTime_seconds">Represents seconds of UTC time since Unix epoch
        /// <br/>1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
        /// <br/>9999-12-31T23:59:59Z inclusive.</param>
        /// <param name="podLogOptions_sinceTime_nanos">Non-negative fractions of a second at nanosecond resolution. Negative
        /// <br/>second values with fractions must still have non-negative nanos values
        /// <br/>that count forward in time. Must be from 0 to 999,999,999
        /// <br/>inclusive. This field may be limited in precision depending on context.</param>
        /// <param name="podLogOptions_timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
        /// <br/>of log output. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_tailLines">If set, the number of lines from the end of the logs to show. If not specified,
        /// <br/>logs are shown from the creation of the container or sinceSeconds or sinceTime
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_limitBytes">If set, the number of bytes to read from the server before terminating the
        /// <br/>log output. This may not display a complete final line of logging, and may return
        /// <br/>slightly more or slightly less than the specified limit.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_insecureSkipTLSVerifyBackend">insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
        /// <br/>serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
        /// <br/>and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
        /// <br/>kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
        /// <br/>connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
        /// <br/>the actual log data coming from the real kubelet).
        /// <br/>+optional.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response7> SensorService_SensorsLogsAsync(string @namespace, string name, string triggerName, string grep, string podLogOptions_container, bool? podLogOptions_follow, bool? podLogOptions_previous, string podLogOptions_sinceSeconds, string podLogOptions_sinceTime_seconds, int? podLogOptions_sinceTime_nanos, bool? podLogOptions_timestamps, string podLogOptions_tailLines, string podLogOptions_limitBytes, bool? podLogOptions_insecureSkipTLSVerifyBackend);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="name">optional - only return entries for this sensor name.</param>
        /// <param name="triggerName">optional - only return entries for this trigger.</param>
        /// <param name="grep">option - only return entries where `msg` contains this regular expressions.</param>
        /// <param name="podLogOptions_container">The container for which to stream logs. Defaults to only container if there is one container in the pod.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_follow">Follow the log stream of the pod. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_previous">Return previous terminated container logs. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value
        /// <br/>precedes the time a pod was started, only logs since the pod start will be returned.
        /// <br/>If this value is in the future, no logs will be returned.
        /// <br/>Only one of sinceSeconds or sinceTime may be specified.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_sinceTime_seconds">Represents seconds of UTC time since Unix epoch
        /// <br/>1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
        /// <br/>9999-12-31T23:59:59Z inclusive.</param>
        /// <param name="podLogOptions_sinceTime_nanos">Non-negative fractions of a second at nanosecond resolution. Negative
        /// <br/>second values with fractions must still have non-negative nanos values
        /// <br/>that count forward in time. Must be from 0 to 999,999,999
        /// <br/>inclusive. This field may be limited in precision depending on context.</param>
        /// <param name="podLogOptions_timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
        /// <br/>of log output. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_tailLines">If set, the number of lines from the end of the logs to show. If not specified,
        /// <br/>logs are shown from the creation of the container or sinceSeconds or sinceTime
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_limitBytes">If set, the number of bytes to read from the server before terminating the
        /// <br/>log output. This may not display a complete final line of logging, and may return
        /// <br/>slightly more or slightly less than the specified limit.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_insecureSkipTLSVerifyBackend">insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
        /// <br/>serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
        /// <br/>and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
        /// <br/>kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
        /// <br/>connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
        /// <br/>the actual log data coming from the real kubelet).
        /// <br/>+optional.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response7> SensorService_SensorsLogsAsync(string @namespace, string name, string triggerName, string grep, string podLogOptions_container, bool? podLogOptions_follow, bool? podLogOptions_previous, string podLogOptions_sinceSeconds, string podLogOptions_sinceTime_seconds, int? podLogOptions_sinceTime_nanos, bool? podLogOptions_timestamps, string podLogOptions_tailLines, string podLogOptions_limitBytes, bool? podLogOptions_insecureSkipTLSVerifyBackend, System.Threading.CancellationToken cancellationToken);

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response8> PipelineService_WatchStepsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response8> PipelineService_WatchStepsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetUserInfoResponse> InfoService_GetUserInfoAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<GetUserInfoResponse> InfoService_GetUserInfoAsync(System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Version> InfoService_GetVersionAsync();

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Version> InfoService_GetVersionAsync(System.Threading.CancellationToken cancellationToken);

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<WorkflowEventBindingList> EventService_ListWorkflowEventBindingsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<WorkflowEventBindingList> EventService_ListWorkflowEventBindingsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken);

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response9> WorkflowService_WatchWorkflowsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, string fields);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response9> WorkflowService_WatchWorkflowsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, string fields, System.Threading.CancellationToken cancellationToken);

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<WorkflowTemplateList> WorkflowTemplateService_ListWorkflowTemplatesAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<WorkflowTemplateList> WorkflowTemplateService_ListWorkflowTemplatesAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<WorkflowTemplate> WorkflowTemplateService_CreateWorkflowTemplateAsync(string @namespace, WorkflowTemplateCreateRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<WorkflowTemplate> WorkflowTemplateService_CreateWorkflowTemplateAsync(string @namespace, WorkflowTemplateCreateRequest body, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<WorkflowTemplate> WorkflowTemplateService_LintWorkflowTemplateAsync(string @namespace, WorkflowTemplateLintRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<WorkflowTemplate> WorkflowTemplateService_LintWorkflowTemplateAsync(string @namespace, WorkflowTemplateLintRequest body, System.Threading.CancellationToken cancellationToken);

        /// <param name="getOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<WorkflowTemplate> WorkflowTemplateService_GetWorkflowTemplateAsync(string @namespace, string name, string getOptions_resourceVersion);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="getOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<WorkflowTemplate> WorkflowTemplateService_GetWorkflowTemplateAsync(string @namespace, string name, string getOptions_resourceVersion, System.Threading.CancellationToken cancellationToken);

        /// <param name="name">DEPRECATED: This field is ignored.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<WorkflowTemplate> WorkflowTemplateService_UpdateWorkflowTemplateAsync(string @namespace, string name, WorkflowTemplateUpdateRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="name">DEPRECATED: This field is ignored.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<WorkflowTemplate> WorkflowTemplateService_UpdateWorkflowTemplateAsync(string @namespace, string name, WorkflowTemplateUpdateRequest body, System.Threading.CancellationToken cancellationToken);

        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<WorkflowTemplateDeleteResponse> WorkflowTemplateService_DeleteWorkflowTemplateAsync(string @namespace, string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<WorkflowTemplateDeleteResponse> WorkflowTemplateService_DeleteWorkflowTemplateAsync(string @namespace, string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun, System.Threading.CancellationToken cancellationToken);

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <param name="fields">Fields to be included or excluded in the response. e.g. "items.spec,items.status.phase", "-items.status.nodes".</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<WorkflowList> WorkflowService_ListWorkflowsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, string fields);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <param name="fields">Fields to be included or excluded in the response. e.g. "items.spec,items.status.phase", "-items.status.nodes".</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<WorkflowList> WorkflowService_ListWorkflowsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, string fields, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Workflow> WorkflowService_CreateWorkflowAsync(string @namespace, WorkflowCreateRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Workflow> WorkflowService_CreateWorkflowAsync(string @namespace, WorkflowCreateRequest body, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Workflow> WorkflowService_LintWorkflowAsync(string @namespace, WorkflowLintRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Workflow> WorkflowService_LintWorkflowAsync(string @namespace, WorkflowLintRequest body, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Workflow> WorkflowService_SubmitWorkflowAsync(string @namespace, WorkflowSubmitRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Workflow> WorkflowService_SubmitWorkflowAsync(string @namespace, WorkflowSubmitRequest body, System.Threading.CancellationToken cancellationToken);

        /// <param name="getOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="fields">Fields to be included or excluded in the response. e.g. "spec,status.phase", "-status.nodes".</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Workflow> WorkflowService_GetWorkflowAsync(string @namespace, string name, string getOptions_resourceVersion, string fields);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="getOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="fields">Fields to be included or excluded in the response. e.g. "spec,status.phase", "-status.nodes".</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Workflow> WorkflowService_GetWorkflowAsync(string @namespace, string name, string getOptions_resourceVersion, string fields, System.Threading.CancellationToken cancellationToken);

        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<WorkflowDeleteResponse> WorkflowService_DeleteWorkflowAsync(string @namespace, string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<WorkflowDeleteResponse> WorkflowService_DeleteWorkflowAsync(string @namespace, string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun, System.Threading.CancellationToken cancellationToken);

        /// <param name="logOptions_container">The container for which to stream logs. Defaults to only container if there is one container in the pod.
        /// <br/>+optional.</param>
        /// <param name="logOptions_follow">Follow the log stream of the pod. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="logOptions_previous">Return previous terminated container logs. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="logOptions_sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value
        /// <br/>precedes the time a pod was started, only logs since the pod start will be returned.
        /// <br/>If this value is in the future, no logs will be returned.
        /// <br/>Only one of sinceSeconds or sinceTime may be specified.
        /// <br/>+optional.</param>
        /// <param name="logOptions_sinceTime_seconds">Represents seconds of UTC time since Unix epoch
        /// <br/>1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
        /// <br/>9999-12-31T23:59:59Z inclusive.</param>
        /// <param name="logOptions_sinceTime_nanos">Non-negative fractions of a second at nanosecond resolution. Negative
        /// <br/>second values with fractions must still have non-negative nanos values
        /// <br/>that count forward in time. Must be from 0 to 999,999,999
        /// <br/>inclusive. This field may be limited in precision depending on context.</param>
        /// <param name="logOptions_timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
        /// <br/>of log output. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="logOptions_tailLines">If set, the number of lines from the end of the logs to show. If not specified,
        /// <br/>logs are shown from the creation of the container or sinceSeconds or sinceTime
        /// <br/>+optional.</param>
        /// <param name="logOptions_limitBytes">If set, the number of bytes to read from the server before terminating the
        /// <br/>log output. This may not display a complete final line of logging, and may return
        /// <br/>slightly more or slightly less than the specified limit.
        /// <br/>+optional.</param>
        /// <param name="logOptions_insecureSkipTLSVerifyBackend">insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
        /// <br/>serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
        /// <br/>and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
        /// <br/>kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
        /// <br/>connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
        /// <br/>the actual log data coming from the real kubelet).
        /// <br/>+optional.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<string> WorkflowService_WorkflowLogsAsync(string @namespace, string name, string podName, string logOptions_container, bool? logOptions_follow, bool? logOptions_previous, string logOptions_sinceSeconds, string logOptions_sinceTime_seconds, int? logOptions_sinceTime_nanos, bool? logOptions_timestamps, string logOptions_tailLines, string logOptions_limitBytes, bool? logOptions_insecureSkipTLSVerifyBackend, string grep, string selector);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="logOptions_container">The container for which to stream logs. Defaults to only container if there is one container in the pod.
        /// <br/>+optional.</param>
        /// <param name="logOptions_follow">Follow the log stream of the pod. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="logOptions_previous">Return previous terminated container logs. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="logOptions_sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value
        /// <br/>precedes the time a pod was started, only logs since the pod start will be returned.
        /// <br/>If this value is in the future, no logs will be returned.
        /// <br/>Only one of sinceSeconds or sinceTime may be specified.
        /// <br/>+optional.</param>
        /// <param name="logOptions_sinceTime_seconds">Represents seconds of UTC time since Unix epoch
        /// <br/>1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
        /// <br/>9999-12-31T23:59:59Z inclusive.</param>
        /// <param name="logOptions_sinceTime_nanos">Non-negative fractions of a second at nanosecond resolution. Negative
        /// <br/>second values with fractions must still have non-negative nanos values
        /// <br/>that count forward in time. Must be from 0 to 999,999,999
        /// <br/>inclusive. This field may be limited in precision depending on context.</param>
        /// <param name="logOptions_timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
        /// <br/>of log output. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="logOptions_tailLines">If set, the number of lines from the end of the logs to show. If not specified,
        /// <br/>logs are shown from the creation of the container or sinceSeconds or sinceTime
        /// <br/>+optional.</param>
        /// <param name="logOptions_limitBytes">If set, the number of bytes to read from the server before terminating the
        /// <br/>log output. This may not display a complete final line of logging, and may return
        /// <br/>slightly more or slightly less than the specified limit.
        /// <br/>+optional.</param>
        /// <param name="logOptions_insecureSkipTLSVerifyBackend">insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
        /// <br/>serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
        /// <br/>and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
        /// <br/>kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
        /// <br/>connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
        /// <br/>the actual log data coming from the real kubelet).
        /// <br/>+optional.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        //System.Threading.Tasks.Task<Response10> WorkflowService_WorkflowLogsAsync(string @namespace, string name, string podName, string logOptions_container, bool? logOptions_follow, bool? logOptions_previous, string logOptions_sinceSeconds, string logOptions_sinceTime_seconds, int? logOptions_sinceTime_nanos, bool? logOptions_timestamps, string logOptions_tailLines, string logOptions_limitBytes, bool? logOptions_insecureSkipTLSVerifyBackend, string grep, string selector, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Workflow> WorkflowService_ResubmitWorkflowAsync(string @namespace, string name, WorkflowResubmitRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Workflow> WorkflowService_ResubmitWorkflowAsync(string @namespace, string name, WorkflowResubmitRequest body, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Workflow> WorkflowService_ResumeWorkflowAsync(string @namespace, string name, WorkflowResumeRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Workflow> WorkflowService_ResumeWorkflowAsync(string @namespace, string name, WorkflowResumeRequest body, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Workflow> WorkflowService_RetryWorkflowAsync(string @namespace, string name, WorkflowRetryRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Workflow> WorkflowService_RetryWorkflowAsync(string @namespace, string name, WorkflowRetryRequest body, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Workflow> WorkflowService_SetWorkflowAsync(string @namespace, string name, WorkflowSetRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Workflow> WorkflowService_SetWorkflowAsync(string @namespace, string name, WorkflowSetRequest body, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Workflow> WorkflowService_StopWorkflowAsync(string @namespace, string name, WorkflowStopRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Workflow> WorkflowService_StopWorkflowAsync(string @namespace, string name, WorkflowStopRequest body, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Workflow> WorkflowService_SuspendWorkflowAsync(string @namespace, string name, WorkflowSuspendRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Workflow> WorkflowService_SuspendWorkflowAsync(string @namespace, string name, WorkflowSuspendRequest body, System.Threading.CancellationToken cancellationToken);

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Workflow> WorkflowService_TerminateWorkflowAsync(string @namespace, string name, WorkflowTerminateRequest body);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Workflow> WorkflowService_TerminateWorkflowAsync(string @namespace, string name, WorkflowTerminateRequest body, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// DEPRECATED: Cannot work via HTTP if podName is an empty string. Use WorkflowLogs.
        /// </summary>
        /// <param name="logOptions_container">The container for which to stream logs. Defaults to only container if there is one container in the pod.
        /// <br/>+optional.</param>
        /// <param name="logOptions_follow">Follow the log stream of the pod. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="logOptions_previous">Return previous terminated container logs. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="logOptions_sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value
        /// <br/>precedes the time a pod was started, only logs since the pod start will be returned.
        /// <br/>If this value is in the future, no logs will be returned.
        /// <br/>Only one of sinceSeconds or sinceTime may be specified.
        /// <br/>+optional.</param>
        /// <param name="logOptions_sinceTime_seconds">Represents seconds of UTC time since Unix epoch
        /// <br/>1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
        /// <br/>9999-12-31T23:59:59Z inclusive.</param>
        /// <param name="logOptions_sinceTime_nanos">Non-negative fractions of a second at nanosecond resolution. Negative
        /// <br/>second values with fractions must still have non-negative nanos values
        /// <br/>that count forward in time. Must be from 0 to 999,999,999
        /// <br/>inclusive. This field may be limited in precision depending on context.</param>
        /// <param name="logOptions_timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
        /// <br/>of log output. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="logOptions_tailLines">If set, the number of lines from the end of the logs to show. If not specified,
        /// <br/>logs are shown from the creation of the container or sinceSeconds or sinceTime
        /// <br/>+optional.</param>
        /// <param name="logOptions_limitBytes">If set, the number of bytes to read from the server before terminating the
        /// <br/>log output. This may not display a complete final line of logging, and may return
        /// <br/>slightly more or slightly less than the specified limit.
        /// <br/>+optional.</param>
        /// <param name="logOptions_insecureSkipTLSVerifyBackend">insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
        /// <br/>serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
        /// <br/>and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
        /// <br/>kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
        /// <br/>connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
        /// <br/>the actual log data coming from the real kubelet).
        /// <br/>+optional.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response11> WorkflowService_PodLogsAsync(string @namespace, string name, string podName, string logOptions_container, bool? logOptions_follow, bool? logOptions_previous, string logOptions_sinceSeconds, string logOptions_sinceTime_seconds, int? logOptions_sinceTime_nanos, bool? logOptions_timestamps, string logOptions_tailLines, string logOptions_limitBytes, bool? logOptions_insecureSkipTLSVerifyBackend, string grep, string selector);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// DEPRECATED: Cannot work via HTTP if podName is an empty string. Use WorkflowLogs.
        /// </summary>
        /// <param name="logOptions_container">The container for which to stream logs. Defaults to only container if there is one container in the pod.
        /// <br/>+optional.</param>
        /// <param name="logOptions_follow">Follow the log stream of the pod. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="logOptions_previous">Return previous terminated container logs. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="logOptions_sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value
        /// <br/>precedes the time a pod was started, only logs since the pod start will be returned.
        /// <br/>If this value is in the future, no logs will be returned.
        /// <br/>Only one of sinceSeconds or sinceTime may be specified.
        /// <br/>+optional.</param>
        /// <param name="logOptions_sinceTime_seconds">Represents seconds of UTC time since Unix epoch
        /// <br/>1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
        /// <br/>9999-12-31T23:59:59Z inclusive.</param>
        /// <param name="logOptions_sinceTime_nanos">Non-negative fractions of a second at nanosecond resolution. Negative
        /// <br/>second values with fractions must still have non-negative nanos values
        /// <br/>that count forward in time. Must be from 0 to 999,999,999
        /// <br/>inclusive. This field may be limited in precision depending on context.</param>
        /// <param name="logOptions_timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
        /// <br/>of log output. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="logOptions_tailLines">If set, the number of lines from the end of the logs to show. If not specified,
        /// <br/>logs are shown from the creation of the container or sinceSeconds or sinceTime
        /// <br/>+optional.</param>
        /// <param name="logOptions_limitBytes">If set, the number of bytes to read from the server before terminating the
        /// <br/>log output. This may not display a complete final line of logging, and may return
        /// <br/>slightly more or slightly less than the specified limit.
        /// <br/>+optional.</param>
        /// <param name="logOptions_insecureSkipTLSVerifyBackend">insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
        /// <br/>serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
        /// <br/>and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
        /// <br/>kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
        /// <br/>connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
        /// <br/>the actual log data coming from the real kubelet).
        /// <br/>+optional.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response11> WorkflowService_PodLogsAsync(string @namespace, string name, string podName, string logOptions_container, bool? logOptions_follow, bool? logOptions_previous, string logOptions_sinceSeconds, string logOptions_sinceTime_seconds, int? logOptions_sinceTime_nanos, bool? logOptions_timestamps, string logOptions_tailLines, string logOptions_limitBytes, bool? logOptions_insecureSkipTLSVerifyBackend, string grep, string selector, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get an output artifact by UID.
        /// </summary>
        /// <returns>An artifact file.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ArtifactService_GetOutputArtifactByUIDAsync(string uid, string podName, string artifactName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get an output artifact by UID.
        /// </summary>
        /// <returns>An artifact file.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ArtifactService_GetOutputArtifactByUIDAsync(string uid, string podName, string artifactName, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get an output artifact.
        /// </summary>
        /// <returns>An artifact file.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ArtifactService_GetOutputArtifactAsync(string @namespace, string name, string podName, string artifactName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get an output artifact.
        /// </summary>
        /// <returns>An artifact file.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ArtifactService_GetOutputArtifactAsync(string @namespace, string name, string podName, string artifactName, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get an input artifact by UID.
        /// </summary>
        /// <returns>An artifact file.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ArtifactService_GetInputArtifactByUIDAsync(string uid, string podName, string artifactName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get an input artifact by UID.
        /// </summary>
        /// <returns>An artifact file.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ArtifactService_GetInputArtifactByUIDAsync(string uid, string podName, string artifactName, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// Get an input artifact.
        /// </summary>
        /// <returns>An artifact file.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ArtifactService_GetInputArtifactAsync(string @namespace, string name, string podName, string artifactName);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get an input artifact.
        /// </summary>
        /// <returns>An artifact file.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        System.Threading.Tasks.Task ArtifactService_GetInputArtifactAsync(string @namespace, string name, string podName, string artifactName, System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ArgoGeneratedClient : IArgoGeneratedClient
    {
        private string _baseUrl = "http://localhost:2746";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public ArgoGeneratedClient(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }

        public Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<WorkflowList> ArchivedWorkflowService_ListArchivedWorkflowsAsync(string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, string namePrefix)
        {
            return ArchivedWorkflowService_ListArchivedWorkflowsAsync(listOptions_labelSelector, listOptions_fieldSelector, listOptions_watch, listOptions_allowWatchBookmarks, listOptions_resourceVersion, listOptions_resourceVersionMatch, listOptions_timeoutSeconds, listOptions_limit, listOptions_continue, namePrefix, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<WorkflowList> ArchivedWorkflowService_ListArchivedWorkflowsAsync(string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, string namePrefix, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/archived-workflows?");
            if (listOptions_labelSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.labelSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_labelSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_fieldSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.fieldSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_fieldSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_watch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.watch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_watch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_allowWatchBookmarks != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.allowWatchBookmarks") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_allowWatchBookmarks, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersionMatch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersionMatch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersionMatch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_timeoutSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.timeoutSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_timeoutSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_limit != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.limit") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_continue != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.continue") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_continue, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (namePrefix != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("namePrefix") + "=").Append(System.Uri.EscapeDataString(ConvertToString(namePrefix, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<WorkflowList>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<LabelKeys> ArchivedWorkflowService_ListArchivedWorkflowLabelKeysAsync()
        {
            return ArchivedWorkflowService_ListArchivedWorkflowLabelKeysAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<LabelKeys> ArchivedWorkflowService_ListArchivedWorkflowLabelKeysAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/archived-workflows-label-keys");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LabelKeys>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<LabelValues> ArchivedWorkflowService_ListArchivedWorkflowLabelValuesAsync(string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue)
        {
            return ArchivedWorkflowService_ListArchivedWorkflowLabelValuesAsync(listOptions_labelSelector, listOptions_fieldSelector, listOptions_watch, listOptions_allowWatchBookmarks, listOptions_resourceVersion, listOptions_resourceVersionMatch, listOptions_timeoutSeconds, listOptions_limit, listOptions_continue, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<LabelValues> ArchivedWorkflowService_ListArchivedWorkflowLabelValuesAsync(string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/archived-workflows-label-values?");
            if (listOptions_labelSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.labelSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_labelSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_fieldSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.fieldSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_fieldSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_watch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.watch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_watch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_allowWatchBookmarks != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.allowWatchBookmarks") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_allowWatchBookmarks, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersionMatch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersionMatch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersionMatch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_timeoutSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.timeoutSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_timeoutSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_limit != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.limit") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_continue != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.continue") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_continue, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<LabelValues>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Workflow> ArchivedWorkflowService_GetArchivedWorkflowAsync(string uid)
        {
            return ArchivedWorkflowService_GetArchivedWorkflowAsync(uid, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Workflow> ArchivedWorkflowService_GetArchivedWorkflowAsync(string uid, System.Threading.CancellationToken cancellationToken)
        {
            if (uid == null)
                throw new System.ArgumentNullException("uid");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/archived-workflows/{uid}");
            urlBuilder_.Replace("{uid}", System.Uri.EscapeDataString(ConvertToString(uid, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Workflow>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ArchivedWorkflowDeletedResponse> ArchivedWorkflowService_DeleteArchivedWorkflowAsync(string uid)
        {
            return ArchivedWorkflowService_DeleteArchivedWorkflowAsync(uid, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ArchivedWorkflowDeletedResponse> ArchivedWorkflowService_DeleteArchivedWorkflowAsync(string uid, System.Threading.CancellationToken cancellationToken)
        {
            if (uid == null)
                throw new System.ArgumentNullException("uid");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/archived-workflows/{uid}");
            urlBuilder_.Replace("{uid}", System.Uri.EscapeDataString(ConvertToString(uid, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ArchivedWorkflowDeletedResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ClusterWorkflowTemplateList> ClusterWorkflowTemplateService_ListClusterWorkflowTemplatesAsync(string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue)
        {
            return ClusterWorkflowTemplateService_ListClusterWorkflowTemplatesAsync(listOptions_labelSelector, listOptions_fieldSelector, listOptions_watch, listOptions_allowWatchBookmarks, listOptions_resourceVersion, listOptions_resourceVersionMatch, listOptions_timeoutSeconds, listOptions_limit, listOptions_continue, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ClusterWorkflowTemplateList> ClusterWorkflowTemplateService_ListClusterWorkflowTemplatesAsync(string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/cluster-workflow-templates?");
            if (listOptions_labelSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.labelSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_labelSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_fieldSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.fieldSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_fieldSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_watch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.watch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_watch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_allowWatchBookmarks != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.allowWatchBookmarks") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_allowWatchBookmarks, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersionMatch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersionMatch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersionMatch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_timeoutSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.timeoutSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_timeoutSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_limit != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.limit") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_continue != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.continue") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_continue, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ClusterWorkflowTemplateList>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ClusterWorkflowTemplate> ClusterWorkflowTemplateService_CreateClusterWorkflowTemplateAsync(ClusterWorkflowTemplateCreateRequest body)
        {
            return ClusterWorkflowTemplateService_CreateClusterWorkflowTemplateAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ClusterWorkflowTemplate> ClusterWorkflowTemplateService_CreateClusterWorkflowTemplateAsync(ClusterWorkflowTemplateCreateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/cluster-workflow-templates");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ClusterWorkflowTemplate>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ClusterWorkflowTemplate> ClusterWorkflowTemplateService_LintClusterWorkflowTemplateAsync(ClusterWorkflowTemplateLintRequest body)
        {
            return ClusterWorkflowTemplateService_LintClusterWorkflowTemplateAsync(body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ClusterWorkflowTemplate> ClusterWorkflowTemplateService_LintClusterWorkflowTemplateAsync(ClusterWorkflowTemplateLintRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/cluster-workflow-templates/lint");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ClusterWorkflowTemplate>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="getOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ClusterWorkflowTemplate> ClusterWorkflowTemplateService_GetClusterWorkflowTemplateAsync(string name, string getOptions_resourceVersion)
        {
            return ClusterWorkflowTemplateService_GetClusterWorkflowTemplateAsync(name, getOptions_resourceVersion, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="getOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ClusterWorkflowTemplate> ClusterWorkflowTemplateService_GetClusterWorkflowTemplateAsync(string name, string getOptions_resourceVersion, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/cluster-workflow-templates/{name}?");
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
            if (getOptions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("getOptions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(getOptions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ClusterWorkflowTemplate>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="name">DEPRECATED: This field is ignored.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ClusterWorkflowTemplate> ClusterWorkflowTemplateService_UpdateClusterWorkflowTemplateAsync(string name, ClusterWorkflowTemplateUpdateRequest body)
        {
            return ClusterWorkflowTemplateService_UpdateClusterWorkflowTemplateAsync(name, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="name">DEPRECATED: This field is ignored.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ClusterWorkflowTemplate> ClusterWorkflowTemplateService_UpdateClusterWorkflowTemplateAsync(string name, ClusterWorkflowTemplateUpdateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/cluster-workflow-templates/{name}");
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ClusterWorkflowTemplate>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ClusterWorkflowTemplateDeleteResponse> ClusterWorkflowTemplateService_DeleteClusterWorkflowTemplateAsync(string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun)
        {
            return ClusterWorkflowTemplateService_DeleteClusterWorkflowTemplateAsync(name, deleteOptions_gracePeriodSeconds, deleteOptions_preconditions_uid, deleteOptions_preconditions_resourceVersion, deleteOptions_orphanDependents, deleteOptions_propagationPolicy, deleteOptions_dryRun, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ClusterWorkflowTemplateDeleteResponse> ClusterWorkflowTemplateService_DeleteClusterWorkflowTemplateAsync(string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun, System.Threading.CancellationToken cancellationToken)
        {
            if (name == null)
                throw new System.ArgumentNullException("name");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/cluster-workflow-templates/{name}?");
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
            if (deleteOptions_gracePeriodSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.gracePeriodSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_gracePeriodSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_preconditions_uid != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.preconditions.uid") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_preconditions_uid, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_preconditions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.preconditions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_preconditions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_orphanDependents != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.orphanDependents") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_orphanDependents, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_propagationPolicy != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.propagationPolicy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_propagationPolicy, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_dryRun != null)
            {
                foreach (var item_ in deleteOptions_dryRun) { urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.dryRun") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ClusterWorkflowTemplateDeleteResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CronWorkflowList> CronWorkflowService_ListCronWorkflowsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue)
        {
            return CronWorkflowService_ListCronWorkflowsAsync(@namespace, listOptions_labelSelector, listOptions_fieldSelector, listOptions_watch, listOptions_allowWatchBookmarks, listOptions_resourceVersion, listOptions_resourceVersionMatch, listOptions_timeoutSeconds, listOptions_limit, listOptions_continue, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CronWorkflowList> CronWorkflowService_ListCronWorkflowsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/cron-workflows/{namespace}?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (listOptions_labelSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.labelSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_labelSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_fieldSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.fieldSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_fieldSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_watch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.watch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_watch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_allowWatchBookmarks != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.allowWatchBookmarks") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_allowWatchBookmarks, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersionMatch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersionMatch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersionMatch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_timeoutSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.timeoutSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_timeoutSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_limit != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.limit") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_continue != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.continue") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_continue, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CronWorkflowList>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CronWorkflow> CronWorkflowService_CreateCronWorkflowAsync(string @namespace, CreateCronWorkflowRequest body)
        {
            return CronWorkflowService_CreateCronWorkflowAsync(@namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CronWorkflow> CronWorkflowService_CreateCronWorkflowAsync(string @namespace, CreateCronWorkflowRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/cron-workflows/{namespace}");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CronWorkflow>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CronWorkflow> CronWorkflowService_LintCronWorkflowAsync(string @namespace, LintCronWorkflowRequest body)
        {
            return CronWorkflowService_LintCronWorkflowAsync(@namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CronWorkflow> CronWorkflowService_LintCronWorkflowAsync(string @namespace, LintCronWorkflowRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/cron-workflows/{namespace}/lint");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CronWorkflow>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="getOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CronWorkflow> CronWorkflowService_GetCronWorkflowAsync(string @namespace, string name, string getOptions_resourceVersion)
        {
            return CronWorkflowService_GetCronWorkflowAsync(@namespace, name, getOptions_resourceVersion, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="getOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CronWorkflow> CronWorkflowService_GetCronWorkflowAsync(string @namespace, string name, string getOptions_resourceVersion, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/cron-workflows/{namespace}/{name}?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
            if (getOptions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("getOptions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(getOptions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CronWorkflow>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="name">DEPRECATED: This field is ignored.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CronWorkflow> CronWorkflowService_UpdateCronWorkflowAsync(string @namespace, string name, UpdateCronWorkflowRequest body)
        {
            return CronWorkflowService_UpdateCronWorkflowAsync(@namespace, name, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="name">DEPRECATED: This field is ignored.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CronWorkflow> CronWorkflowService_UpdateCronWorkflowAsync(string @namespace, string name, UpdateCronWorkflowRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/cron-workflows/{namespace}/{name}");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CronWorkflow>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CronWorkflowDeletedResponse> CronWorkflowService_DeleteCronWorkflowAsync(string @namespace, string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun)
        {
            return CronWorkflowService_DeleteCronWorkflowAsync(@namespace, name, deleteOptions_gracePeriodSeconds, deleteOptions_preconditions_uid, deleteOptions_preconditions_resourceVersion, deleteOptions_orphanDependents, deleteOptions_propagationPolicy, deleteOptions_dryRun, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CronWorkflowDeletedResponse> CronWorkflowService_DeleteCronWorkflowAsync(string @namespace, string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/cron-workflows/{namespace}/{name}?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
            if (deleteOptions_gracePeriodSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.gracePeriodSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_gracePeriodSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_preconditions_uid != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.preconditions.uid") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_preconditions_uid, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_preconditions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.preconditions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_preconditions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_orphanDependents != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.orphanDependents") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_orphanDependents, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_propagationPolicy != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.propagationPolicy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_propagationPolicy, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_dryRun != null)
            {
                foreach (var item_ in deleteOptions_dryRun) { urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.dryRun") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CronWorkflowDeletedResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CronWorkflow> CronWorkflowService_ResumeCronWorkflowAsync(string @namespace, string name, CronWorkflowResumeRequest body)
        {
            return CronWorkflowService_ResumeCronWorkflowAsync(@namespace, name, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CronWorkflow> CronWorkflowService_ResumeCronWorkflowAsync(string @namespace, string name, CronWorkflowResumeRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/cron-workflows/{namespace}/{name}/resume");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CronWorkflow>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CronWorkflow> CronWorkflowService_SuspendCronWorkflowAsync(string @namespace, string name, CronWorkflowSuspendRequest body)
        {
            return CronWorkflowService_SuspendCronWorkflowAsync(@namespace, name, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CronWorkflow> CronWorkflowService_SuspendCronWorkflowAsync(string @namespace, string name, CronWorkflowSuspendRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/cron-workflows/{namespace}/{name}/suspend");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CronWorkflow>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<EventSourceList> EventSourceService_ListEventSourcesAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue)
        {
            return EventSourceService_ListEventSourcesAsync(@namespace, listOptions_labelSelector, listOptions_fieldSelector, listOptions_watch, listOptions_allowWatchBookmarks, listOptions_resourceVersion, listOptions_resourceVersionMatch, listOptions_timeoutSeconds, listOptions_limit, listOptions_continue, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<EventSourceList> EventSourceService_ListEventSourcesAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/event-sources/{namespace}?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (listOptions_labelSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.labelSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_labelSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_fieldSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.fieldSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_fieldSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_watch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.watch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_watch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_allowWatchBookmarks != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.allowWatchBookmarks") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_allowWatchBookmarks, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersionMatch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersionMatch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersionMatch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_timeoutSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.timeoutSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_timeoutSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_limit != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.limit") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_continue != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.continue") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_continue, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<EventSourceList>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<EventSource> EventSourceService_CreateEventSourceAsync(string @namespace, CreateEventSourceRequest body)
        {
            return EventSourceService_CreateEventSourceAsync(@namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<EventSource> EventSourceService_CreateEventSourceAsync(string @namespace, CreateEventSourceRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/event-sources/{namespace}");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<EventSource>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<EventSource> EventSourceService_GetEventSourceAsync(string @namespace, string name)
        {
            return EventSourceService_GetEventSourceAsync(@namespace, name, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<EventSource> EventSourceService_GetEventSourceAsync(string @namespace, string name, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/event-sources/{namespace}/{name}");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<EventSource>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<EventSource> EventSourceService_UpdateEventSourceAsync(string @namespace, string name, UpdateEventSourceRequest body)
        {
            return EventSourceService_UpdateEventSourceAsync(@namespace, name, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<EventSource> EventSourceService_UpdateEventSourceAsync(string @namespace, string name, UpdateEventSourceRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/event-sources/{namespace}/{name}");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<EventSource>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<EventSourceDeletedResponse> EventSourceService_DeleteEventSourceAsync(string @namespace, string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun)
        {
            return EventSourceService_DeleteEventSourceAsync(@namespace, name, deleteOptions_gracePeriodSeconds, deleteOptions_preconditions_uid, deleteOptions_preconditions_resourceVersion, deleteOptions_orphanDependents, deleteOptions_propagationPolicy, deleteOptions_dryRun, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<EventSourceDeletedResponse> EventSourceService_DeleteEventSourceAsync(string @namespace, string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/event-sources/{namespace}/{name}?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
            if (deleteOptions_gracePeriodSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.gracePeriodSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_gracePeriodSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_preconditions_uid != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.preconditions.uid") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_preconditions_uid, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_preconditions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.preconditions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_preconditions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_orphanDependents != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.orphanDependents") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_orphanDependents, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_propagationPolicy != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.propagationPolicy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_propagationPolicy, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_dryRun != null)
            {
                foreach (var item_ in deleteOptions_dryRun) { urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.dryRun") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<EventSourceDeletedResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="namespace">The namespace for the io.argoproj.workflow.v1alpha1. This can be empty if the client has cluster scoped permissions.
        /// <br/>If empty, then the event is "broadcast" to workflow event binding in all namespaces.</param>
        /// <param name="discriminator">Optional discriminator for the io.argoproj.workflow.v1alpha1. This should almost always be empty.
        /// <br/>Used for edge-cases where the event payload alone is not provide enough information to discriminate the event.
        /// <br/>This MUST NOT be used as security mechanism, e.g. to allow two clients to use the same access token, or
        /// <br/>to support webhooks on unsecured server. Instead, use access tokens.
        /// <br/>This is made available as `discriminator` in the event binding selector (`/spec/event/selector)`</param>
        /// <param name="body">The event itself can be any data.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<EventResponse> EventService_ReceiveEventAsync(string @namespace, string discriminator, Item body)
        {
            return EventService_ReceiveEventAsync(@namespace, discriminator, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="namespace">The namespace for the io.argoproj.workflow.v1alpha1. This can be empty if the client has cluster scoped permissions.
        /// <br/>If empty, then the event is "broadcast" to workflow event binding in all namespaces.</param>
        /// <param name="discriminator">Optional discriminator for the io.argoproj.workflow.v1alpha1. This should almost always be empty.
        /// <br/>Used for edge-cases where the event payload alone is not provide enough information to discriminate the event.
        /// <br/>This MUST NOT be used as security mechanism, e.g. to allow two clients to use the same access token, or
        /// <br/>to support webhooks on unsecured server. Instead, use access tokens.
        /// <br/>This is made available as `discriminator` in the event binding selector (`/spec/event/selector)`</param>
        /// <param name="body">The event itself can be any data.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<EventResponse> EventService_ReceiveEventAsync(string @namespace, string discriminator, Item body, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (discriminator == null)
                throw new System.ArgumentNullException("discriminator");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/events/{namespace}/{discriminator}");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{discriminator}", System.Uri.EscapeDataString(ConvertToString(discriminator, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<EventResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<InfoResponse> InfoService_GetInfoAsync()
        {
            return InfoService_GetInfoAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<InfoResponse> InfoService_GetInfoAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/info");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<InfoResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<PipelineList> PipelineService_ListPipelinesAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue)
        {
            return PipelineService_ListPipelinesAsync(@namespace, listOptions_labelSelector, listOptions_fieldSelector, listOptions_watch, listOptions_allowWatchBookmarks, listOptions_resourceVersion, listOptions_resourceVersionMatch, listOptions_timeoutSeconds, listOptions_limit, listOptions_continue, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<PipelineList> PipelineService_ListPipelinesAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/pipelines/{namespace}?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (listOptions_labelSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.labelSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_labelSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_fieldSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.fieldSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_fieldSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_watch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.watch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_watch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_allowWatchBookmarks != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.allowWatchBookmarks") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_allowWatchBookmarks, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersionMatch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersionMatch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersionMatch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_timeoutSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.timeoutSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_timeoutSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_limit != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.limit") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_continue != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.continue") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_continue, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<PipelineList>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="getOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Pipeline> PipelineService_GetPipelineAsync(string @namespace, string name, string getOptions_resourceVersion)
        {
            return PipelineService_GetPipelineAsync(@namespace, name, getOptions_resourceVersion, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="getOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Pipeline> PipelineService_GetPipelineAsync(string @namespace, string name, string getOptions_resourceVersion, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/pipelines/{namespace}/{name}?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
            if (getOptions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("getOptions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(getOptions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Pipeline>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<DeletePipelineResponse> PipelineService_DeletePipelineAsync(string @namespace, string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun)
        {
            return PipelineService_DeletePipelineAsync(@namespace, name, deleteOptions_gracePeriodSeconds, deleteOptions_preconditions_uid, deleteOptions_preconditions_resourceVersion, deleteOptions_orphanDependents, deleteOptions_propagationPolicy, deleteOptions_dryRun, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<DeletePipelineResponse> PipelineService_DeletePipelineAsync(string @namespace, string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/pipelines/{namespace}/{name}?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
            if (deleteOptions_gracePeriodSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.gracePeriodSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_gracePeriodSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_preconditions_uid != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.preconditions.uid") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_preconditions_uid, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_preconditions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.preconditions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_preconditions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_orphanDependents != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.orphanDependents") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_orphanDependents, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_propagationPolicy != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.propagationPolicy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_propagationPolicy, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_dryRun != null)
            {
                foreach (var item_ in deleteOptions_dryRun) { urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.dryRun") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DeletePipelineResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<RestartPipelineResponse> PipelineService_RestartPipelineAsync(string @namespace, string name)
        {
            return PipelineService_RestartPipelineAsync(@namespace, name, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<RestartPipelineResponse> PipelineService_RestartPipelineAsync(string @namespace, string name, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/pipelines/{namespace}/{name}/restart");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<RestartPipelineResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SensorList> SensorService_ListSensorsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue)
        {
            return SensorService_ListSensorsAsync(@namespace, listOptions_labelSelector, listOptions_fieldSelector, listOptions_watch, listOptions_allowWatchBookmarks, listOptions_resourceVersion, listOptions_resourceVersionMatch, listOptions_timeoutSeconds, listOptions_limit, listOptions_continue, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SensorList> SensorService_ListSensorsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/sensors/{namespace}?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (listOptions_labelSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.labelSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_labelSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_fieldSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.fieldSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_fieldSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_watch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.watch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_watch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_allowWatchBookmarks != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.allowWatchBookmarks") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_allowWatchBookmarks, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersionMatch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersionMatch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersionMatch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_timeoutSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.timeoutSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_timeoutSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_limit != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.limit") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_continue != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.continue") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_continue, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SensorList>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Sensor> SensorService_CreateSensorAsync(string @namespace, CreateSensorRequest body)
        {
            return SensorService_CreateSensorAsync(@namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Sensor> SensorService_CreateSensorAsync(string @namespace, CreateSensorRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/sensors/{namespace}");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Sensor>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="getOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Sensor> SensorService_GetSensorAsync(string @namespace, string name, string getOptions_resourceVersion)
        {
            return SensorService_GetSensorAsync(@namespace, name, getOptions_resourceVersion, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="getOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Sensor> SensorService_GetSensorAsync(string @namespace, string name, string getOptions_resourceVersion, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/sensors/{namespace}/{name}?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
            if (getOptions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("getOptions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(getOptions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Sensor>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Sensor> SensorService_UpdateSensorAsync(string @namespace, string name, UpdateSensorRequest body)
        {
            return SensorService_UpdateSensorAsync(@namespace, name, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Sensor> SensorService_UpdateSensorAsync(string @namespace, string name, UpdateSensorRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/sensors/{namespace}/{name}");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Sensor>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<DeleteSensorResponse> SensorService_DeleteSensorAsync(string @namespace, string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun)
        {
            return SensorService_DeleteSensorAsync(@namespace, name, deleteOptions_gracePeriodSeconds, deleteOptions_preconditions_uid, deleteOptions_preconditions_resourceVersion, deleteOptions_orphanDependents, deleteOptions_propagationPolicy, deleteOptions_dryRun, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<DeleteSensorResponse> SensorService_DeleteSensorAsync(string @namespace, string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/sensors/{namespace}/{name}?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
            if (deleteOptions_gracePeriodSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.gracePeriodSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_gracePeriodSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_preconditions_uid != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.preconditions.uid") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_preconditions_uid, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_preconditions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.preconditions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_preconditions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_orphanDependents != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.orphanDependents") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_orphanDependents, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_propagationPolicy != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.propagationPolicy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_propagationPolicy, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_dryRun != null)
            {
                foreach (var item_ in deleteOptions_dryRun) { urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.dryRun") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DeleteSensorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response> EventSourceService_WatchEventSourcesAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue)
        {
            return EventSourceService_WatchEventSourcesAsync(@namespace, listOptions_labelSelector, listOptions_fieldSelector, listOptions_watch, listOptions_allowWatchBookmarks, listOptions_resourceVersion, listOptions_resourceVersionMatch, listOptions_timeoutSeconds, listOptions_limit, listOptions_continue, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response> EventSourceService_WatchEventSourcesAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/stream/event-sources/{namespace}?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (listOptions_labelSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.labelSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_labelSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_fieldSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.fieldSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_fieldSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_watch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.watch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_watch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_allowWatchBookmarks != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.allowWatchBookmarks") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_allowWatchBookmarks, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersionMatch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersionMatch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersionMatch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_timeoutSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.timeoutSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_timeoutSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_limit != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.limit") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_continue != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.continue") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_continue, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="name">optional - only return entries for this event source.</param>
        /// <param name="eventSourceType">optional - only return entries for this event source type (e.g. `webhook`).</param>
        /// <param name="eventName">optional - only return entries for this event name (e.g. `example`).</param>
        /// <param name="grep">optional - only return entries where `msg` matches this regular expression.</param>
        /// <param name="podLogOptions_container">The container for which to stream logs. Defaults to only container if there is one container in the pod.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_follow">Follow the log stream of the pod. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_previous">Return previous terminated container logs. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value
        /// <br/>precedes the time a pod was started, only logs since the pod start will be returned.
        /// <br/>If this value is in the future, no logs will be returned.
        /// <br/>Only one of sinceSeconds or sinceTime may be specified.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_sinceTime_seconds">Represents seconds of UTC time since Unix epoch
        /// <br/>1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
        /// <br/>9999-12-31T23:59:59Z inclusive.</param>
        /// <param name="podLogOptions_sinceTime_nanos">Non-negative fractions of a second at nanosecond resolution. Negative
        /// <br/>second values with fractions must still have non-negative nanos values
        /// <br/>that count forward in time. Must be from 0 to 999,999,999
        /// <br/>inclusive. This field may be limited in precision depending on context.</param>
        /// <param name="podLogOptions_timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
        /// <br/>of log output. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_tailLines">If set, the number of lines from the end of the logs to show. If not specified,
        /// <br/>logs are shown from the creation of the container or sinceSeconds or sinceTime
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_limitBytes">If set, the number of bytes to read from the server before terminating the
        /// <br/>log output. This may not display a complete final line of logging, and may return
        /// <br/>slightly more or slightly less than the specified limit.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_insecureSkipTLSVerifyBackend">insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
        /// <br/>serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
        /// <br/>and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
        /// <br/>kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
        /// <br/>connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
        /// <br/>the actual log data coming from the real kubelet).
        /// <br/>+optional.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response2> EventSourceService_EventSourcesLogsAsync(string @namespace, string name, string eventSourceType, string eventName, string grep, string podLogOptions_container, bool? podLogOptions_follow, bool? podLogOptions_previous, string podLogOptions_sinceSeconds, string podLogOptions_sinceTime_seconds, int? podLogOptions_sinceTime_nanos, bool? podLogOptions_timestamps, string podLogOptions_tailLines, string podLogOptions_limitBytes, bool? podLogOptions_insecureSkipTLSVerifyBackend)
        {
            return EventSourceService_EventSourcesLogsAsync(@namespace, name, eventSourceType, eventName, grep, podLogOptions_container, podLogOptions_follow, podLogOptions_previous, podLogOptions_sinceSeconds, podLogOptions_sinceTime_seconds, podLogOptions_sinceTime_nanos, podLogOptions_timestamps, podLogOptions_tailLines, podLogOptions_limitBytes, podLogOptions_insecureSkipTLSVerifyBackend, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="name">optional - only return entries for this event source.</param>
        /// <param name="eventSourceType">optional - only return entries for this event source type (e.g. `webhook`).</param>
        /// <param name="eventName">optional - only return entries for this event name (e.g. `example`).</param>
        /// <param name="grep">optional - only return entries where `msg` matches this regular expression.</param>
        /// <param name="podLogOptions_container">The container for which to stream logs. Defaults to only container if there is one container in the pod.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_follow">Follow the log stream of the pod. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_previous">Return previous terminated container logs. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value
        /// <br/>precedes the time a pod was started, only logs since the pod start will be returned.
        /// <br/>If this value is in the future, no logs will be returned.
        /// <br/>Only one of sinceSeconds or sinceTime may be specified.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_sinceTime_seconds">Represents seconds of UTC time since Unix epoch
        /// <br/>1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
        /// <br/>9999-12-31T23:59:59Z inclusive.</param>
        /// <param name="podLogOptions_sinceTime_nanos">Non-negative fractions of a second at nanosecond resolution. Negative
        /// <br/>second values with fractions must still have non-negative nanos values
        /// <br/>that count forward in time. Must be from 0 to 999,999,999
        /// <br/>inclusive. This field may be limited in precision depending on context.</param>
        /// <param name="podLogOptions_timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
        /// <br/>of log output. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_tailLines">If set, the number of lines from the end of the logs to show. If not specified,
        /// <br/>logs are shown from the creation of the container or sinceSeconds or sinceTime
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_limitBytes">If set, the number of bytes to read from the server before terminating the
        /// <br/>log output. This may not display a complete final line of logging, and may return
        /// <br/>slightly more or slightly less than the specified limit.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_insecureSkipTLSVerifyBackend">insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
        /// <br/>serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
        /// <br/>and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
        /// <br/>kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
        /// <br/>connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
        /// <br/>the actual log data coming from the real kubelet).
        /// <br/>+optional.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response2> EventSourceService_EventSourcesLogsAsync(string @namespace, string name, string eventSourceType, string eventName, string grep, string podLogOptions_container, bool? podLogOptions_follow, bool? podLogOptions_previous, string podLogOptions_sinceSeconds, string podLogOptions_sinceTime_seconds, int? podLogOptions_sinceTime_nanos, bool? podLogOptions_timestamps, string podLogOptions_tailLines, string podLogOptions_limitBytes, bool? podLogOptions_insecureSkipTLSVerifyBackend, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/stream/event-sources/{namespace}/logs?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (name != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("name") + "=").Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (eventSourceType != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("eventSourceType") + "=").Append(System.Uri.EscapeDataString(ConvertToString(eventSourceType, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (eventName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("eventName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(eventName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (grep != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("grep") + "=").Append(System.Uri.EscapeDataString(ConvertToString(grep, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_container != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.container") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_container, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_follow != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.follow") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_follow, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_previous != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.previous") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_previous, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_sinceSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.sinceSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_sinceSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_sinceTime_seconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.sinceTime.seconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_sinceTime_seconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_sinceTime_nanos != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.sinceTime.nanos") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_sinceTime_nanos, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_timestamps != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.timestamps") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_timestamps, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_tailLines != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.tailLines") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_tailLines, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_limitBytes != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.limitBytes") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_limitBytes, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_insecureSkipTLSVerifyBackend != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.insecureSkipTLSVerifyBackend") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_insecureSkipTLSVerifyBackend, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response2>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response3> WorkflowService_WatchEventsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue)
        {
            return WorkflowService_WatchEventsAsync(@namespace, listOptions_labelSelector, listOptions_fieldSelector, listOptions_watch, listOptions_allowWatchBookmarks, listOptions_resourceVersion, listOptions_resourceVersionMatch, listOptions_timeoutSeconds, listOptions_limit, listOptions_continue, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response3> WorkflowService_WatchEventsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/stream/events/{namespace}?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (listOptions_labelSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.labelSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_labelSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_fieldSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.fieldSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_fieldSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_watch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.watch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_watch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_allowWatchBookmarks != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.allowWatchBookmarks") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_allowWatchBookmarks, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersionMatch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersionMatch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersionMatch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_timeoutSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.timeoutSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_timeoutSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_limit != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.limit") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_continue != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.continue") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_continue, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response3>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response4> PipelineService_WatchPipelinesAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue)
        {
            return PipelineService_WatchPipelinesAsync(@namespace, listOptions_labelSelector, listOptions_fieldSelector, listOptions_watch, listOptions_allowWatchBookmarks, listOptions_resourceVersion, listOptions_resourceVersionMatch, listOptions_timeoutSeconds, listOptions_limit, listOptions_continue, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response4> PipelineService_WatchPipelinesAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/stream/pipelines/{namespace}?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (listOptions_labelSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.labelSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_labelSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_fieldSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.fieldSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_fieldSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_watch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.watch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_watch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_allowWatchBookmarks != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.allowWatchBookmarks") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_allowWatchBookmarks, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersionMatch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersionMatch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersionMatch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_timeoutSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.timeoutSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_timeoutSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_limit != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.limit") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_continue != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.continue") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_continue, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response4>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="name">optional - only return entries for this pipeline.</param>
        /// <param name="stepName">optional - only return entries for this step.</param>
        /// <param name="grep">optional - only return entries which match this expresssion.</param>
        /// <param name="podLogOptions_container">The container for which to stream logs. Defaults to only container if there is one container in the pod.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_follow">Follow the log stream of the pod. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_previous">Return previous terminated container logs. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value
        /// <br/>precedes the time a pod was started, only logs since the pod start will be returned.
        /// <br/>If this value is in the future, no logs will be returned.
        /// <br/>Only one of sinceSeconds or sinceTime may be specified.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_sinceTime_seconds">Represents seconds of UTC time since Unix epoch
        /// <br/>1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
        /// <br/>9999-12-31T23:59:59Z inclusive.</param>
        /// <param name="podLogOptions_sinceTime_nanos">Non-negative fractions of a second at nanosecond resolution. Negative
        /// <br/>second values with fractions must still have non-negative nanos values
        /// <br/>that count forward in time. Must be from 0 to 999,999,999
        /// <br/>inclusive. This field may be limited in precision depending on context.</param>
        /// <param name="podLogOptions_timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
        /// <br/>of log output. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_tailLines">If set, the number of lines from the end of the logs to show. If not specified,
        /// <br/>logs are shown from the creation of the container or sinceSeconds or sinceTime
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_limitBytes">If set, the number of bytes to read from the server before terminating the
        /// <br/>log output. This may not display a complete final line of logging, and may return
        /// <br/>slightly more or slightly less than the specified limit.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_insecureSkipTLSVerifyBackend">insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
        /// <br/>serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
        /// <br/>and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
        /// <br/>kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
        /// <br/>connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
        /// <br/>the actual log data coming from the real kubelet).
        /// <br/>+optional.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response5> PipelineService_PipelineLogsAsync(string @namespace, string name, string stepName, string grep, string podLogOptions_container, bool? podLogOptions_follow, bool? podLogOptions_previous, string podLogOptions_sinceSeconds, string podLogOptions_sinceTime_seconds, int? podLogOptions_sinceTime_nanos, bool? podLogOptions_timestamps, string podLogOptions_tailLines, string podLogOptions_limitBytes, bool? podLogOptions_insecureSkipTLSVerifyBackend)
        {
            return PipelineService_PipelineLogsAsync(@namespace, name, stepName, grep, podLogOptions_container, podLogOptions_follow, podLogOptions_previous, podLogOptions_sinceSeconds, podLogOptions_sinceTime_seconds, podLogOptions_sinceTime_nanos, podLogOptions_timestamps, podLogOptions_tailLines, podLogOptions_limitBytes, podLogOptions_insecureSkipTLSVerifyBackend, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="name">optional - only return entries for this pipeline.</param>
        /// <param name="stepName">optional - only return entries for this step.</param>
        /// <param name="grep">optional - only return entries which match this expresssion.</param>
        /// <param name="podLogOptions_container">The container for which to stream logs. Defaults to only container if there is one container in the pod.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_follow">Follow the log stream of the pod. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_previous">Return previous terminated container logs. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value
        /// <br/>precedes the time a pod was started, only logs since the pod start will be returned.
        /// <br/>If this value is in the future, no logs will be returned.
        /// <br/>Only one of sinceSeconds or sinceTime may be specified.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_sinceTime_seconds">Represents seconds of UTC time since Unix epoch
        /// <br/>1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
        /// <br/>9999-12-31T23:59:59Z inclusive.</param>
        /// <param name="podLogOptions_sinceTime_nanos">Non-negative fractions of a second at nanosecond resolution. Negative
        /// <br/>second values with fractions must still have non-negative nanos values
        /// <br/>that count forward in time. Must be from 0 to 999,999,999
        /// <br/>inclusive. This field may be limited in precision depending on context.</param>
        /// <param name="podLogOptions_timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
        /// <br/>of log output. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_tailLines">If set, the number of lines from the end of the logs to show. If not specified,
        /// <br/>logs are shown from the creation of the container or sinceSeconds or sinceTime
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_limitBytes">If set, the number of bytes to read from the server before terminating the
        /// <br/>log output. This may not display a complete final line of logging, and may return
        /// <br/>slightly more or slightly less than the specified limit.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_insecureSkipTLSVerifyBackend">insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
        /// <br/>serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
        /// <br/>and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
        /// <br/>kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
        /// <br/>connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
        /// <br/>the actual log data coming from the real kubelet).
        /// <br/>+optional.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response5> PipelineService_PipelineLogsAsync(string @namespace, string name, string stepName, string grep, string podLogOptions_container, bool? podLogOptions_follow, bool? podLogOptions_previous, string podLogOptions_sinceSeconds, string podLogOptions_sinceTime_seconds, int? podLogOptions_sinceTime_nanos, bool? podLogOptions_timestamps, string podLogOptions_tailLines, string podLogOptions_limitBytes, bool? podLogOptions_insecureSkipTLSVerifyBackend, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/stream/pipelines/{namespace}/logs?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (name != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("name") + "=").Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (stepName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("stepName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(stepName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (grep != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("grep") + "=").Append(System.Uri.EscapeDataString(ConvertToString(grep, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_container != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.container") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_container, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_follow != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.follow") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_follow, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_previous != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.previous") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_previous, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_sinceSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.sinceSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_sinceSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_sinceTime_seconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.sinceTime.seconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_sinceTime_seconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_sinceTime_nanos != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.sinceTime.nanos") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_sinceTime_nanos, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_timestamps != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.timestamps") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_timestamps, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_tailLines != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.tailLines") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_tailLines, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_limitBytes != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.limitBytes") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_limitBytes, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_insecureSkipTLSVerifyBackend != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.insecureSkipTLSVerifyBackend") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_insecureSkipTLSVerifyBackend, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response5>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response6> SensorService_WatchSensorsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue)
        {
            return SensorService_WatchSensorsAsync(@namespace, listOptions_labelSelector, listOptions_fieldSelector, listOptions_watch, listOptions_allowWatchBookmarks, listOptions_resourceVersion, listOptions_resourceVersionMatch, listOptions_timeoutSeconds, listOptions_limit, listOptions_continue, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response6> SensorService_WatchSensorsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/stream/sensors/{namespace}?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (listOptions_labelSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.labelSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_labelSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_fieldSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.fieldSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_fieldSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_watch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.watch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_watch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_allowWatchBookmarks != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.allowWatchBookmarks") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_allowWatchBookmarks, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersionMatch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersionMatch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersionMatch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_timeoutSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.timeoutSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_timeoutSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_limit != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.limit") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_continue != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.continue") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_continue, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response6>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="name">optional - only return entries for this sensor name.</param>
        /// <param name="triggerName">optional - only return entries for this trigger.</param>
        /// <param name="grep">option - only return entries where `msg` contains this regular expressions.</param>
        /// <param name="podLogOptions_container">The container for which to stream logs. Defaults to only container if there is one container in the pod.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_follow">Follow the log stream of the pod. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_previous">Return previous terminated container logs. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value
        /// <br/>precedes the time a pod was started, only logs since the pod start will be returned.
        /// <br/>If this value is in the future, no logs will be returned.
        /// <br/>Only one of sinceSeconds or sinceTime may be specified.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_sinceTime_seconds">Represents seconds of UTC time since Unix epoch
        /// <br/>1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
        /// <br/>9999-12-31T23:59:59Z inclusive.</param>
        /// <param name="podLogOptions_sinceTime_nanos">Non-negative fractions of a second at nanosecond resolution. Negative
        /// <br/>second values with fractions must still have non-negative nanos values
        /// <br/>that count forward in time. Must be from 0 to 999,999,999
        /// <br/>inclusive. This field may be limited in precision depending on context.</param>
        /// <param name="podLogOptions_timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
        /// <br/>of log output. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_tailLines">If set, the number of lines from the end of the logs to show. If not specified,
        /// <br/>logs are shown from the creation of the container or sinceSeconds or sinceTime
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_limitBytes">If set, the number of bytes to read from the server before terminating the
        /// <br/>log output. This may not display a complete final line of logging, and may return
        /// <br/>slightly more or slightly less than the specified limit.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_insecureSkipTLSVerifyBackend">insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
        /// <br/>serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
        /// <br/>and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
        /// <br/>kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
        /// <br/>connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
        /// <br/>the actual log data coming from the real kubelet).
        /// <br/>+optional.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response7> SensorService_SensorsLogsAsync(string @namespace, string name, string triggerName, string grep, string podLogOptions_container, bool? podLogOptions_follow, bool? podLogOptions_previous, string podLogOptions_sinceSeconds, string podLogOptions_sinceTime_seconds, int? podLogOptions_sinceTime_nanos, bool? podLogOptions_timestamps, string podLogOptions_tailLines, string podLogOptions_limitBytes, bool? podLogOptions_insecureSkipTLSVerifyBackend)
        {
            return SensorService_SensorsLogsAsync(@namespace, name, triggerName, grep, podLogOptions_container, podLogOptions_follow, podLogOptions_previous, podLogOptions_sinceSeconds, podLogOptions_sinceTime_seconds, podLogOptions_sinceTime_nanos, podLogOptions_timestamps, podLogOptions_tailLines, podLogOptions_limitBytes, podLogOptions_insecureSkipTLSVerifyBackend, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="name">optional - only return entries for this sensor name.</param>
        /// <param name="triggerName">optional - only return entries for this trigger.</param>
        /// <param name="grep">option - only return entries where `msg` contains this regular expressions.</param>
        /// <param name="podLogOptions_container">The container for which to stream logs. Defaults to only container if there is one container in the pod.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_follow">Follow the log stream of the pod. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_previous">Return previous terminated container logs. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value
        /// <br/>precedes the time a pod was started, only logs since the pod start will be returned.
        /// <br/>If this value is in the future, no logs will be returned.
        /// <br/>Only one of sinceSeconds or sinceTime may be specified.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_sinceTime_seconds">Represents seconds of UTC time since Unix epoch
        /// <br/>1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
        /// <br/>9999-12-31T23:59:59Z inclusive.</param>
        /// <param name="podLogOptions_sinceTime_nanos">Non-negative fractions of a second at nanosecond resolution. Negative
        /// <br/>second values with fractions must still have non-negative nanos values
        /// <br/>that count forward in time. Must be from 0 to 999,999,999
        /// <br/>inclusive. This field may be limited in precision depending on context.</param>
        /// <param name="podLogOptions_timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
        /// <br/>of log output. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_tailLines">If set, the number of lines from the end of the logs to show. If not specified,
        /// <br/>logs are shown from the creation of the container or sinceSeconds or sinceTime
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_limitBytes">If set, the number of bytes to read from the server before terminating the
        /// <br/>log output. This may not display a complete final line of logging, and may return
        /// <br/>slightly more or slightly less than the specified limit.
        /// <br/>+optional.</param>
        /// <param name="podLogOptions_insecureSkipTLSVerifyBackend">insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
        /// <br/>serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
        /// <br/>and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
        /// <br/>kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
        /// <br/>connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
        /// <br/>the actual log data coming from the real kubelet).
        /// <br/>+optional.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response7> SensorService_SensorsLogsAsync(string @namespace, string name, string triggerName, string grep, string podLogOptions_container, bool? podLogOptions_follow, bool? podLogOptions_previous, string podLogOptions_sinceSeconds, string podLogOptions_sinceTime_seconds, int? podLogOptions_sinceTime_nanos, bool? podLogOptions_timestamps, string podLogOptions_tailLines, string podLogOptions_limitBytes, bool? podLogOptions_insecureSkipTLSVerifyBackend, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/stream/sensors/{namespace}/logs?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (name != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("name") + "=").Append(System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (triggerName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("triggerName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(triggerName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (grep != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("grep") + "=").Append(System.Uri.EscapeDataString(ConvertToString(grep, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_container != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.container") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_container, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_follow != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.follow") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_follow, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_previous != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.previous") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_previous, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_sinceSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.sinceSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_sinceSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_sinceTime_seconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.sinceTime.seconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_sinceTime_seconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_sinceTime_nanos != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.sinceTime.nanos") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_sinceTime_nanos, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_timestamps != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.timestamps") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_timestamps, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_tailLines != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.tailLines") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_tailLines, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_limitBytes != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.limitBytes") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_limitBytes, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (podLogOptions_insecureSkipTLSVerifyBackend != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podLogOptions.insecureSkipTLSVerifyBackend") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podLogOptions_insecureSkipTLSVerifyBackend, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response7>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response8> PipelineService_WatchStepsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue)
        {
            return PipelineService_WatchStepsAsync(@namespace, listOptions_labelSelector, listOptions_fieldSelector, listOptions_watch, listOptions_allowWatchBookmarks, listOptions_resourceVersion, listOptions_resourceVersionMatch, listOptions_timeoutSeconds, listOptions_limit, listOptions_continue, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response8> PipelineService_WatchStepsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/stream/steps/{namespace}?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (listOptions_labelSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.labelSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_labelSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_fieldSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.fieldSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_fieldSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_watch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.watch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_watch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_allowWatchBookmarks != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.allowWatchBookmarks") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_allowWatchBookmarks, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersionMatch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersionMatch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersionMatch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_timeoutSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.timeoutSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_timeoutSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_limit != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.limit") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_continue != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.continue") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_continue, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response8>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<GetUserInfoResponse> InfoService_GetUserInfoAsync()
        {
            return InfoService_GetUserInfoAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<GetUserInfoResponse> InfoService_GetUserInfoAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/userinfo");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<GetUserInfoResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Version> InfoService_GetVersionAsync()
        {
            return InfoService_GetVersionAsync(System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Version> InfoService_GetVersionAsync(System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/version");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Version>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<WorkflowEventBindingList> EventService_ListWorkflowEventBindingsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue)
        {
            return EventService_ListWorkflowEventBindingsAsync(@namespace, listOptions_labelSelector, listOptions_fieldSelector, listOptions_watch, listOptions_allowWatchBookmarks, listOptions_resourceVersion, listOptions_resourceVersionMatch, listOptions_timeoutSeconds, listOptions_limit, listOptions_continue, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<WorkflowEventBindingList> EventService_ListWorkflowEventBindingsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/workflow-event-bindings/{namespace}?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (listOptions_labelSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.labelSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_labelSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_fieldSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.fieldSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_fieldSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_watch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.watch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_watch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_allowWatchBookmarks != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.allowWatchBookmarks") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_allowWatchBookmarks, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersionMatch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersionMatch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersionMatch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_timeoutSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.timeoutSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_timeoutSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_limit != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.limit") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_continue != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.continue") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_continue, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<WorkflowEventBindingList>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response9> WorkflowService_WatchWorkflowsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, string fields)
        {
            return WorkflowService_WatchWorkflowsAsync(@namespace, listOptions_labelSelector, listOptions_fieldSelector, listOptions_watch, listOptions_allowWatchBookmarks, listOptions_resourceVersion, listOptions_resourceVersionMatch, listOptions_timeoutSeconds, listOptions_limit, listOptions_continue, fields, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response9> WorkflowService_WatchWorkflowsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, string fields, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/workflow-events/{namespace}?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (listOptions_labelSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.labelSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_labelSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_fieldSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.fieldSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_fieldSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_watch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.watch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_watch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_allowWatchBookmarks != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.allowWatchBookmarks") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_allowWatchBookmarks, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersionMatch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersionMatch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersionMatch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_timeoutSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.timeoutSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_timeoutSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_limit != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.limit") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_continue != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.continue") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_continue, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response9>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<WorkflowTemplateList> WorkflowTemplateService_ListWorkflowTemplatesAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue)
        {
            return WorkflowTemplateService_ListWorkflowTemplatesAsync(@namespace, listOptions_labelSelector, listOptions_fieldSelector, listOptions_watch, listOptions_allowWatchBookmarks, listOptions_resourceVersion, listOptions_resourceVersionMatch, listOptions_timeoutSeconds, listOptions_limit, listOptions_continue, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<WorkflowTemplateList> WorkflowTemplateService_ListWorkflowTemplatesAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/workflow-templates/{namespace}?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (listOptions_labelSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.labelSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_labelSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_fieldSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.fieldSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_fieldSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_watch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.watch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_watch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_allowWatchBookmarks != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.allowWatchBookmarks") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_allowWatchBookmarks, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersionMatch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersionMatch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersionMatch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_timeoutSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.timeoutSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_timeoutSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_limit != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.limit") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_continue != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.continue") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_continue, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<WorkflowTemplateList>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<WorkflowTemplate> WorkflowTemplateService_CreateWorkflowTemplateAsync(string @namespace, WorkflowTemplateCreateRequest body)
        {
            return WorkflowTemplateService_CreateWorkflowTemplateAsync(@namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<WorkflowTemplate> WorkflowTemplateService_CreateWorkflowTemplateAsync(string @namespace, WorkflowTemplateCreateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/workflow-templates/{namespace}");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<WorkflowTemplate>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<WorkflowTemplate> WorkflowTemplateService_LintWorkflowTemplateAsync(string @namespace, WorkflowTemplateLintRequest body)
        {
            return WorkflowTemplateService_LintWorkflowTemplateAsync(@namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<WorkflowTemplate> WorkflowTemplateService_LintWorkflowTemplateAsync(string @namespace, WorkflowTemplateLintRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/workflow-templates/{namespace}/lint");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<WorkflowTemplate>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="getOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<WorkflowTemplate> WorkflowTemplateService_GetWorkflowTemplateAsync(string @namespace, string name, string getOptions_resourceVersion)
        {
            return WorkflowTemplateService_GetWorkflowTemplateAsync(@namespace, name, getOptions_resourceVersion, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="getOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<WorkflowTemplate> WorkflowTemplateService_GetWorkflowTemplateAsync(string @namespace, string name, string getOptions_resourceVersion, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/workflow-templates/{namespace}/{name}?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
            if (getOptions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("getOptions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(getOptions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<WorkflowTemplate>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="name">DEPRECATED: This field is ignored.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<WorkflowTemplate> WorkflowTemplateService_UpdateWorkflowTemplateAsync(string @namespace, string name, WorkflowTemplateUpdateRequest body)
        {
            return WorkflowTemplateService_UpdateWorkflowTemplateAsync(@namespace, name, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="name">DEPRECATED: This field is ignored.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<WorkflowTemplate> WorkflowTemplateService_UpdateWorkflowTemplateAsync(string @namespace, string name, WorkflowTemplateUpdateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/workflow-templates/{namespace}/{name}");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<WorkflowTemplate>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<WorkflowTemplateDeleteResponse> WorkflowTemplateService_DeleteWorkflowTemplateAsync(string @namespace, string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun)
        {
            return WorkflowTemplateService_DeleteWorkflowTemplateAsync(@namespace, name, deleteOptions_gracePeriodSeconds, deleteOptions_preconditions_uid, deleteOptions_preconditions_resourceVersion, deleteOptions_orphanDependents, deleteOptions_propagationPolicy, deleteOptions_dryRun, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<WorkflowTemplateDeleteResponse> WorkflowTemplateService_DeleteWorkflowTemplateAsync(string @namespace, string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/workflow-templates/{namespace}/{name}?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
            if (deleteOptions_gracePeriodSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.gracePeriodSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_gracePeriodSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_preconditions_uid != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.preconditions.uid") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_preconditions_uid, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_preconditions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.preconditions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_preconditions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_orphanDependents != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.orphanDependents") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_orphanDependents, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_propagationPolicy != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.propagationPolicy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_propagationPolicy, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_dryRun != null)
            {
                foreach (var item_ in deleteOptions_dryRun) { urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.dryRun") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<WorkflowTemplateDeleteResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <param name="fields">Fields to be included or excluded in the response. e.g. "items.spec,items.status.phase", "-items.status.nodes".</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<WorkflowList> WorkflowService_ListWorkflowsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, string fields)
        {
            return WorkflowService_ListWorkflowsAsync(@namespace, listOptions_labelSelector, listOptions_fieldSelector, listOptions_watch, listOptions_allowWatchBookmarks, listOptions_resourceVersion, listOptions_resourceVersionMatch, listOptions_timeoutSeconds, listOptions_limit, listOptions_continue, fields, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="listOptions_labelSelector">A selector to restrict the list of returned objects by their labels.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_fieldSelector">A selector to restrict the list of returned objects by their fields.
        /// <br/>Defaults to everything.
        /// <br/>+optional.</param>
        /// <param name="listOptions_watch">Watch for changes to the described resources and return them as a stream of
        /// <br/>add, update, and remove notifications. Specify resourceVersion.
        /// <br/>+optional.</param>
        /// <param name="listOptions_allowWatchBookmarks">allowWatchBookmarks requests watch events with type "BOOKMARK".
        /// <br/>Servers that do not implement bookmarks may ignore this flag and
        /// <br/>bookmarks are sent at the server's discretion. Clients should not
        /// <br/>assume bookmarks are returned at any specific interval, nor may they
        /// <br/>assume the server will send any BOOKMARK event during a session.
        /// <br/>If this is not a watch, this field is ignored.
        /// <br/>+optional.</param>
        /// <param name="listOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_resourceVersionMatch">resourceVersionMatch determines how resourceVersion is applied to list calls.
        /// <br/>It is highly recommended that resourceVersionMatch be set for list calls where
        /// <br/>resourceVersion is set
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="listOptions_timeoutSeconds">Timeout for the list/watch call.
        /// <br/>This limits the duration of the call, regardless of any activity or inactivity.
        /// <br/>+optional.</param>
        /// <param name="listOptions_limit">limit is a maximum number of responses to return for a list call. If more items exist, the
        /// <br/>server will set the `continue` field on the list metadata to a value that can be used with the
        /// <br/>same initial query to retrieve the next set of results. Setting a limit may return fewer than
        /// <br/>the requested amount of items (up to zero items) in the event all requested objects are
        /// <br/>filtered out and clients should only use the presence of the continue field to determine whether
        /// <br/>more results are available. Servers may choose not to support the limit argument and will return
        /// <br/>all of the available results. If limit is specified and the continue field is empty, clients may
        /// <br/>assume that no more results are available. This field is not supported if watch is true.
        /// <br/>
        /// <br/>The server guarantees that the objects returned when using continue will be identical to issuing
        /// <br/>a single list call without a limit - that is, no objects created, modified, or deleted after the
        /// <br/>first request is issued will be included in any subsequent continued requests. This is sometimes
        /// <br/>referred to as a consistent snapshot, and ensures that a client that is using limit to receive
        /// <br/>smaller chunks of a very large result can ensure they see all possible objects. If objects are
        /// <br/>updated during a chunked list the version of the object that was present at the time the first list
        /// <br/>result was calculated is returned.</param>
        /// <param name="listOptions_continue">The continue option should be set when retrieving more results from the server. Since this value is
        /// <br/>server defined, clients may only use the continue value from a previous query result with identical
        /// <br/>query parameters (except for the value of continue) and the server may reject a continue value it
        /// <br/>does not recognize. If the specified continue value is no longer valid whether due to expiration
        /// <br/>(generally five to fifteen minutes) or a configuration change on the server, the server will
        /// <br/>respond with a 410 ResourceExpired error together with a continue token. If the client needs a
        /// <br/>consistent list, it must restart their list without the continue field. Otherwise, the client may
        /// <br/>send another list request with the token received with the 410 error, the server will respond with
        /// <br/>a list starting from the next key, but from the latest snapshot, which is inconsistent from the
        /// <br/>previous list results - objects that are created, modified, or deleted after the first list request
        /// <br/>will be included in the response, as long as their keys are after the "next key".
        /// <br/>
        /// <br/>This field is not supported when watch is true. Clients may start a watch from the last
        /// <br/>resourceVersion value returned by the server and not miss any modifications.</param>
        /// <param name="fields">Fields to be included or excluded in the response. e.g. "items.spec,items.status.phase", "-items.status.nodes".</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<WorkflowList> WorkflowService_ListWorkflowsAsync(string @namespace, string listOptions_labelSelector, string listOptions_fieldSelector, bool? listOptions_watch, bool? listOptions_allowWatchBookmarks, string listOptions_resourceVersion, string listOptions_resourceVersionMatch, string listOptions_timeoutSeconds, string listOptions_limit, string listOptions_continue, string fields, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/workflows/{namespace}?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            if (listOptions_labelSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.labelSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_labelSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_fieldSelector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.fieldSelector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_fieldSelector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_watch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.watch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_watch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_allowWatchBookmarks != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.allowWatchBookmarks") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_allowWatchBookmarks, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_resourceVersionMatch != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.resourceVersionMatch") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_resourceVersionMatch, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_timeoutSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.timeoutSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_timeoutSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_limit != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.limit") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_limit, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (listOptions_continue != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("listOptions.continue") + "=").Append(System.Uri.EscapeDataString(ConvertToString(listOptions_continue, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<WorkflowList>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Workflow> WorkflowService_CreateWorkflowAsync(string @namespace, WorkflowCreateRequest body)
        {
            return WorkflowService_CreateWorkflowAsync(@namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Workflow> WorkflowService_CreateWorkflowAsync(string @namespace, WorkflowCreateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/workflows/{namespace}");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Workflow>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Workflow> WorkflowService_LintWorkflowAsync(string @namespace, WorkflowLintRequest body)
        {
            return WorkflowService_LintWorkflowAsync(@namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Workflow> WorkflowService_LintWorkflowAsync(string @namespace, WorkflowLintRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/workflows/{namespace}/lint");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Workflow>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Workflow> WorkflowService_SubmitWorkflowAsync(string @namespace, WorkflowSubmitRequest body)
        {
            return WorkflowService_SubmitWorkflowAsync(@namespace, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Workflow> WorkflowService_SubmitWorkflowAsync(string @namespace, WorkflowSubmitRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/workflows/{namespace}/submit");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Workflow>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="getOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="fields">Fields to be included or excluded in the response. e.g. "spec,status.phase", "-status.nodes".</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Workflow> WorkflowService_GetWorkflowAsync(string @namespace, string name, string getOptions_resourceVersion, string fields)
        {
            return WorkflowService_GetWorkflowAsync(@namespace, name, getOptions_resourceVersion, fields, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="getOptions_resourceVersion">resourceVersion sets a constraint on what resource versions a request may be served from.
        /// <br/>See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for
        /// <br/>details.
        /// <br/>
        /// <br/>Defaults to unset
        /// <br/>+optional</param>
        /// <param name="fields">Fields to be included or excluded in the response. e.g. "spec,status.phase", "-status.nodes".</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Workflow> WorkflowService_GetWorkflowAsync(string @namespace, string name, string getOptions_resourceVersion, string fields, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/workflows/{namespace}/{name}?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
            if (getOptions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("getOptions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(getOptions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (fields != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("fields") + "=").Append(System.Uri.EscapeDataString(ConvertToString(fields, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Workflow>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<WorkflowDeleteResponse> WorkflowService_DeleteWorkflowAsync(string @namespace, string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun)
        {
            return WorkflowService_DeleteWorkflowAsync(@namespace, name, deleteOptions_gracePeriodSeconds, deleteOptions_preconditions_uid, deleteOptions_preconditions_resourceVersion, deleteOptions_orphanDependents, deleteOptions_propagationPolicy, deleteOptions_dryRun, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="deleteOptions_gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer.
        /// <br/>The value zero indicates delete immediately. If this value is nil, the default grace period for the
        /// <br/>specified type will be used.
        /// <br/>Defaults to a per object value if not specified. zero means delete immediately.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_uid">Specifies the target UID.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_preconditions_resourceVersion">Specifies the target ResourceVersion
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
        /// <br/>Should the dependent objects be orphaned. If true/false, the "orphan"
        /// <br/>finalizer will be added to/removed from the object's finalizers list.
        /// <br/>Either this field or PropagationPolicy may be set, but not both.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_propagationPolicy">Whether and how garbage collection will be performed.
        /// <br/>Either this field or OrphanDependents may be set, but not both.
        /// <br/>The default policy is decided by the existing finalizer set in the
        /// <br/>metadata.finalizers and the resource-specific default policy.
        /// <br/>Acceptable values are: 'Orphan' - orphan the dependents; 'Background' -
        /// <br/>allow the garbage collector to delete the dependents in the background;
        /// <br/>'Foreground' - a cascading policy that deletes all dependents in the
        /// <br/>foreground.
        /// <br/>+optional.</param>
        /// <param name="deleteOptions_dryRun">When present, indicates that modifications should not be
        /// <br/>persisted. An invalid or unrecognized dryRun directive will
        /// <br/>result in an error response and no further processing of the
        /// <br/>request. Valid values are:
        /// <br/>- All: all dry run stages will be processed
        /// <br/>+optional.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<WorkflowDeleteResponse> WorkflowService_DeleteWorkflowAsync(string @namespace, string name, string deleteOptions_gracePeriodSeconds, string deleteOptions_preconditions_uid, string deleteOptions_preconditions_resourceVersion, bool? deleteOptions_orphanDependents, string deleteOptions_propagationPolicy, System.Collections.Generic.IEnumerable<string> deleteOptions_dryRun, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/workflows/{namespace}/{name}?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
            if (deleteOptions_gracePeriodSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.gracePeriodSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_gracePeriodSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_preconditions_uid != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.preconditions.uid") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_preconditions_uid, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_preconditions_resourceVersion != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.preconditions.resourceVersion") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_preconditions_resourceVersion, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_orphanDependents != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.orphanDependents") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_orphanDependents, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_propagationPolicy != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.propagationPolicy") + "=").Append(System.Uri.EscapeDataString(ConvertToString(deleteOptions_propagationPolicy, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (deleteOptions_dryRun != null)
            {
                foreach (var item_ in deleteOptions_dryRun) { urlBuilder_.Append(System.Uri.EscapeDataString("deleteOptions.dryRun") + "=").Append(System.Uri.EscapeDataString(ConvertToString(item_, System.Globalization.CultureInfo.InvariantCulture))).Append("&"); }
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<WorkflowDeleteResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="logOptions_container">The container for which to stream logs. Defaults to only container if there is one container in the pod.
        /// <br/>+optional.</param>
        /// <param name="logOptions_follow">Follow the log stream of the pod. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="logOptions_previous">Return previous terminated container logs. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="logOptions_sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value
        /// <br/>precedes the time a pod was started, only logs since the pod start will be returned.
        /// <br/>If this value is in the future, no logs will be returned.
        /// <br/>Only one of sinceSeconds or sinceTime may be specified.
        /// <br/>+optional.</param>
        /// <param name="logOptions_sinceTime_seconds">Represents seconds of UTC time since Unix epoch
        /// <br/>1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
        /// <br/>9999-12-31T23:59:59Z inclusive.</param>
        /// <param name="logOptions_sinceTime_nanos">Non-negative fractions of a second at nanosecond resolution. Negative
        /// <br/>second values with fractions must still have non-negative nanos values
        /// <br/>that count forward in time. Must be from 0 to 999,999,999
        /// <br/>inclusive. This field may be limited in precision depending on context.</param>
        /// <param name="logOptions_timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
        /// <br/>of log output. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="logOptions_tailLines">If set, the number of lines from the end of the logs to show. If not specified,
        /// <br/>logs are shown from the creation of the container or sinceSeconds or sinceTime
        /// <br/>+optional.</param>
        /// <param name="logOptions_limitBytes">If set, the number of bytes to read from the server before terminating the
        /// <br/>log output. This may not display a complete final line of logging, and may return
        /// <br/>slightly more or slightly less than the specified limit.
        /// <br/>+optional.</param>
        /// <param name="logOptions_insecureSkipTLSVerifyBackend">insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
        /// <br/>serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
        /// <br/>and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
        /// <br/>kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
        /// <br/>connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
        /// <br/>the actual log data coming from the real kubelet).
        /// <br/>+optional.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<string> WorkflowService_WorkflowLogsAsync(string @namespace, string name, string podName, string logOptions_container, bool? logOptions_follow, bool? logOptions_previous, string logOptions_sinceSeconds, string logOptions_sinceTime_seconds, int? logOptions_sinceTime_nanos, bool? logOptions_timestamps, string logOptions_tailLines, string logOptions_limitBytes, bool? logOptions_insecureSkipTLSVerifyBackend, string grep, string selector)
        {
            return WorkflowService_WorkflowLogsAsync(@namespace, name, podName, logOptions_container, logOptions_follow, logOptions_previous, logOptions_sinceSeconds, logOptions_sinceTime_seconds, logOptions_sinceTime_nanos, logOptions_timestamps, logOptions_tailLines, logOptions_limitBytes, logOptions_insecureSkipTLSVerifyBackend, grep, selector, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <param name="logOptions_container">The container for which to stream logs. Defaults to only container if there is one container in the pod.
        /// <br/>+optional.</param>
        /// <param name="logOptions_follow">Follow the log stream of the pod. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="logOptions_previous">Return previous terminated container logs. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="logOptions_sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value
        /// <br/>precedes the time a pod was started, only logs since the pod start will be returned.
        /// <br/>If this value is in the future, no logs will be returned.
        /// <br/>Only one of sinceSeconds or sinceTime may be specified.
        /// <br/>+optional.</param>
        /// <param name="logOptions_sinceTime_seconds">Represents seconds of UTC time since Unix epoch
        /// <br/>1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
        /// <br/>9999-12-31T23:59:59Z inclusive.</param>
        /// <param name="logOptions_sinceTime_nanos">Non-negative fractions of a second at nanosecond resolution. Negative
        /// <br/>second values with fractions must still have non-negative nanos values
        /// <br/>that count forward in time. Must be from 0 to 999,999,999
        /// <br/>inclusive. This field may be limited in precision depending on context.</param>
        /// <param name="logOptions_timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
        /// <br/>of log output. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="logOptions_tailLines">If set, the number of lines from the end of the logs to show. If not specified,
        /// <br/>logs are shown from the creation of the container or sinceSeconds or sinceTime
        /// <br/>+optional.</param>
        /// <param name="logOptions_limitBytes">If set, the number of bytes to read from the server before terminating the
        /// <br/>log output. This may not display a complete final line of logging, and may return
        /// <br/>slightly more or slightly less than the specified limit.
        /// <br/>+optional.</param>
        /// <param name="logOptions_insecureSkipTLSVerifyBackend">insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
        /// <br/>serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
        /// <br/>and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
        /// <br/>kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
        /// <br/>connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
        /// <br/>the actual log data coming from the real kubelet).
        /// <br/>+optional.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<string> WorkflowService_WorkflowLogsAsync(string @namespace, string name, string podName, string logOptions_container, bool? logOptions_follow, bool? logOptions_previous, string logOptions_sinceSeconds, string logOptions_sinceTime_seconds, int? logOptions_sinceTime_nanos, bool? logOptions_timestamps, string logOptions_tailLines, string logOptions_limitBytes, bool? logOptions_insecureSkipTLSVerifyBackend, string grep, string selector, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/workflows/{namespace}/{name}/log?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
            if (podName != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("podName") + "=").Append(System.Uri.EscapeDataString(ConvertToString(podName, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (logOptions_container != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("logOptions.container") + "=").Append(System.Uri.EscapeDataString(ConvertToString(logOptions_container, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (logOptions_follow != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("logOptions.follow") + "=").Append(System.Uri.EscapeDataString(ConvertToString(logOptions_follow, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (logOptions_previous != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("logOptions.previous") + "=").Append(System.Uri.EscapeDataString(ConvertToString(logOptions_previous, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (logOptions_sinceSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("logOptions.sinceSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(logOptions_sinceSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (logOptions_sinceTime_seconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("logOptions.sinceTime.seconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(logOptions_sinceTime_seconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (logOptions_sinceTime_nanos != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("logOptions.sinceTime.nanos") + "=").Append(System.Uri.EscapeDataString(ConvertToString(logOptions_sinceTime_nanos, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (logOptions_timestamps != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("logOptions.timestamps") + "=").Append(System.Uri.EscapeDataString(ConvertToString(logOptions_timestamps, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (logOptions_tailLines != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("logOptions.tailLines") + "=").Append(System.Uri.EscapeDataString(ConvertToString(logOptions_tailLines, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (logOptions_limitBytes != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("logOptions.limitBytes") + "=").Append(System.Uri.EscapeDataString(ConvertToString(logOptions_limitBytes, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (logOptions_insecureSkipTLSVerifyBackend != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("logOptions.insecureSkipTLSVerifyBackend") + "=").Append(System.Uri.EscapeDataString(ConvertToString(logOptions_insecureSkipTLSVerifyBackend, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (grep != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("grep") + "=").Append(System.Uri.EscapeDataString(ConvertToString(grep, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (selector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("selector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(selector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var responseText = await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            return responseText;

                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Workflow> WorkflowService_ResubmitWorkflowAsync(string @namespace, string name, WorkflowResubmitRequest body)
        {
            return WorkflowService_ResubmitWorkflowAsync(@namespace, name, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Workflow> WorkflowService_ResubmitWorkflowAsync(string @namespace, string name, WorkflowResubmitRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/workflows/{namespace}/{name}/resubmit");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Workflow>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Workflow> WorkflowService_ResumeWorkflowAsync(string @namespace, string name, WorkflowResumeRequest body)
        {
            return WorkflowService_ResumeWorkflowAsync(@namespace, name, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Workflow> WorkflowService_ResumeWorkflowAsync(string @namespace, string name, WorkflowResumeRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/workflows/{namespace}/{name}/resume");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Workflow>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Workflow> WorkflowService_RetryWorkflowAsync(string @namespace, string name, WorkflowRetryRequest body)
        {
            return WorkflowService_RetryWorkflowAsync(@namespace, name, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Workflow> WorkflowService_RetryWorkflowAsync(string @namespace, string name, WorkflowRetryRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/workflows/{namespace}/{name}/retry");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Workflow>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Workflow> WorkflowService_SetWorkflowAsync(string @namespace, string name, WorkflowSetRequest body)
        {
            return WorkflowService_SetWorkflowAsync(@namespace, name, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Workflow> WorkflowService_SetWorkflowAsync(string @namespace, string name, WorkflowSetRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/workflows/{namespace}/{name}/set");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Workflow>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Workflow> WorkflowService_StopWorkflowAsync(string @namespace, string name, WorkflowStopRequest body)
        {
            return WorkflowService_StopWorkflowAsync(@namespace, name, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Workflow> WorkflowService_StopWorkflowAsync(string @namespace, string name, WorkflowStopRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/workflows/{namespace}/{name}/stop");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Workflow>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Workflow> WorkflowService_SuspendWorkflowAsync(string @namespace, string name, WorkflowSuspendRequest body)
        {
            return WorkflowService_SuspendWorkflowAsync(@namespace, name, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Workflow> WorkflowService_SuspendWorkflowAsync(string @namespace, string name, WorkflowSuspendRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/workflows/{namespace}/{name}/suspend");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Workflow>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Workflow> WorkflowService_TerminateWorkflowAsync(string @namespace, string name, WorkflowTerminateRequest body)
        {
            return WorkflowService_TerminateWorkflowAsync(@namespace, name, body, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <returns>A successful response.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Workflow> WorkflowService_TerminateWorkflowAsync(string @namespace, string name, WorkflowTerminateRequest body, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/workflows/{namespace}/{name}/terminate");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("PUT");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Workflow>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// DEPRECATED: Cannot work via HTTP if podName is an empty string. Use WorkflowLogs.
        /// </summary>
        /// <param name="logOptions_container">The container for which to stream logs. Defaults to only container if there is one container in the pod.
        /// <br/>+optional.</param>
        /// <param name="logOptions_follow">Follow the log stream of the pod. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="logOptions_previous">Return previous terminated container logs. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="logOptions_sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value
        /// <br/>precedes the time a pod was started, only logs since the pod start will be returned.
        /// <br/>If this value is in the future, no logs will be returned.
        /// <br/>Only one of sinceSeconds or sinceTime may be specified.
        /// <br/>+optional.</param>
        /// <param name="logOptions_sinceTime_seconds">Represents seconds of UTC time since Unix epoch
        /// <br/>1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
        /// <br/>9999-12-31T23:59:59Z inclusive.</param>
        /// <param name="logOptions_sinceTime_nanos">Non-negative fractions of a second at nanosecond resolution. Negative
        /// <br/>second values with fractions must still have non-negative nanos values
        /// <br/>that count forward in time. Must be from 0 to 999,999,999
        /// <br/>inclusive. This field may be limited in precision depending on context.</param>
        /// <param name="logOptions_timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
        /// <br/>of log output. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="logOptions_tailLines">If set, the number of lines from the end of the logs to show. If not specified,
        /// <br/>logs are shown from the creation of the container or sinceSeconds or sinceTime
        /// <br/>+optional.</param>
        /// <param name="logOptions_limitBytes">If set, the number of bytes to read from the server before terminating the
        /// <br/>log output. This may not display a complete final line of logging, and may return
        /// <br/>slightly more or slightly less than the specified limit.
        /// <br/>+optional.</param>
        /// <param name="logOptions_insecureSkipTLSVerifyBackend">insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
        /// <br/>serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
        /// <br/>and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
        /// <br/>kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
        /// <br/>connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
        /// <br/>the actual log data coming from the real kubelet).
        /// <br/>+optional.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response11> WorkflowService_PodLogsAsync(string @namespace, string name, string podName, string logOptions_container, bool? logOptions_follow, bool? logOptions_previous, string logOptions_sinceSeconds, string logOptions_sinceTime_seconds, int? logOptions_sinceTime_nanos, bool? logOptions_timestamps, string logOptions_tailLines, string logOptions_limitBytes, bool? logOptions_insecureSkipTLSVerifyBackend, string grep, string selector)
        {
            return WorkflowService_PodLogsAsync(@namespace, name, podName, logOptions_container, logOptions_follow, logOptions_previous, logOptions_sinceSeconds, logOptions_sinceTime_seconds, logOptions_sinceTime_nanos, logOptions_timestamps, logOptions_tailLines, logOptions_limitBytes, logOptions_insecureSkipTLSVerifyBackend, grep, selector, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// DEPRECATED: Cannot work via HTTP if podName is an empty string. Use WorkflowLogs.
        /// </summary>
        /// <param name="logOptions_container">The container for which to stream logs. Defaults to only container if there is one container in the pod.
        /// <br/>+optional.</param>
        /// <param name="logOptions_follow">Follow the log stream of the pod. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="logOptions_previous">Return previous terminated container logs. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="logOptions_sinceSeconds">A relative time in seconds before the current time from which to show logs. If this value
        /// <br/>precedes the time a pod was started, only logs since the pod start will be returned.
        /// <br/>If this value is in the future, no logs will be returned.
        /// <br/>Only one of sinceSeconds or sinceTime may be specified.
        /// <br/>+optional.</param>
        /// <param name="logOptions_sinceTime_seconds">Represents seconds of UTC time since Unix epoch
        /// <br/>1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
        /// <br/>9999-12-31T23:59:59Z inclusive.</param>
        /// <param name="logOptions_sinceTime_nanos">Non-negative fractions of a second at nanosecond resolution. Negative
        /// <br/>second values with fractions must still have non-negative nanos values
        /// <br/>that count forward in time. Must be from 0 to 999,999,999
        /// <br/>inclusive. This field may be limited in precision depending on context.</param>
        /// <param name="logOptions_timestamps">If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
        /// <br/>of log output. Defaults to false.
        /// <br/>+optional.</param>
        /// <param name="logOptions_tailLines">If set, the number of lines from the end of the logs to show. If not specified,
        /// <br/>logs are shown from the creation of the container or sinceSeconds or sinceTime
        /// <br/>+optional.</param>
        /// <param name="logOptions_limitBytes">If set, the number of bytes to read from the server before terminating the
        /// <br/>log output. This may not display a complete final line of logging, and may return
        /// <br/>slightly more or slightly less than the specified limit.
        /// <br/>+optional.</param>
        /// <param name="logOptions_insecureSkipTLSVerifyBackend">insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
        /// <br/>serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
        /// <br/>and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
        /// <br/>kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
        /// <br/>connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
        /// <br/>the actual log data coming from the real kubelet).
        /// <br/>+optional.</param>
        /// <returns>A successful response.(streaming responses)</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response11> WorkflowService_PodLogsAsync(string @namespace, string name, string podName, string logOptions_container, bool? logOptions_follow, bool? logOptions_previous, string logOptions_sinceSeconds, string logOptions_sinceTime_seconds, int? logOptions_sinceTime_nanos, bool? logOptions_timestamps, string logOptions_tailLines, string logOptions_limitBytes, bool? logOptions_insecureSkipTLSVerifyBackend, string grep, string selector, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            if (podName == null)
                throw new System.ArgumentNullException("podName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/api/v1/workflows/{namespace}/{name}/{podName}/log?");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{podName}", System.Uri.EscapeDataString(ConvertToString(podName, System.Globalization.CultureInfo.InvariantCulture)));
            if (logOptions_container != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("logOptions.container") + "=").Append(System.Uri.EscapeDataString(ConvertToString(logOptions_container, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (logOptions_follow != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("logOptions.follow") + "=").Append(System.Uri.EscapeDataString(ConvertToString(logOptions_follow, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (logOptions_previous != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("logOptions.previous") + "=").Append(System.Uri.EscapeDataString(ConvertToString(logOptions_previous, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (logOptions_sinceSeconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("logOptions.sinceSeconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(logOptions_sinceSeconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (logOptions_sinceTime_seconds != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("logOptions.sinceTime.seconds") + "=").Append(System.Uri.EscapeDataString(ConvertToString(logOptions_sinceTime_seconds, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (logOptions_sinceTime_nanos != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("logOptions.sinceTime.nanos") + "=").Append(System.Uri.EscapeDataString(ConvertToString(logOptions_sinceTime_nanos, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (logOptions_timestamps != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("logOptions.timestamps") + "=").Append(System.Uri.EscapeDataString(ConvertToString(logOptions_timestamps, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (logOptions_tailLines != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("logOptions.tailLines") + "=").Append(System.Uri.EscapeDataString(ConvertToString(logOptions_tailLines, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (logOptions_limitBytes != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("logOptions.limitBytes") + "=").Append(System.Uri.EscapeDataString(ConvertToString(logOptions_limitBytes, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (logOptions_insecureSkipTLSVerifyBackend != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("logOptions.insecureSkipTLSVerifyBackend") + "=").Append(System.Uri.EscapeDataString(ConvertToString(logOptions_insecureSkipTLSVerifyBackend, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (grep != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("grep") + "=").Append(System.Uri.EscapeDataString(ConvertToString(grep, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (selector != null)
            {
                urlBuilder_.Append(System.Uri.EscapeDataString("selector") + "=").Append(System.Uri.EscapeDataString(ConvertToString(selector, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response11>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get an output artifact by UID.
        /// </summary>
        /// <returns>An artifact file.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ArtifactService_GetOutputArtifactByUIDAsync(string uid, string podName, string artifactName)
        {
            return ArtifactService_GetOutputArtifactByUIDAsync(uid, podName, artifactName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get an output artifact by UID.
        /// </summary>
        /// <returns>An artifact file.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ArtifactService_GetOutputArtifactByUIDAsync(string uid, string podName, string artifactName, System.Threading.CancellationToken cancellationToken)
        {
            if (uid == null)
                throw new System.ArgumentNullException("uid");

            if (podName == null)
                throw new System.ArgumentNullException("podName");

            if (artifactName == null)
                throw new System.ArgumentNullException("artifactName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/artifacts-by-uid/{uid}/{podName}/{artifactName}");
            urlBuilder_.Replace("{uid}", System.Uri.EscapeDataString(ConvertToString(uid, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{podName}", System.Uri.EscapeDataString(ConvertToString(podName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{artifactName}", System.Uri.EscapeDataString(ConvertToString(artifactName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get an output artifact.
        /// </summary>
        /// <returns>An artifact file.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ArtifactService_GetOutputArtifactAsync(string @namespace, string name, string podName, string artifactName)
        {
            return ArtifactService_GetOutputArtifactAsync(@namespace, name, podName, artifactName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get an output artifact.
        /// </summary>
        /// <returns>An artifact file.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ArtifactService_GetOutputArtifactAsync(string @namespace, string name, string podName, string artifactName, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            if (podName == null)
                throw new System.ArgumentNullException("podName");

            if (artifactName == null)
                throw new System.ArgumentNullException("artifactName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/artifacts/{namespace}/{name}/{podName}/{artifactName}");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{podName}", System.Uri.EscapeDataString(ConvertToString(podName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{artifactName}", System.Uri.EscapeDataString(ConvertToString(artifactName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get an input artifact by UID.
        /// </summary>
        /// <returns>An artifact file.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ArtifactService_GetInputArtifactByUIDAsync(string uid, string podName, string artifactName)
        {
            return ArtifactService_GetInputArtifactByUIDAsync(uid, podName, artifactName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get an input artifact by UID.
        /// </summary>
        /// <returns>An artifact file.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ArtifactService_GetInputArtifactByUIDAsync(string uid, string podName, string artifactName, System.Threading.CancellationToken cancellationToken)
        {
            if (uid == null)
                throw new System.ArgumentNullException("uid");

            if (podName == null)
                throw new System.ArgumentNullException("podName");

            if (artifactName == null)
                throw new System.ArgumentNullException("artifactName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/input-artifacts-by-uid/{uid}/{podName}/{artifactName}");
            urlBuilder_.Replace("{uid}", System.Uri.EscapeDataString(ConvertToString(uid, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{podName}", System.Uri.EscapeDataString(ConvertToString(podName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{artifactName}", System.Uri.EscapeDataString(ConvertToString(artifactName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// Get an input artifact.
        /// </summary>
        /// <returns>An artifact file.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task ArtifactService_GetInputArtifactAsync(string @namespace, string name, string podName, string artifactName)
        {
            return ArtifactService_GetInputArtifactAsync(@namespace, name, podName, artifactName, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Get an input artifact.
        /// </summary>
        /// <returns>An artifact file.</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task ArtifactService_GetInputArtifactAsync(string @namespace, string name, string podName, string artifactName, System.Threading.CancellationToken cancellationToken)
        {
            if (@namespace == null)
                throw new System.ArgumentNullException("@namespace");

            if (name == null)
                throw new System.ArgumentNullException("name");

            if (podName == null)
                throw new System.ArgumentNullException("podName");

            if (artifactName == null)
                throw new System.ArgumentNullException("artifactName");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/input-artifacts/{namespace}/{name}/{podName}/{artifactName}");
            urlBuilder_.Replace("{namespace}", System.Uri.EscapeDataString(ConvertToString(@namespace, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{name}", System.Uri.EscapeDataString(ConvertToString(name, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{podName}", System.Uri.EscapeDataString(ConvertToString(podName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{artifactName}", System.Uri.EscapeDataString(ConvertToString(artifactName, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            return;
                        }
                        else
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Error>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new ApiException<Error>("An unexpected error response.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute))
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool)
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[])value);
            }
            else if (value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array)value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CreateEventSourceRequest
    {
        [Newtonsoft.Json.JsonProperty("eventSource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSource EventSource { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EventSourceDeletedResponse
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EventSourceWatchEvent
    {
        [Newtonsoft.Json.JsonProperty("object", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSource Object { get; set; }

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LogEntry
    {
        [Newtonsoft.Json.JsonProperty("eventName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EventName { get; set; }

        [Newtonsoft.Json.JsonProperty("eventSourceName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EventSourceName { get; set; }

        [Newtonsoft.Json.JsonProperty("eventSourceType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EventSourceType { get; set; }

        [Newtonsoft.Json.JsonProperty("level", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Level { get; set; }

        [Newtonsoft.Json.JsonProperty("msg", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Msg { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Time { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UpdateEventSourceRequest
    {
        [Newtonsoft.Json.JsonProperty("eventSource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSource EventSource { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AWSCredentials
    {
        [Newtonsoft.Json.JsonProperty("accessKeyId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector AccessKeyId { get; set; }

        [Newtonsoft.Json.JsonProperty("secretAccessKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector SecretAccessKey { get; set; }

        [Newtonsoft.Json.JsonProperty("sessionToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector SessionToken { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AWSEndpoint
    {
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AbstractStep
    {
        [Newtonsoft.Json.JsonProperty("resources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceRequirements Resources { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AbstractVolumeSource
    {
        [Newtonsoft.Json.JsonProperty("awsElasticBlockStore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AWSElasticBlockStoreVolumeSource AwsElasticBlockStore { get; set; }

        [Newtonsoft.Json.JsonProperty("azureDisk", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AzureDiskVolumeSource AzureDisk { get; set; }

        [Newtonsoft.Json.JsonProperty("azureFile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AzureFileVolumeSource AzureFile { get; set; }

        [Newtonsoft.Json.JsonProperty("cephfs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CephFSVolumeSource Cephfs { get; set; }

        [Newtonsoft.Json.JsonProperty("cinder", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CinderVolumeSource Cinder { get; set; }

        [Newtonsoft.Json.JsonProperty("configMap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConfigMapVolumeSource ConfigMap { get; set; }

        [Newtonsoft.Json.JsonProperty("csi", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CSIVolumeSource Csi { get; set; }

        [Newtonsoft.Json.JsonProperty("downwardAPI", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DownwardAPIVolumeSource DownwardAPI { get; set; }

        [Newtonsoft.Json.JsonProperty("emptyDir", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EmptyDirVolumeSource EmptyDir { get; set; }

        /// <summary>
        /// Ephemeral represents a volume that is handled by a cluster storage driver.
        /// <br/>The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
        /// <br/>and deleted when the pod is removed.
        /// <br/>
        /// <br/>Use this if:
        /// <br/>a) the volume is only needed while the pod runs,
        /// <br/>b) features of normal volumes like restoring from snapshot or capacity
        /// <br/>   tracking are needed,
        /// <br/>c) the storage driver is specified through a storage class, and
        /// <br/>d) the storage driver supports dynamic volume provisioning through
        /// <br/>   a PersistentVolumeClaim (see EphemeralVolumeSource for more
        /// <br/>   information on the connection between this volume type
        /// <br/>   and PersistentVolumeClaim).
        /// <br/>
        /// <br/>Use PersistentVolumeClaim or one of the vendor-specific
        /// <br/>APIs for volumes that persist for longer than the lifecycle
        /// <br/>of an individual pod.
        /// <br/>
        /// <br/>Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
        /// <br/>be used that way - see the documentation of the driver for
        /// <br/>more information.
        /// <br/>
        /// <br/>A pod can use both types of ephemeral volumes and
        /// <br/>persistent volumes at the same time.
        /// <br/>
        /// <br/>+optional
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ephemeral", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EphemeralVolumeSource Ephemeral { get; set; }

        [Newtonsoft.Json.JsonProperty("fc", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FCVolumeSource Fc { get; set; }

        [Newtonsoft.Json.JsonProperty("flexVolume", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FlexVolumeSource FlexVolume { get; set; }

        [Newtonsoft.Json.JsonProperty("flocker", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FlockerVolumeSource Flocker { get; set; }

        [Newtonsoft.Json.JsonProperty("gcePersistentDisk", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GCEPersistentDiskVolumeSource GcePersistentDisk { get; set; }

        [Newtonsoft.Json.JsonProperty("gitRepo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GitRepoVolumeSource GitRepo { get; set; }

        [Newtonsoft.Json.JsonProperty("glusterfs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GlusterfsVolumeSource Glusterfs { get; set; }

        [Newtonsoft.Json.JsonProperty("hostPath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HostPathVolumeSource HostPath { get; set; }

        [Newtonsoft.Json.JsonProperty("iscsi", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ISCSIVolumeSource Iscsi { get; set; }

        [Newtonsoft.Json.JsonProperty("nfs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public NFSVolumeSource Nfs { get; set; }

        [Newtonsoft.Json.JsonProperty("persistentVolumeClaim", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PersistentVolumeClaimVolumeSource PersistentVolumeClaim { get; set; }

        [Newtonsoft.Json.JsonProperty("photonPersistentDisk", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PhotonPersistentDiskVolumeSource PhotonPersistentDisk { get; set; }

        [Newtonsoft.Json.JsonProperty("portworxVolume", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PortworxVolumeSource PortworxVolume { get; set; }

        [Newtonsoft.Json.JsonProperty("projected", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProjectedVolumeSource Projected { get; set; }

        [Newtonsoft.Json.JsonProperty("quobyte", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public QuobyteVolumeSource Quobyte { get; set; }

        [Newtonsoft.Json.JsonProperty("rbd", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RBDVolumeSource Rbd { get; set; }

        [Newtonsoft.Json.JsonProperty("scaleIO", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ScaleIOVolumeSource ScaleIO { get; set; }

        [Newtonsoft.Json.JsonProperty("secret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretVolumeSource Secret { get; set; }

        [Newtonsoft.Json.JsonProperty("storageos", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StorageOSVolumeSource Storageos { get; set; }

        [Newtonsoft.Json.JsonProperty("vsphereVolume", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public VsphereVirtualDiskVolumeSource VsphereVolume { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Backoff
    {
        [Newtonsoft.Json.JsonProperty("FactorPercentage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? FactorPercentage { get; set; }

        [Newtonsoft.Json.JsonProperty("cap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Duration Cap { get; set; }

        [Newtonsoft.Json.JsonProperty("duration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Duration Duration { get; set; }

        [Newtonsoft.Json.JsonProperty("jitterPercentage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? JitterPercentage { get; set; }

        [Newtonsoft.Json.JsonProperty("steps", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Steps { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Cat
    {
        [Newtonsoft.Json.JsonProperty("abstractStep", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AbstractStep AbstractStep { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Code
    {
        /// <summary>
        /// Image is used in preference to Runtime.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("image", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Image { get; set; }

        [Newtonsoft.Json.JsonProperty("runtime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Runtime { get; set; }

        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Source { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Container
    {
        [Newtonsoft.Json.JsonProperty("args", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Args { get; set; }

        [Newtonsoft.Json.JsonProperty("command", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Command { get; set; }

        [Newtonsoft.Json.JsonProperty("env", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<EnvVar> Env { get; set; }

        [Newtonsoft.Json.JsonProperty("image", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Image { get; set; }

        [Newtonsoft.Json.JsonProperty("in", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Interface In { get; set; }

        [Newtonsoft.Json.JsonProperty("resources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceRequirements Resources { get; set; }

        [Newtonsoft.Json.JsonProperty("volumeMounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<VolumeMount> VolumeMounts { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Cron
    {
        [Newtonsoft.Json.JsonProperty("layout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Layout { get; set; }

        [Newtonsoft.Json.JsonProperty("schedule", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Schedule { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DBDataSource
    {
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

        [Newtonsoft.Json.JsonProperty("valueFrom", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DBDataSourceFrom ValueFrom { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DBDataSourceFrom
    {
        [Newtonsoft.Json.JsonProperty("secretKeyRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector SecretKeyRef { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DBSink
    {
        [Newtonsoft.Json.JsonProperty("actions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SQLAction> Actions { get; set; }

        [Newtonsoft.Json.JsonProperty("database", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Database Database { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DBSource
    {
        [Newtonsoft.Json.JsonProperty("commitInterval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Duration CommitInterval { get; set; }

        [Newtonsoft.Json.JsonProperty("database", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Database Database { get; set; }

        [Newtonsoft.Json.JsonProperty("initSchema", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? InitSchema { get; set; }

        [Newtonsoft.Json.JsonProperty("offsetColumn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OffsetColumn { get; set; }

        [Newtonsoft.Json.JsonProperty("pollInterval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Duration PollInterval { get; set; }

        [Newtonsoft.Json.JsonProperty("query", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Query { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Database
    {
        [Newtonsoft.Json.JsonProperty("dataSource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DBDataSource DataSource { get; set; }

        [Newtonsoft.Json.JsonProperty("driver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Driver { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Dedupe
    {
        [Newtonsoft.Json.JsonProperty("abstractStep", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AbstractStep AbstractStep { get; set; }

        [Newtonsoft.Json.JsonProperty("maxSize", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MaxSize { get; set; }

        [Newtonsoft.Json.JsonProperty("uid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Uid { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Expand
    {
        [Newtonsoft.Json.JsonProperty("abstractStep", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AbstractStep AbstractStep { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Filter
    {
        [Newtonsoft.Json.JsonProperty("abstractStep", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AbstractStep AbstractStep { get; set; }

        [Newtonsoft.Json.JsonProperty("expression", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Expression { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Flatten
    {
        [Newtonsoft.Json.JsonProperty("abstractStep", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AbstractStep AbstractStep { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Git
    {
        [Newtonsoft.Json.JsonProperty("branch", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Branch { get; set; }

        [Newtonsoft.Json.JsonProperty("command", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Command { get; set; }

        [Newtonsoft.Json.JsonProperty("env", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<EnvVar> Env { get; set; }

        [Newtonsoft.Json.JsonProperty("image", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Image { get; set; }

        [Newtonsoft.Json.JsonProperty("insecureIgnoreHostKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? InsecureIgnoreHostKey { get; set; }

        [Newtonsoft.Json.JsonProperty("passwordSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector PasswordSecret { get; set; }

        /// <summary>
        /// +kubebuilder:default=.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }

        [Newtonsoft.Json.JsonProperty("sshPrivateKeySecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector SshPrivateKeySecret { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("usernameSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector UsernameSecret { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Group
    {
        [Newtonsoft.Json.JsonProperty("endOfGroup", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EndOfGroup { get; set; }

        [Newtonsoft.Json.JsonProperty("format", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Format { get; set; }

        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }

        [Newtonsoft.Json.JsonProperty("storage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Storage Storage { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HTTP
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HTTPHeader
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

        [Newtonsoft.Json.JsonProperty("valueFrom", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HTTPHeaderSource ValueFrom { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HTTPHeaderSource
    {
        [Newtonsoft.Json.JsonProperty("secretKeyRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector SecretKeyRef { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HTTPSink
    {
        [Newtonsoft.Json.JsonProperty("headers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<HTTPHeader> Headers { get; set; }

        [Newtonsoft.Json.JsonProperty("insecureSkipVerify", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? InsecureSkipVerify { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HTTPSource
    {
        [Newtonsoft.Json.JsonProperty("serviceName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ServiceName { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Interface
    {
        [Newtonsoft.Json.JsonProperty("fifo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Fifo { get; set; }

        [Newtonsoft.Json.JsonProperty("http", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HTTP Http { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class JetStream
    {
        [Newtonsoft.Json.JsonProperty("auth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public NATSAuth Auth { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("natsUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NatsUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("subject", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Subject { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class JetStreamSink
    {
        [Newtonsoft.Json.JsonProperty("jetstream", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JetStream Jetstream { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class JetStreamSource
    {
        [Newtonsoft.Json.JsonProperty("jetstream", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JetStream Jetstream { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Kafka
    {
        [Newtonsoft.Json.JsonProperty("kafkaConfig", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KafkaConfig KafkaConfig { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("topic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Topic { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KafkaConfig
    {
        [Newtonsoft.Json.JsonProperty("brokers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Brokers { get; set; }

        [Newtonsoft.Json.JsonProperty("maxMessageBytes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxMessageBytes { get; set; }

        [Newtonsoft.Json.JsonProperty("net", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KafkaNET Net { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KafkaNET
    {
        [Newtonsoft.Json.JsonProperty("sasl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SASL Sasl { get; set; }

        [Newtonsoft.Json.JsonProperty("tls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TLS Tls { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KafkaSink
    {
        [Newtonsoft.Json.JsonProperty("acks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Acks { get; set; }

        [Newtonsoft.Json.JsonProperty("async", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Async { get; set; }

        [Newtonsoft.Json.JsonProperty("batchSize", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BatchSize { get; set; }

        [Newtonsoft.Json.JsonProperty("compressionType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CompressionType { get; set; }

        [Newtonsoft.Json.JsonProperty("enableIdempotence", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? EnableIdempotence { get; set; }

        [Newtonsoft.Json.JsonProperty("kafka", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Kafka Kafka { get; set; }

        [Newtonsoft.Json.JsonProperty("linger", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Duration Linger { get; set; }

        [Newtonsoft.Json.JsonProperty("maxInflight", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxInflight { get; set; }

        [Newtonsoft.Json.JsonProperty("messageTimeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Duration MessageTimeout { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KafkaSource
    {
        [Newtonsoft.Json.JsonProperty("fetchMin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FetchMin { get; set; }

        [Newtonsoft.Json.JsonProperty("fetchWaitMax", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Duration FetchWaitMax { get; set; }

        /// <summary>
        /// GroupID is the consumer group ID. If not specified, a unique deterministic group ID is generated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("groupId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GroupId { get; set; }

        [Newtonsoft.Json.JsonProperty("kafka", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Kafka Kafka { get; set; }

        [Newtonsoft.Json.JsonProperty("startOffset", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StartOffset { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Log
    {
        [Newtonsoft.Json.JsonProperty("truncate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Truncate { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Map
    {
        [Newtonsoft.Json.JsonProperty("abstractStep", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AbstractStep AbstractStep { get; set; }

        [Newtonsoft.Json.JsonProperty("expression", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Expression { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Metadata
    {
        [Newtonsoft.Json.JsonProperty("annotations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Annotations { get; set; }

        [Newtonsoft.Json.JsonProperty("labels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NATSAuth
    {
        [Newtonsoft.Json.JsonProperty("token", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector Token { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Pipeline
    {
        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ObjectMeta Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("spec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PipelineSpec Spec { get; set; }

        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PipelineStatus Status { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PipelineList
    {
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Pipeline> Items { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ListMeta Metadata { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PipelineSpec
    {
        [Newtonsoft.Json.JsonProperty("deletionDelay", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Duration DeletionDelay { get; set; }

        [Newtonsoft.Json.JsonProperty("steps", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<StepSpec> Steps { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PipelineStatus
    {
        [Newtonsoft.Json.JsonProperty("conditions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Condition3> Conditions { get; set; }

        [Newtonsoft.Json.JsonProperty("lastUpdated", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? LastUpdated { get; set; }

        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        [Newtonsoft.Json.JsonProperty("phase", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Phase { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class S3
    {
        [Newtonsoft.Json.JsonProperty("bucket", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Bucket { get; set; }

        [Newtonsoft.Json.JsonProperty("credentials", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AWSCredentials Credentials { get; set; }

        [Newtonsoft.Json.JsonProperty("endpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AWSEndpoint Endpoint { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("region", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Region { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class S3Sink
    {
        [Newtonsoft.Json.JsonProperty("s3", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public S3 S3 { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class S3Source
    {
        [Newtonsoft.Json.JsonProperty("concurrency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Concurrency { get; set; }

        [Newtonsoft.Json.JsonProperty("pollPeriod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Duration PollPeriod { get; set; }

        [Newtonsoft.Json.JsonProperty("s3", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public S3 S3 { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SASL
    {
        [Newtonsoft.Json.JsonProperty("mechanism", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Mechanism { get; set; }

        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector Password { get; set; }

        [Newtonsoft.Json.JsonProperty("user", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector User { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SQLAction
    {
        [Newtonsoft.Json.JsonProperty("onError", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SQLStatement OnError { get; set; }

        [Newtonsoft.Json.JsonProperty("onRecordNotFound", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SQLStatement OnRecordNotFound { get; set; }

        [Newtonsoft.Json.JsonProperty("statement", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SQLStatement Statement { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SQLStatement
    {
        [Newtonsoft.Json.JsonProperty("args", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Args { get; set; }

        [Newtonsoft.Json.JsonProperty("sql", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Sql { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class STAN
    {
        [Newtonsoft.Json.JsonProperty("auth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public NATSAuth Auth { get; set; }

        [Newtonsoft.Json.JsonProperty("clusterId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClusterId { get; set; }

        [Newtonsoft.Json.JsonProperty("maxInflight", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MaxInflight { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("natsMonitoringUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NatsMonitoringUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("natsUrl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NatsUrl { get; set; }

        [Newtonsoft.Json.JsonProperty("subject", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Subject { get; set; }

        [Newtonsoft.Json.JsonProperty("subjectPrefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SubjectPrefix { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Scale
    {
        /// <summary>
        /// An expression to determine the number of replicas. Must evaluation to an `int`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("desiredReplicas", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DesiredReplicas { get; set; }

        [Newtonsoft.Json.JsonProperty("peekDelay", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PeekDelay { get; set; }

        [Newtonsoft.Json.JsonProperty("scalingDelay", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ScalingDelay { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Sidecar
    {
        [Newtonsoft.Json.JsonProperty("resources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceRequirements Resources { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Sink
    {
        [Newtonsoft.Json.JsonProperty("db", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DBSink Db { get; set; }

        [Newtonsoft.Json.JsonProperty("deadLetterQueue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DeadLetterQueue { get; set; }

        [Newtonsoft.Json.JsonProperty("http", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HTTPSink Http { get; set; }

        [Newtonsoft.Json.JsonProperty("jetstream", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JetStreamSink Jetstream { get; set; }

        [Newtonsoft.Json.JsonProperty("kafka", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KafkaSink Kafka { get; set; }

        [Newtonsoft.Json.JsonProperty("log", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Log Log { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("s3", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public S3Sink S3 { get; set; }

        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public STAN Stan { get; set; }

        [Newtonsoft.Json.JsonProperty("volume", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public VolumeSink Volume { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Source
    {
        [Newtonsoft.Json.JsonProperty("cron", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Cron Cron { get; set; }

        [Newtonsoft.Json.JsonProperty("db", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DBSource Db { get; set; }

        [Newtonsoft.Json.JsonProperty("http", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HTTPSource Http { get; set; }

        [Newtonsoft.Json.JsonProperty("jetstream", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public JetStreamSource Jetstream { get; set; }

        [Newtonsoft.Json.JsonProperty("kafka", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KafkaSource Kafka { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("retry", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Backoff Retry { get; set; }

        [Newtonsoft.Json.JsonProperty("s3", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public S3Source S3 { get; set; }

        [Newtonsoft.Json.JsonProperty("stan", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public STAN Stan { get; set; }

        [Newtonsoft.Json.JsonProperty("volume", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public VolumeSource Volume { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Step
    {
        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ObjectMeta Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("spec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StepSpec Spec { get; set; }

        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StepStatus Status { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StepSpec
    {
        [Newtonsoft.Json.JsonProperty("affinity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Affinity Affinity { get; set; }

        [Newtonsoft.Json.JsonProperty("cat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Cat Cat { get; set; }

        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Code Code { get; set; }

        [Newtonsoft.Json.JsonProperty("container", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Container Container { get; set; }

        [Newtonsoft.Json.JsonProperty("dedupe", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Dedupe Dedupe { get; set; }

        [Newtonsoft.Json.JsonProperty("expand", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Expand Expand { get; set; }

        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Filter Filter { get; set; }

        [Newtonsoft.Json.JsonProperty("flatten", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Flatten Flatten { get; set; }

        [Newtonsoft.Json.JsonProperty("git", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Git Git { get; set; }

        [Newtonsoft.Json.JsonProperty("group", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Group Group { get; set; }

        [Newtonsoft.Json.JsonProperty("imagePullSecrets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LocalObjectReference> ImagePullSecrets { get; set; }

        [Newtonsoft.Json.JsonProperty("map", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Map Map { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Metadata Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("nodeSelector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> NodeSelector { get; set; }

        [Newtonsoft.Json.JsonProperty("replicas", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Replicas { get; set; }

        [Newtonsoft.Json.JsonProperty("restartPolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RestartPolicy { get; set; }

        [Newtonsoft.Json.JsonProperty("scale", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Scale Scale { get; set; }

        [Newtonsoft.Json.JsonProperty("serviceAccountName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ServiceAccountName { get; set; }

        [Newtonsoft.Json.JsonProperty("sidecar", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Sidecar Sidecar { get; set; }

        [Newtonsoft.Json.JsonProperty("sinks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Sink> Sinks { get; set; }

        [Newtonsoft.Json.JsonProperty("sources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Source> Sources { get; set; }

        [Newtonsoft.Json.JsonProperty("terminator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Terminator { get; set; }

        [Newtonsoft.Json.JsonProperty("tolerations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Toleration> Tolerations { get; set; }

        [Newtonsoft.Json.JsonProperty("volumes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Volume> Volumes { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StepStatus
    {
        [Newtonsoft.Json.JsonProperty("lastScaledAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? LastScaledAt { get; set; }

        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        [Newtonsoft.Json.JsonProperty("phase", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Phase { get; set; }

        [Newtonsoft.Json.JsonProperty("reason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Reason { get; set; }

        [Newtonsoft.Json.JsonProperty("replicas", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Replicas { get; set; }

        [Newtonsoft.Json.JsonProperty("selector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Selector { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Storage
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("subPath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SubPath { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TLS
    {
        [Newtonsoft.Json.JsonProperty("caCertSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector CaCertSecret { get; set; }

        [Newtonsoft.Json.JsonProperty("certSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector CertSecret { get; set; }

        [Newtonsoft.Json.JsonProperty("keySecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector KeySecret { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class VolumeSink
    {
        [Newtonsoft.Json.JsonProperty("abstractVolumeSource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AbstractVolumeSource AbstractVolumeSource { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class VolumeSource
    {
        [Newtonsoft.Json.JsonProperty("abstractVolumeSource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AbstractVolumeSource AbstractVolumeSource { get; set; }

        [Newtonsoft.Json.JsonProperty("concurrency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Concurrency { get; set; }

        [Newtonsoft.Json.JsonProperty("pollPeriod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Duration PollPeriod { get; set; }

        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Any
    {
        [Newtonsoft.Json.JsonProperty("type_url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type_url { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Error
    {
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Code { get; set; }

        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Any> Details { get; set; }

        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Error1 { get; set; }

        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StreamError
    {
        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Any> Details { get; set; }

        [Newtonsoft.Json.JsonProperty("grpc_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Grpc_code { get; set; }

        [Newtonsoft.Json.JsonProperty("http_code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Http_code { get; set; }

        [Newtonsoft.Json.JsonProperty("http_status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Http_status { get; set; }

        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AMQPConsumeConfig
    {
        [Newtonsoft.Json.JsonProperty("autoAck", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AutoAck { get; set; }

        [Newtonsoft.Json.JsonProperty("consumerTag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConsumerTag { get; set; }

        [Newtonsoft.Json.JsonProperty("exclusive", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Exclusive { get; set; }

        [Newtonsoft.Json.JsonProperty("noLocal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? NoLocal { get; set; }

        [Newtonsoft.Json.JsonProperty("noWait", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? NoWait { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AMQPEventSource
    {
        [Newtonsoft.Json.JsonProperty("auth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public BasicAuth Auth { get; set; }

        [Newtonsoft.Json.JsonProperty("connectionBackoff", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Backoff2 ConnectionBackoff { get; set; }

        [Newtonsoft.Json.JsonProperty("consume", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AMQPConsumeConfig Consume { get; set; }

        [Newtonsoft.Json.JsonProperty("exchangeDeclare", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AMQPExchangeDeclareConfig ExchangeDeclare { get; set; }

        [Newtonsoft.Json.JsonProperty("exchangeName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExchangeName { get; set; }

        [Newtonsoft.Json.JsonProperty("exchangeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExchangeType { get; set; }

        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSourceFilter Filter { get; set; }

        [Newtonsoft.Json.JsonProperty("jsonBody", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? JsonBody { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("queueBind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AMQPQueueBindConfig QueueBind { get; set; }

        [Newtonsoft.Json.JsonProperty("queueDeclare", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AMQPQueueDeclareConfig QueueDeclare { get; set; }

        [Newtonsoft.Json.JsonProperty("routingKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RoutingKey { get; set; }

        [Newtonsoft.Json.JsonProperty("tls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TLSConfig Tls { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("urlSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector UrlSecret { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AMQPExchangeDeclareConfig
    {
        [Newtonsoft.Json.JsonProperty("autoDelete", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AutoDelete { get; set; }

        [Newtonsoft.Json.JsonProperty("durable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Durable { get; set; }

        [Newtonsoft.Json.JsonProperty("internal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Internal { get; set; }

        [Newtonsoft.Json.JsonProperty("noWait", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? NoWait { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AMQPQueueBindConfig
    {
        [Newtonsoft.Json.JsonProperty("noWait", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? NoWait { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AMQPQueueDeclareConfig
    {
        [Newtonsoft.Json.JsonProperty("arguments", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Arguments { get; set; }

        [Newtonsoft.Json.JsonProperty("autoDelete", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AutoDelete { get; set; }

        [Newtonsoft.Json.JsonProperty("durable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Durable { get; set; }

        [Newtonsoft.Json.JsonProperty("exclusive", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Exclusive { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("noWait", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? NoWait { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AWSLambdaTrigger
    {
        [Newtonsoft.Json.JsonProperty("accessKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector AccessKey { get; set; }

        /// <summary>
        /// FunctionName refers to the name of the function to invoke.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("functionName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FunctionName { get; set; }

        /// <summary>
        /// Choose from the following options.
        /// <br/>
        /// <br/>   * RequestResponse (default) - Invoke the function synchronously. Keep
        /// <br/>   the connection open until the function returns a response or times out.
        /// <br/>   The API response includes the function response and additional data.
        /// <br/>
        /// <br/>   * Event - Invoke the function asynchronously. Send events that fail multiple
        /// <br/>   times to the function's dead-letter queue (if it's configured). The API
        /// <br/>   response only includes a status code.
        /// <br/>
        /// <br/>   * DryRun - Validate parameter values and verify that the user or role
        /// <br/>   has permission to invoke the function.
        /// <br/>+optional
        /// </summary>
        [Newtonsoft.Json.JsonProperty("invocationType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InvocationType { get; set; }

        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TriggerParameter> Parameters { get; set; }

        /// <summary>
        /// Payload is the list of key-value extracted from an event payload to construct the request payload.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TriggerParameter> Payload { get; set; }

        [Newtonsoft.Json.JsonProperty("region", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Region { get; set; }

        [Newtonsoft.Json.JsonProperty("roleARN", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RoleARN { get; set; }

        [Newtonsoft.Json.JsonProperty("secretKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector SecretKey { get; set; }

    }

    /// <summary>
    /// Amount represent a numeric amount.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Amount
    {
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ArgoWorkflowTrigger
    {
        [Newtonsoft.Json.JsonProperty("operation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Operation { get; set; }

        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TriggerParameter> Parameters { get; set; }

        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ArtifactLocation Source { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ArtifactLocation
    {
        [Newtonsoft.Json.JsonProperty("configmap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConfigMapKeySelector Configmap { get; set; }

        [Newtonsoft.Json.JsonProperty("file", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FileArtifact File { get; set; }

        [Newtonsoft.Json.JsonProperty("git", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GitArtifact Git { get; set; }

        [Newtonsoft.Json.JsonProperty("inline", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Inline { get; set; }

        [Newtonsoft.Json.JsonProperty("resource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Resource Resource { get; set; }

        [Newtonsoft.Json.JsonProperty("s3", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public S3Artifact S3 { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public URLArtifact Url { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AzureEventHubsTrigger
    {
        [Newtonsoft.Json.JsonProperty("fqdn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fqdn { get; set; }

        [Newtonsoft.Json.JsonProperty("hubName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HubName { get; set; }

        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TriggerParameter> Parameters { get; set; }

        /// <summary>
        /// Payload is the list of key-value extracted from an event payload to construct the request payload.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TriggerParameter> Payload { get; set; }

        [Newtonsoft.Json.JsonProperty("sharedAccessKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector SharedAccessKey { get; set; }

        [Newtonsoft.Json.JsonProperty("sharedAccessKeyName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector SharedAccessKeyName { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AzureEventsHubEventSource
    {
        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSourceFilter Filter { get; set; }

        [Newtonsoft.Json.JsonProperty("fqdn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Fqdn { get; set; }

        [Newtonsoft.Json.JsonProperty("hubName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HubName { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("sharedAccessKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector SharedAccessKey { get; set; }

        [Newtonsoft.Json.JsonProperty("sharedAccessKeyName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector SharedAccessKeyName { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Backoff2
    {
        [Newtonsoft.Json.JsonProperty("duration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Int64OrString Duration { get; set; }

        [Newtonsoft.Json.JsonProperty("factor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Amount Factor { get; set; }

        [Newtonsoft.Json.JsonProperty("jitter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Amount Jitter { get; set; }

        [Newtonsoft.Json.JsonProperty("steps", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Steps { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BasicAuth
    {
        /// <summary>
        /// Password refers to the Kubernetes secret that holds the password required for basic auth.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector Password { get; set; }

        /// <summary>
        /// Username refers to the Kubernetes secret that holds the username required for basic auth.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector Username { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BitbucketAuth
    {
        [Newtonsoft.Json.JsonProperty("basic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public BitbucketBasicAuth Basic { get; set; }

        [Newtonsoft.Json.JsonProperty("token", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector Token { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BitbucketBasicAuth
    {
        /// <summary>
        /// Password refers to the K8s secret that holds the password.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector Password { get; set; }

        /// <summary>
        /// Username refers to the K8s secret that holds the username.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector Username { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BitbucketEventSource
    {
        /// <summary>
        /// Auth information required to connect to Bitbucket.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("auth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public BitbucketAuth Auth { get; set; }

        [Newtonsoft.Json.JsonProperty("deleteHookOnFinish", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DeleteHookOnFinish { get; set; }

        /// <summary>
        /// Events this webhook is subscribed to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("events", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Events { get; set; }

        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSourceFilter Filter { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        /// <summary>
        /// Owner of the repository.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("owner", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Owner { get; set; }

        [Newtonsoft.Json.JsonProperty("projectKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProjectKey { get; set; }

        /// <summary>
        /// RepositorySlug is a URL-friendly version of a repository name, automatically generated by Bitbucket for use in the URL.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("repositorySlug", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RepositorySlug { get; set; }

        [Newtonsoft.Json.JsonProperty("webhook", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WebhookContext Webhook { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BitbucketServerEventSource
    {
        [Newtonsoft.Json.JsonProperty("accessToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector AccessToken { get; set; }

        [Newtonsoft.Json.JsonProperty("bitbucketserverBaseURL", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BitbucketserverBaseURL { get; set; }

        [Newtonsoft.Json.JsonProperty("deleteHookOnFinish", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DeleteHookOnFinish { get; set; }

        [Newtonsoft.Json.JsonProperty("events", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Events { get; set; }

        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSourceFilter Filter { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("projectKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProjectKey { get; set; }

        [Newtonsoft.Json.JsonProperty("repositories", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<BitbucketServerRepository> Repositories { get; set; }

        [Newtonsoft.Json.JsonProperty("repositorySlug", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RepositorySlug { get; set; }

        [Newtonsoft.Json.JsonProperty("webhook", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WebhookContext Webhook { get; set; }

        [Newtonsoft.Json.JsonProperty("webhookSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector WebhookSecret { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BitbucketServerRepository
    {
        [Newtonsoft.Json.JsonProperty("projectKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProjectKey { get; set; }

        [Newtonsoft.Json.JsonProperty("repositorySlug", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RepositorySlug { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CalendarEventSource
    {
        /// <summary>
        /// ExclusionDates defines the list of DATE-TIME exceptions for recurring events.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exclusionDates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> ExclusionDates { get; set; }

        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSourceFilter Filter { get; set; }

        [Newtonsoft.Json.JsonProperty("interval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Interval { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("persistence", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventPersistence Persistence { get; set; }

        [Newtonsoft.Json.JsonProperty("schedule", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Schedule { get; set; }

        [Newtonsoft.Json.JsonProperty("timezone", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Timezone { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CatchupConfiguration
    {
        [Newtonsoft.Json.JsonProperty("enabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Enabled { get; set; }

        [Newtonsoft.Json.JsonProperty("maxDuration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MaxDuration { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Condition
    {
        [Newtonsoft.Json.JsonProperty("lastTransitionTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? LastTransitionTime { get; set; }

        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        [Newtonsoft.Json.JsonProperty("reason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Reason { get; set; }

        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Status { get; set; }

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConditionsResetByTime
    {
        [Newtonsoft.Json.JsonProperty("cron", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Cron { get; set; }

        [Newtonsoft.Json.JsonProperty("timezone", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Timezone { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConditionsResetCriteria
    {
        [Newtonsoft.Json.JsonProperty("byTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConditionsResetByTime ByTime { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConfigMapPersistence
    {
        [Newtonsoft.Json.JsonProperty("createIfNotExist", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CreateIfNotExist { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

    }

    /// <summary>
    /// CustomTrigger refers to the specification of the custom trigger.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CustomTrigger
    {
        /// <summary>
        /// CertSecret refers to the secret that contains cert for secure connection between sensor and custom trigger gRPC server.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("certSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector CertSecret { get; set; }

        /// <summary>
        /// Parameters is the list of parameters that is applied to resolved custom trigger trigger object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TriggerParameter> Parameters { get; set; }

        /// <summary>
        /// Payload is the list of key-value extracted from an event payload to construct the request payload.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TriggerParameter> Payload { get; set; }

        [Newtonsoft.Json.JsonProperty("secure", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Secure { get; set; }

        /// <summary>
        /// ServerNameOverride for the secure connection between sensor and custom trigger gRPC server.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("serverNameOverride", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ServerNameOverride { get; set; }

        [Newtonsoft.Json.JsonProperty("serverURL", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ServerURL { get; set; }

        /// <summary>
        /// Spec is the custom trigger resource specification that custom trigger gRPC server knows how to interpret.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("spec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Spec { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DataFilter
    {
        /// <summary>
        /// Comparator compares the event data with a user given value.
        /// <br/>Can be "&gt;=", "&gt;", "=", "!=", "&lt;", or "&lt;=".
        /// <br/>Is optional, and if left blank treated as equality "=".
        /// </summary>
        [Newtonsoft.Json.JsonProperty("comparator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Comparator { get; set; }

        /// <summary>
        /// Path is the JSONPath of the event's (JSON decoded) data key
        /// <br/>Path is a series of keys separated by a dot. A key may contain wildcard characters '*' and '?'.
        /// <br/>To access an array value use the index as the key. The dot and wildcard characters can be escaped with '\\'.
        /// <br/>See https://github.com/tidwall/gjson#path-syntax for more information on how to use this.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }

        [Newtonsoft.Json.JsonProperty("template", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Template { get; set; }

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EmitterEventSource
    {
        /// <summary>
        /// Broker URI to connect to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("broker", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Broker { get; set; }

        [Newtonsoft.Json.JsonProperty("channelKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ChannelKey { get; set; }

        [Newtonsoft.Json.JsonProperty("channelName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ChannelName { get; set; }

        [Newtonsoft.Json.JsonProperty("connectionBackoff", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Backoff2 ConnectionBackoff { get; set; }

        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSourceFilter Filter { get; set; }

        [Newtonsoft.Json.JsonProperty("jsonBody", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? JsonBody { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector Password { get; set; }

        [Newtonsoft.Json.JsonProperty("tls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TLSConfig Tls { get; set; }

        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector Username { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EventContext
    {
        /// <summary>
        /// DataContentType - A MIME (RFC2046) string describing the media type of `data`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("datacontenttype", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Datacontenttype { get; set; }

        /// <summary>
        /// ID of the event; must be non-empty and unique within the scope of the producer.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        /// <summary>
        /// Source - A URI describing the event producer.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Source { get; set; }

        /// <summary>
        /// SpecVersion - The version of the CloudEvents specification used by the io.argoproj.workflow.v1alpha1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("specversion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Specversion { get; set; }

        [Newtonsoft.Json.JsonProperty("subject", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Subject { get; set; }

        /// <summary>
        /// Time - A Timestamp when the event happened.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Time { get; set; }

        /// <summary>
        /// Type - The type of the occurrence which has happened.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EventDependency
    {
        [Newtonsoft.Json.JsonProperty("eventName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EventName { get; set; }

        [Newtonsoft.Json.JsonProperty("eventSourceName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EventSourceName { get; set; }

        [Newtonsoft.Json.JsonProperty("filters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventDependencyFilter Filters { get; set; }

        /// <summary>
        /// FiltersLogicalOperator defines how different filters are evaluated together.
        /// <br/>Available values: and (&amp;&amp;), or (||)
        /// <br/>Is optional and if left blank treated as and (&amp;&amp;).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("filtersLogicalOperator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FiltersLogicalOperator { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("transform", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventDependencyTransformer Transform { get; set; }

    }

    /// <summary>
    /// EventDependencyFilter defines filters and constraints for a io.argoproj.workflow.v1alpha1.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EventDependencyFilter
    {
        [Newtonsoft.Json.JsonProperty("context", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventContext Context { get; set; }

        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<DataFilter> Data { get; set; }

        /// <summary>
        /// DataLogicalOperator defines how multiple Data filters (if defined) are evaluated together.
        /// <br/>Available values: and (&amp;&amp;), or (||)
        /// <br/>Is optional and if left blank treated as and (&amp;&amp;).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dataLogicalOperator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DataLogicalOperator { get; set; }

        /// <summary>
        /// ExprLogicalOperator defines how multiple Exprs filters (if defined) are evaluated together.
        /// <br/>Available values: and (&amp;&amp;), or (||)
        /// <br/>Is optional and if left blank treated as and (&amp;&amp;).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exprLogicalOperator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExprLogicalOperator { get; set; }

        /// <summary>
        /// Exprs contains the list of expressions evaluated against the event payload.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exprs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ExprFilter> Exprs { get; set; }

        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TimeFilter Time { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EventDependencyTransformer
    {
        [Newtonsoft.Json.JsonProperty("jq", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Jq { get; set; }

        [Newtonsoft.Json.JsonProperty("script", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Script { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EventPersistence
    {
        [Newtonsoft.Json.JsonProperty("catchup", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CatchupConfiguration Catchup { get; set; }

        [Newtonsoft.Json.JsonProperty("configMap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConfigMapPersistence ConfigMap { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EventSource
    {
        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ObjectMeta Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("spec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSourceSpec Spec { get; set; }

        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSourceStatus Status { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EventSourceFilter
    {
        [Newtonsoft.Json.JsonProperty("expression", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Expression { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EventSourceList
    {
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<EventSource> Items { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ListMeta Metadata { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EventSourceSpec
    {
        [Newtonsoft.Json.JsonProperty("amqp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, AMQPEventSource> Amqp { get; set; }

        [Newtonsoft.Json.JsonProperty("azureEventsHub", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, AzureEventsHubEventSource> AzureEventsHub { get; set; }

        [Newtonsoft.Json.JsonProperty("bitbucket", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, BitbucketEventSource> Bitbucket { get; set; }

        [Newtonsoft.Json.JsonProperty("bitbucketserver", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, BitbucketServerEventSource> Bitbucketserver { get; set; }

        [Newtonsoft.Json.JsonProperty("calendar", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, CalendarEventSource> Calendar { get; set; }

        [Newtonsoft.Json.JsonProperty("emitter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, EmitterEventSource> Emitter { get; set; }

        [Newtonsoft.Json.JsonProperty("eventBusName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EventBusName { get; set; }

        [Newtonsoft.Json.JsonProperty("file", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, FileEventSource> File { get; set; }

        [Newtonsoft.Json.JsonProperty("generic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, GenericEventSource> Generic { get; set; }

        [Newtonsoft.Json.JsonProperty("github", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, GithubEventSource> Github { get; set; }

        [Newtonsoft.Json.JsonProperty("gitlab", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, GitlabEventSource> Gitlab { get; set; }

        [Newtonsoft.Json.JsonProperty("hdfs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, HDFSEventSource> Hdfs { get; set; }

        [Newtonsoft.Json.JsonProperty("kafka", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, KafkaEventSource> Kafka { get; set; }

        [Newtonsoft.Json.JsonProperty("minio", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, S3Artifact> Minio { get; set; }

        [Newtonsoft.Json.JsonProperty("mqtt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, MQTTEventSource> Mqtt { get; set; }

        [Newtonsoft.Json.JsonProperty("nats", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, NATSEventsSource> Nats { get; set; }

        [Newtonsoft.Json.JsonProperty("nsq", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, NSQEventSource> Nsq { get; set; }

        [Newtonsoft.Json.JsonProperty("pubSub", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, PubSubEventSource> PubSub { get; set; }

        [Newtonsoft.Json.JsonProperty("pulsar", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, PulsarEventSource> Pulsar { get; set; }

        [Newtonsoft.Json.JsonProperty("redis", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, RedisEventSource> Redis { get; set; }

        [Newtonsoft.Json.JsonProperty("replicas", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Replicas { get; set; }

        [Newtonsoft.Json.JsonProperty("resource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, ResourceEventSource> Resource { get; set; }

        [Newtonsoft.Json.JsonProperty("service", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Service Service { get; set; }

        [Newtonsoft.Json.JsonProperty("slack", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, SlackEventSource> Slack { get; set; }

        [Newtonsoft.Json.JsonProperty("sns", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, SNSEventSource> Sns { get; set; }

        [Newtonsoft.Json.JsonProperty("sqs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, SQSEventSource> Sqs { get; set; }

        [Newtonsoft.Json.JsonProperty("storageGrid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, StorageGridEventSource> StorageGrid { get; set; }

        [Newtonsoft.Json.JsonProperty("stripe", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, StripeEventSource> Stripe { get; set; }

        [Newtonsoft.Json.JsonProperty("template", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Template Template { get; set; }

        [Newtonsoft.Json.JsonProperty("webhook", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, WebhookContext> Webhook { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EventSourceStatus
    {
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Status Status { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ExprFilter
    {
        /// <summary>
        /// Expr refers to the expression that determines the outcome of the filter.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("expr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Expr { get; set; }

        /// <summary>
        /// Fields refers to set of keys that refer to the paths within event payload.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PayloadField> Fields { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FileArtifact
    {
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }

    }

    /// <summary>
    /// FileEventSource describes an event-source for file related events.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FileEventSource
    {
        [Newtonsoft.Json.JsonProperty("eventType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EventType { get; set; }

        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSourceFilter Filter { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("polling", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Polling { get; set; }

        [Newtonsoft.Json.JsonProperty("watchPathConfig", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WatchPathConfig WatchPathConfig { get; set; }

    }

    /// <summary>
    /// GenericEventSource refers to a generic event source. It can be used to implement a custom event source.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GenericEventSource
    {
        [Newtonsoft.Json.JsonProperty("authSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector AuthSecret { get; set; }

        [Newtonsoft.Json.JsonProperty("config", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Config { get; set; }

        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSourceFilter Filter { get; set; }

        /// <summary>
        /// Insecure determines the type of connection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("insecure", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Insecure { get; set; }

        [Newtonsoft.Json.JsonProperty("jsonBody", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? JsonBody { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        /// <summary>
        /// URL of the gRPC server that implements the event source.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GitArtifact
    {
        [Newtonsoft.Json.JsonProperty("branch", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Branch { get; set; }

        /// <summary>
        /// Directory to clone the repository. We clone complete directory because GitArtifact is not limited to any specific Git service providers.
        /// <br/>Hence we don't use any specific git provider client.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cloneDirectory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CloneDirectory { get; set; }

        [Newtonsoft.Json.JsonProperty("creds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GitCreds Creds { get; set; }

        [Newtonsoft.Json.JsonProperty("filePath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FilePath { get; set; }

        [Newtonsoft.Json.JsonProperty("ref", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ref { get; set; }

        [Newtonsoft.Json.JsonProperty("remote", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GitRemoteConfig Remote { get; set; }

        [Newtonsoft.Json.JsonProperty("sshKeySecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector SshKeySecret { get; set; }

        [Newtonsoft.Json.JsonProperty("tag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tag { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GitCreds
    {
        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector Password { get; set; }

        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector Username { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GitRemoteConfig
    {
        /// <summary>
        /// Name of the remote to fetch from.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// URLs the URLs of a remote repository. It must be non-empty. Fetch will
        /// <br/>always use the first URL, while push will use all of them.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("urls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Urls { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GithubAppCreds
    {
        [Newtonsoft.Json.JsonProperty("appID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AppID { get; set; }

        [Newtonsoft.Json.JsonProperty("installationID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InstallationID { get; set; }

        [Newtonsoft.Json.JsonProperty("privateKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector PrivateKey { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GithubEventSource
    {
        [Newtonsoft.Json.JsonProperty("active", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Active { get; set; }

        [Newtonsoft.Json.JsonProperty("apiToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector ApiToken { get; set; }

        [Newtonsoft.Json.JsonProperty("contentType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ContentType { get; set; }

        [Newtonsoft.Json.JsonProperty("deleteHookOnFinish", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DeleteHookOnFinish { get; set; }

        [Newtonsoft.Json.JsonProperty("events", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Events { get; set; }

        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSourceFilter Filter { get; set; }

        [Newtonsoft.Json.JsonProperty("githubApp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GithubAppCreds GithubApp { get; set; }

        [Newtonsoft.Json.JsonProperty("githubBaseURL", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GithubBaseURL { get; set; }

        [Newtonsoft.Json.JsonProperty("githubUploadURL", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GithubUploadURL { get; set; }

        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Id { get; set; }

        [Newtonsoft.Json.JsonProperty("insecure", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Insecure { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        /// <summary>
        /// Organizations holds the names of organizations (used for organization level webhooks). Not required if Repositories is set.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("organizations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Organizations { get; set; }

        [Newtonsoft.Json.JsonProperty("owner", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Owner { get; set; }

        /// <summary>
        /// Repositories holds the information of repositories, which uses repo owner as the key,
        /// <br/>and list of repo names as the value. Not required if Organizations is set.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("repositories", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OwnedRepositories> Repositories { get; set; }

        [Newtonsoft.Json.JsonProperty("repository", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Repository { get; set; }

        [Newtonsoft.Json.JsonProperty("webhook", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WebhookContext Webhook { get; set; }

        [Newtonsoft.Json.JsonProperty("webhookSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector WebhookSecret { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GitlabEventSource
    {
        [Newtonsoft.Json.JsonProperty("accessToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector AccessToken { get; set; }

        [Newtonsoft.Json.JsonProperty("deleteHookOnFinish", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DeleteHookOnFinish { get; set; }

        [Newtonsoft.Json.JsonProperty("enableSSLVerification", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? EnableSSLVerification { get; set; }

        /// <summary>
        /// Events are gitlab event to listen to.
        /// <br/>Refer https://github.com/xanzy/go-gitlab/blob/bf34eca5d13a9f4c3f501d8a97b8ac226d55e4d9/projects.go#L794.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("events", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Events { get; set; }

        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSourceFilter Filter { get; set; }

        [Newtonsoft.Json.JsonProperty("gitlabBaseURL", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GitlabBaseURL { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("projectID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProjectID { get; set; }

        [Newtonsoft.Json.JsonProperty("projects", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Projects { get; set; }

        [Newtonsoft.Json.JsonProperty("secretToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector SecretToken { get; set; }

        [Newtonsoft.Json.JsonProperty("webhook", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WebhookContext Webhook { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HDFSEventSource
    {
        [Newtonsoft.Json.JsonProperty("addresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Addresses { get; set; }

        [Newtonsoft.Json.JsonProperty("checkInterval", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CheckInterval { get; set; }

        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSourceFilter Filter { get; set; }

        /// <summary>
        /// HDFSUser is the user to access HDFS file system.
        /// <br/>It is ignored if either ccache or keytab is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hdfsUser", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HdfsUser { get; set; }

        /// <summary>
        /// KrbCCacheSecret is the secret selector for Kerberos ccache
        /// <br/>Either ccache or keytab can be set to use Kerberos.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("krbCCacheSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector KrbCCacheSecret { get; set; }

        /// <summary>
        /// KrbConfig is the configmap selector for Kerberos config as string
        /// <br/>It must be set if either ccache or keytab is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("krbConfigConfigMap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConfigMapKeySelector KrbConfigConfigMap { get; set; }

        /// <summary>
        /// KrbKeytabSecret is the secret selector for Kerberos keytab
        /// <br/>Either ccache or keytab can be set to use Kerberos.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("krbKeytabSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector KrbKeytabSecret { get; set; }

        /// <summary>
        /// KrbRealm is the Kerberos realm used with Kerberos keytab
        /// <br/>It must be set if keytab is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("krbRealm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KrbRealm { get; set; }

        /// <summary>
        /// KrbServicePrincipalName is the principal name of Kerberos service
        /// <br/>It must be set if either ccache or keytab is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("krbServicePrincipalName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KrbServicePrincipalName { get; set; }

        /// <summary>
        /// KrbUsername is the Kerberos username used with Kerberos keytab
        /// <br/>It must be set if keytab is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("krbUsername", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KrbUsername { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        [Newtonsoft.Json.JsonProperty("watchPathConfig", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WatchPathConfig WatchPathConfig { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HTTPTrigger
    {
        [Newtonsoft.Json.JsonProperty("basicAuth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public BasicAuth BasicAuth { get; set; }

        [Newtonsoft.Json.JsonProperty("headers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Headers { get; set; }

        [Newtonsoft.Json.JsonProperty("method", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Method { get; set; }

        /// <summary>
        /// Parameters is the list of key-value extracted from event's payload that are applied to
        /// <br/>the HTTP trigger resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TriggerParameter> Parameters { get; set; }

        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TriggerParameter> Payload { get; set; }

        [Newtonsoft.Json.JsonProperty("secureHeaders", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SecureHeader> SecureHeaders { get; set; }

        [Newtonsoft.Json.JsonProperty("timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Timeout { get; set; }

        [Newtonsoft.Json.JsonProperty("tls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TLSConfig Tls { get; set; }

        /// <summary>
        /// URL refers to the URL to send HTTP request to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Int64OrString
    {
        [Newtonsoft.Json.JsonProperty("int64Val", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Int64Val { get; set; }

        [Newtonsoft.Json.JsonProperty("strVal", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StrVal { get; set; }

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class K8SResourcePolicy
    {
        [Newtonsoft.Json.JsonProperty("backoff", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Backoff2 Backoff { get; set; }

        [Newtonsoft.Json.JsonProperty("errorOnBackoffTimeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ErrorOnBackoffTimeout { get; set; }

        [Newtonsoft.Json.JsonProperty("labels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KafkaConsumerGroup
    {
        [Newtonsoft.Json.JsonProperty("groupName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GroupName { get; set; }

        [Newtonsoft.Json.JsonProperty("oldest", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Oldest { get; set; }

        [Newtonsoft.Json.JsonProperty("rebalanceStrategy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RebalanceStrategy { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KafkaEventSource
    {
        /// <summary>
        /// Backoff holds parameters applied to connection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("connectionBackoff", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Backoff2 ConnectionBackoff { get; set; }

        [Newtonsoft.Json.JsonProperty("consumerGroup", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KafkaConsumerGroup ConsumerGroup { get; set; }

        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSourceFilter Filter { get; set; }

        [Newtonsoft.Json.JsonProperty("jsonBody", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? JsonBody { get; set; }

        [Newtonsoft.Json.JsonProperty("limitEventsPerSecond", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LimitEventsPerSecond { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("partition", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Partition { get; set; }

        [Newtonsoft.Json.JsonProperty("sasl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SASLConfig Sasl { get; set; }

        [Newtonsoft.Json.JsonProperty("tls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TLSConfig Tls { get; set; }

        [Newtonsoft.Json.JsonProperty("topic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Topic { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Version { get; set; }

    }

    /// <summary>
    /// KafkaTrigger refers to the specification of the Kafka trigger.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KafkaTrigger
    {
        [Newtonsoft.Json.JsonProperty("compress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Compress { get; set; }

        [Newtonsoft.Json.JsonProperty("flushFrequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? FlushFrequency { get; set; }

        /// <summary>
        /// Parameters is the list of parameters that is applied to resolved Kafka trigger object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TriggerParameter> Parameters { get; set; }

        /// <summary>
        /// Partition to write data to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("partition", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Partition { get; set; }

        /// <summary>
        /// The partitioning key for the messages put on the Kafka topic.
        /// <br/>Defaults to broker url.
        /// <br/>+optional.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("partitioningKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PartitioningKey { get; set; }

        /// <summary>
        /// Payload is the list of key-value extracted from an event payload to construct the request payload.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TriggerParameter> Payload { get; set; }

        /// <summary>
        /// RequiredAcks used in producer to tell the broker how many replica acknowledgements
        /// <br/>Defaults to 1 (Only wait for the leader to ack).
        /// <br/>+optional.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("requiredAcks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? RequiredAcks { get; set; }

        [Newtonsoft.Json.JsonProperty("sasl", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SASLConfig Sasl { get; set; }

        [Newtonsoft.Json.JsonProperty("tls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TLSConfig Tls { get; set; }

        [Newtonsoft.Json.JsonProperty("topic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Topic { get; set; }

        /// <summary>
        /// URL of the Kafka broker, multiple URLs separated by comma.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Version { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LogTrigger
    {
        [Newtonsoft.Json.JsonProperty("intervalSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IntervalSeconds { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class MQTTEventSource
    {
        [Newtonsoft.Json.JsonProperty("clientId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClientId { get; set; }

        /// <summary>
        /// ConnectionBackoff holds backoff applied to connection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("connectionBackoff", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Backoff2 ConnectionBackoff { get; set; }

        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSourceFilter Filter { get; set; }

        [Newtonsoft.Json.JsonProperty("jsonBody", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? JsonBody { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("tls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TLSConfig Tls { get; set; }

        [Newtonsoft.Json.JsonProperty("topic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Topic { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Metadata2
    {
        [Newtonsoft.Json.JsonProperty("annotations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Annotations { get; set; }

        [Newtonsoft.Json.JsonProperty("labels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NATSAuth2
    {
        [Newtonsoft.Json.JsonProperty("basic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public BasicAuth Basic { get; set; }

        [Newtonsoft.Json.JsonProperty("credential", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector Credential { get; set; }

        [Newtonsoft.Json.JsonProperty("nkey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector Nkey { get; set; }

        [Newtonsoft.Json.JsonProperty("token", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector Token { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NATSEventsSource
    {
        [Newtonsoft.Json.JsonProperty("auth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public NATSAuth2 Auth { get; set; }

        /// <summary>
        /// ConnectionBackoff holds backoff applied to connection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("connectionBackoff", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Backoff2 ConnectionBackoff { get; set; }

        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSourceFilter Filter { get; set; }

        [Newtonsoft.Json.JsonProperty("jsonBody", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? JsonBody { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("subject", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Subject { get; set; }

        [Newtonsoft.Json.JsonProperty("tls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TLSConfig Tls { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

    }

    /// <summary>
    /// NATSTrigger refers to the specification of the NATS trigger.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NATSTrigger
    {
        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TriggerParameter> Parameters { get; set; }

        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TriggerParameter> Payload { get; set; }

        /// <summary>
        /// Name of the subject to put message on.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subject", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Subject { get; set; }

        [Newtonsoft.Json.JsonProperty("tls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TLSConfig Tls { get; set; }

        /// <summary>
        /// URL of the NATS cluster.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NSQEventSource
    {
        [Newtonsoft.Json.JsonProperty("channel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Channel { get; set; }

        [Newtonsoft.Json.JsonProperty("connectionBackoff", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Backoff2 ConnectionBackoff { get; set; }

        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSourceFilter Filter { get; set; }

        [Newtonsoft.Json.JsonProperty("hostAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HostAddress { get; set; }

        [Newtonsoft.Json.JsonProperty("jsonBody", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? JsonBody { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("tls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TLSConfig Tls { get; set; }

        /// <summary>
        /// Topic to subscribe to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("topic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Topic { get; set; }

    }

    /// <summary>
    /// OpenWhiskTrigger refers to the specification of the OpenWhisk trigger.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OpenWhiskTrigger
    {
        /// <summary>
        /// Name of the action/function.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("actionName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ActionName { get; set; }

        [Newtonsoft.Json.JsonProperty("authToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector AuthToken { get; set; }

        /// <summary>
        /// Host URL of the OpenWhisk.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("host", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Host { get; set; }

        /// <summary>
        /// Namespace for the action.
        /// <br/>Defaults to "_".
        /// <br/>+optional.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TriggerParameter> Parameters { get; set; }

        /// <summary>
        /// Payload is the list of key-value extracted from an event payload to construct the request payload.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TriggerParameter> Payload { get; set; }

        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Version { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OwnedRepositories
    {
        [Newtonsoft.Json.JsonProperty("names", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Names { get; set; }

        [Newtonsoft.Json.JsonProperty("owner", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Owner { get; set; }

    }

    /// <summary>
    /// PayloadField binds a value at path within the event payload against a name.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PayloadField
    {
        /// <summary>
        /// Name acts as key that holds the value at the path.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Path is the JSONPath of the event's (JSON decoded) data key
        /// <br/>Path is a series of keys separated by a dot. A key may contain wildcard characters '*' and '?'.
        /// <br/>To access an array value use the index as the key. The dot and wildcard characters can be escaped with '\\'.
        /// <br/>See https://github.com/tidwall/gjson#path-syntax for more information on how to use this.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }

    }

    /// <summary>
    /// PubSubEventSource refers to event-source for GCP PubSub related events.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PubSubEventSource
    {
        [Newtonsoft.Json.JsonProperty("credentialSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector CredentialSecret { get; set; }

        [Newtonsoft.Json.JsonProperty("deleteSubscriptionOnFinish", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DeleteSubscriptionOnFinish { get; set; }

        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSourceFilter Filter { get; set; }

        [Newtonsoft.Json.JsonProperty("jsonBody", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? JsonBody { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("projectID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProjectID { get; set; }

        [Newtonsoft.Json.JsonProperty("subscriptionID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SubscriptionID { get; set; }

        [Newtonsoft.Json.JsonProperty("topic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Topic { get; set; }

        [Newtonsoft.Json.JsonProperty("topicProjectID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TopicProjectID { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PulsarEventSource
    {
        [Newtonsoft.Json.JsonProperty("authTokenSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector AuthTokenSecret { get; set; }

        [Newtonsoft.Json.JsonProperty("connectionBackoff", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Backoff2 ConnectionBackoff { get; set; }

        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSourceFilter Filter { get; set; }

        [Newtonsoft.Json.JsonProperty("jsonBody", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? JsonBody { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("tls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TLSConfig Tls { get; set; }

        [Newtonsoft.Json.JsonProperty("tlsAllowInsecureConnection", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? TlsAllowInsecureConnection { get; set; }

        [Newtonsoft.Json.JsonProperty("tlsTrustCertsSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector TlsTrustCertsSecret { get; set; }

        [Newtonsoft.Json.JsonProperty("tlsValidateHostname", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? TlsValidateHostname { get; set; }

        [Newtonsoft.Json.JsonProperty("topics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Topics { get; set; }

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

    }

    /// <summary>
    /// PulsarTrigger refers to the specification of the Pulsar trigger.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PulsarTrigger
    {
        [Newtonsoft.Json.JsonProperty("authTokenSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector AuthTokenSecret { get; set; }

        [Newtonsoft.Json.JsonProperty("connectionBackoff", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Backoff2 ConnectionBackoff { get; set; }

        /// <summary>
        /// Parameters is the list of parameters that is applied to resolved Kafka trigger object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TriggerParameter> Parameters { get; set; }

        /// <summary>
        /// Payload is the list of key-value extracted from an event payload to construct the request payload.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("payload", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TriggerParameter> Payload { get; set; }

        [Newtonsoft.Json.JsonProperty("tls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TLSConfig Tls { get; set; }

        [Newtonsoft.Json.JsonProperty("tlsAllowInsecureConnection", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? TlsAllowInsecureConnection { get; set; }

        [Newtonsoft.Json.JsonProperty("tlsTrustCertsSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector TlsTrustCertsSecret { get; set; }

        [Newtonsoft.Json.JsonProperty("tlsValidateHostname", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? TlsValidateHostname { get; set; }

        [Newtonsoft.Json.JsonProperty("topic", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Topic { get; set; }

        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RateLimit
    {
        [Newtonsoft.Json.JsonProperty("requestsPerUnit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? RequestsPerUnit { get; set; }

        [Newtonsoft.Json.JsonProperty("unit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Unit { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RedisEventSource
    {
        [Newtonsoft.Json.JsonProperty("channels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Channels { get; set; }

        [Newtonsoft.Json.JsonProperty("db", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Db { get; set; }

        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSourceFilter Filter { get; set; }

        [Newtonsoft.Json.JsonProperty("hostAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HostAddress { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector Password { get; set; }

        [Newtonsoft.Json.JsonProperty("tls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TLSConfig Tls { get; set; }

    }

    /// <summary>
    /// Resource represent arbitrary structured data.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Resource
    {
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public byte[] Value { get; set; }

    }

    /// <summary>
    /// ResourceEventSource refers to a event-source for K8s resource related events.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ResourceEventSource
    {
        /// <summary>
        /// EventTypes is the list of event type to watch.
        /// <br/>Possible values are - ADD, UPDATE and DELETE.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("eventTypes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> EventTypes { get; set; }

        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceFilter Filter { get; set; }

        [Newtonsoft.Json.JsonProperty("groupVersionResource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GroupVersionResource GroupVersionResource { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ResourceFilter
    {
        [Newtonsoft.Json.JsonProperty("afterStart", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AfterStart { get; set; }

        [Newtonsoft.Json.JsonProperty("createdBy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CreatedBy { get; set; }

        [Newtonsoft.Json.JsonProperty("fields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Selector> Fields { get; set; }

        [Newtonsoft.Json.JsonProperty("labels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Selector> Labels { get; set; }

        [Newtonsoft.Json.JsonProperty("prefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Prefix { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class S3Artifact
    {
        [Newtonsoft.Json.JsonProperty("accessKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector AccessKey { get; set; }

        [Newtonsoft.Json.JsonProperty("bucket", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public S3Bucket Bucket { get; set; }

        [Newtonsoft.Json.JsonProperty("endpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Endpoint { get; set; }

        [Newtonsoft.Json.JsonProperty("events", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Events { get; set; }

        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public S3Filter Filter { get; set; }

        [Newtonsoft.Json.JsonProperty("insecure", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Insecure { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("region", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Region { get; set; }

        [Newtonsoft.Json.JsonProperty("secretKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector SecretKey { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class S3Bucket
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class S3Filter
    {
        [Newtonsoft.Json.JsonProperty("prefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Prefix { get; set; }

        [Newtonsoft.Json.JsonProperty("suffix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Suffix { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SASLConfig
    {
        [Newtonsoft.Json.JsonProperty("mechanism", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Mechanism { get; set; }

        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector Password { get; set; }

        [Newtonsoft.Json.JsonProperty("user", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector User { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SNSEventSource
    {
        [Newtonsoft.Json.JsonProperty("accessKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector AccessKey { get; set; }

        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSourceFilter Filter { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("region", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Region { get; set; }

        [Newtonsoft.Json.JsonProperty("roleARN", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RoleARN { get; set; }

        [Newtonsoft.Json.JsonProperty("secretKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector SecretKey { get; set; }

        [Newtonsoft.Json.JsonProperty("topicArn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TopicArn { get; set; }

        [Newtonsoft.Json.JsonProperty("validateSignature", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ValidateSignature { get; set; }

        [Newtonsoft.Json.JsonProperty("webhook", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WebhookContext Webhook { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SQSEventSource
    {
        [Newtonsoft.Json.JsonProperty("accessKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector AccessKey { get; set; }

        [Newtonsoft.Json.JsonProperty("dlq", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Dlq { get; set; }

        [Newtonsoft.Json.JsonProperty("endpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Endpoint { get; set; }

        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSourceFilter Filter { get; set; }

        [Newtonsoft.Json.JsonProperty("jsonBody", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? JsonBody { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("queue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Queue { get; set; }

        [Newtonsoft.Json.JsonProperty("queueAccountId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string QueueAccountId { get; set; }

        [Newtonsoft.Json.JsonProperty("region", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Region { get; set; }

        [Newtonsoft.Json.JsonProperty("roleARN", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RoleARN { get; set; }

        [Newtonsoft.Json.JsonProperty("secretKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector SecretKey { get; set; }

        /// <summary>
        /// WaitTimeSeconds is The duration (in seconds) for which the call waits for a message to arrive
        /// <br/>in the queue before returning.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("waitTimeSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WaitTimeSeconds { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SecureHeader
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("valueFrom", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ValueFromSource ValueFrom { get; set; }

    }

    /// <summary>
    /// Selector represents conditional operation to select K8s objects.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Selector
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }

        [Newtonsoft.Json.JsonProperty("operation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Operation { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Sensor
    {
        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ObjectMeta Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("spec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SensorSpec Spec { get; set; }

        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SensorStatus Status { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SensorList
    {
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Sensor> Items { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ListMeta Metadata { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SensorSpec
    {
        /// <summary>
        /// Dependencies is a list of the events that this sensor is dependent on.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dependencies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<EventDependency> Dependencies { get; set; }

        /// <summary>
        /// ErrorOnFailedRound if set to true, marks sensor state as `error` if the previous trigger round fails.
        /// <br/>Once sensor state is set to `error`, no further triggers will be processed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("errorOnFailedRound", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ErrorOnFailedRound { get; set; }

        [Newtonsoft.Json.JsonProperty("eventBusName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EventBusName { get; set; }

        [Newtonsoft.Json.JsonProperty("replicas", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Replicas { get; set; }

        [Newtonsoft.Json.JsonProperty("template", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Template Template { get; set; }

        /// <summary>
        /// Triggers is a list of the things that this sensor evokes. These are the outputs from this sensor.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("triggers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Trigger> Triggers { get; set; }

    }

    /// <summary>
    /// SensorStatus contains information about the status of a sensor.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SensorStatus
    {
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Status Status { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Service
    {
        [Newtonsoft.Json.JsonProperty("clusterIP", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClusterIP { get; set; }

        [Newtonsoft.Json.JsonProperty("ports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ServicePort> Ports { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SlackEventSource
    {
        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSourceFilter Filter { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("signingSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector SigningSecret { get; set; }

        [Newtonsoft.Json.JsonProperty("token", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector Token { get; set; }

        [Newtonsoft.Json.JsonProperty("webhook", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WebhookContext Webhook { get; set; }

    }

    /// <summary>
    /// SlackTrigger refers to the specification of the slack notification trigger.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SlackTrigger
    {
        [Newtonsoft.Json.JsonProperty("channel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Channel { get; set; }

        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TriggerParameter> Parameters { get; set; }

        /// <summary>
        /// SlackToken refers to the Kubernetes secret that holds the slack token required to send messages.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("slackToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector SlackToken { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StandardK8STrigger
    {
        [Newtonsoft.Json.JsonProperty("liveObject", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? LiveObject { get; set; }

        [Newtonsoft.Json.JsonProperty("operation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Operation { get; set; }

        /// <summary>
        /// Parameters is the list of parameters that is applied to resolved K8s trigger object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TriggerParameter> Parameters { get; set; }

        [Newtonsoft.Json.JsonProperty("patchStrategy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PatchStrategy { get; set; }

        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ArtifactLocation Source { get; set; }

    }

    /// <summary>
    /// Status is a common structure which can be used for Status field.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Status
    {
        [Newtonsoft.Json.JsonProperty("conditions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Condition> Conditions { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StatusPolicy
    {
        [Newtonsoft.Json.JsonProperty("allow", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<int> Allow { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StorageGridEventSource
    {
        /// <summary>
        /// APIURL is the url of the storagegrid api.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apiURL", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ApiURL { get; set; }

        [Newtonsoft.Json.JsonProperty("authToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector AuthToken { get; set; }

        /// <summary>
        /// Name of the bucket to register notifications for.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bucket", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Bucket { get; set; }

        [Newtonsoft.Json.JsonProperty("events", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Events { get; set; }

        /// <summary>
        /// Filter on object key which caused the notification.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("filter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StorageGridFilter Filter { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("region", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Region { get; set; }

        [Newtonsoft.Json.JsonProperty("topicArn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TopicArn { get; set; }

        [Newtonsoft.Json.JsonProperty("webhook", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WebhookContext Webhook { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StorageGridFilter
    {
        [Newtonsoft.Json.JsonProperty("prefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Prefix { get; set; }

        [Newtonsoft.Json.JsonProperty("suffix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Suffix { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StripeEventSource
    {
        [Newtonsoft.Json.JsonProperty("apiKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector ApiKey { get; set; }

        [Newtonsoft.Json.JsonProperty("createWebhook", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CreateWebhook { get; set; }

        [Newtonsoft.Json.JsonProperty("eventFilter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> EventFilter { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("webhook", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WebhookContext Webhook { get; set; }

    }

    /// <summary>
    /// TLSConfig refers to TLS configuration for a client.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TLSConfig
    {
        [Newtonsoft.Json.JsonProperty("caCertSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector CaCertSecret { get; set; }

        [Newtonsoft.Json.JsonProperty("clientCertSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector ClientCertSecret { get; set; }

        [Newtonsoft.Json.JsonProperty("clientKeySecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector ClientKeySecret { get; set; }

        [Newtonsoft.Json.JsonProperty("insecureSkipVerify", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? InsecureSkipVerify { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Template
    {
        [Newtonsoft.Json.JsonProperty("affinity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Affinity Affinity { get; set; }

        [Newtonsoft.Json.JsonProperty("container", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Container2 Container { get; set; }

        [Newtonsoft.Json.JsonProperty("imagePullSecrets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LocalObjectReference> ImagePullSecrets { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Metadata2 Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("nodeSelector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> NodeSelector { get; set; }

        [Newtonsoft.Json.JsonProperty("priority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Priority { get; set; }

        [Newtonsoft.Json.JsonProperty("priorityClassName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PriorityClassName { get; set; }

        [Newtonsoft.Json.JsonProperty("securityContext", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PodSecurityContext SecurityContext { get; set; }

        [Newtonsoft.Json.JsonProperty("serviceAccountName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ServiceAccountName { get; set; }

        [Newtonsoft.Json.JsonProperty("tolerations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Toleration> Tolerations { get; set; }

        [Newtonsoft.Json.JsonProperty("volumes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Volume> Volumes { get; set; }

    }

    /// <summary>
    /// TimeFilter describes a window in time.
    /// <br/>It filters out events that occur outside the time limits.
    /// <br/>In other words, only events that occur after Start and before Stop
    /// <br/>will pass this filter.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TimeFilter
    {
        /// <summary>
        /// Start is the beginning of a time window in UTC.
        /// <br/>Before this time, events for this dependency are ignored.
        /// <br/>Format is hh:mm:ss.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Start { get; set; }

        /// <summary>
        /// Stop is the end of a time window in UTC.
        /// <br/>After or equal to this time, events for this dependency are ignored and
        /// <br/>Format is hh:mm:ss.
        /// <br/>If it is smaller than Start, it is treated as next day of Start
        /// <br/>(e.g.: 22:00:00-01:00:00 means 22:00:00-25:00:00).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stop", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Stop { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Trigger
    {
        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<TriggerParameter> Parameters { get; set; }

        [Newtonsoft.Json.JsonProperty("policy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TriggerPolicy Policy { get; set; }

        [Newtonsoft.Json.JsonProperty("rateLimit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RateLimit RateLimit { get; set; }

        [Newtonsoft.Json.JsonProperty("retryStrategy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Backoff2 RetryStrategy { get; set; }

        /// <summary>
        /// Template describes the trigger specification.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("template", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TriggerTemplate Template { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TriggerParameter
    {
        /// <summary>
        /// Dest is the JSONPath of a resource key.
        /// <br/>A path is a series of keys separated by a dot. The colon character can be escaped with '.'
        /// <br/>The -1 key can be used to append a value to an existing array.
        /// <br/>See https://github.com/tidwall/sjson#path-syntax for more information about how this is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dest", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Dest { get; set; }

        /// <summary>
        /// Operation is what to do with the existing value at Dest, whether to
        /// <br/>'prepend', 'overwrite', or 'append' it.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("operation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Operation { get; set; }

        [Newtonsoft.Json.JsonProperty("src", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TriggerParameterSource Src { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TriggerParameterSource
    {
        /// <summary>
        /// ContextKey is the JSONPath of the event's (JSON decoded) context key
        /// <br/>ContextKey is a series of keys separated by a dot. A key may contain wildcard characters '*' and '?'.
        /// <br/>To access an array value use the index as the key. The dot and wildcard characters can be escaped with '\\'.
        /// <br/>See https://github.com/tidwall/gjson#path-syntax for more information on how to use this.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("contextKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ContextKey { get; set; }

        [Newtonsoft.Json.JsonProperty("contextTemplate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ContextTemplate { get; set; }

        /// <summary>
        /// DataKey is the JSONPath of the event's (JSON decoded) data key
        /// <br/>DataKey is a series of keys separated by a dot. A key may contain wildcard characters '*' and '?'.
        /// <br/>To access an array value use the index as the key. The dot and wildcard characters can be escaped with '\\'.
        /// <br/>See https://github.com/tidwall/gjson#path-syntax for more information on how to use this.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dataKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DataKey { get; set; }

        [Newtonsoft.Json.JsonProperty("dataTemplate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DataTemplate { get; set; }

        /// <summary>
        /// DependencyName refers to the name of the dependency. The event which is stored for this dependency is used as payload
        /// <br/>for the parameterization. Make sure to refer to one of the dependencies you have defined under Dependencies list.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dependencyName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DependencyName { get; set; }

        /// <summary>
        /// Value is the default literal value to use for this parameter source
        /// <br/>This is only used if the DataKey is invalid.
        /// <br/>If the DataKey is invalid and this is not defined, this param source will produce an error.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TriggerPolicy
    {
        [Newtonsoft.Json.JsonProperty("k8s", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public K8SResourcePolicy K8s { get; set; }

        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StatusPolicy Status { get; set; }

    }

    /// <summary>
    /// TriggerTemplate is the template that describes trigger specification.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TriggerTemplate
    {
        [Newtonsoft.Json.JsonProperty("argoWorkflow", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ArgoWorkflowTrigger ArgoWorkflow { get; set; }

        [Newtonsoft.Json.JsonProperty("awsLambda", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AWSLambdaTrigger AwsLambda { get; set; }

        [Newtonsoft.Json.JsonProperty("azureEventHubs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AzureEventHubsTrigger AzureEventHubs { get; set; }

        [Newtonsoft.Json.JsonProperty("conditions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Conditions { get; set; }

        [Newtonsoft.Json.JsonProperty("conditionsReset", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ConditionsResetCriteria> ConditionsReset { get; set; }

        [Newtonsoft.Json.JsonProperty("custom", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CustomTrigger Custom { get; set; }

        [Newtonsoft.Json.JsonProperty("http", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HTTPTrigger Http { get; set; }

        [Newtonsoft.Json.JsonProperty("k8s", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StandardK8STrigger K8s { get; set; }

        /// <summary>
        /// Kafka refers to the trigger designed to place messages on Kafka topic.
        /// <br/>+optional.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kafka", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public KafkaTrigger Kafka { get; set; }

        [Newtonsoft.Json.JsonProperty("log", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LogTrigger Log { get; set; }

        /// <summary>
        /// Name is a unique name of the action to take.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// NATS refers to the trigger designed to place message on NATS subject.
        /// <br/>+optional.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nats", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public NATSTrigger Nats { get; set; }

        [Newtonsoft.Json.JsonProperty("openWhisk", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OpenWhiskTrigger OpenWhisk { get; set; }

        [Newtonsoft.Json.JsonProperty("pulsar", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PulsarTrigger Pulsar { get; set; }

        [Newtonsoft.Json.JsonProperty("slack", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SlackTrigger Slack { get; set; }

    }

    /// <summary>
    /// URLArtifact contains information about an artifact at an http endpoint.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class URLArtifact
    {
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }

        [Newtonsoft.Json.JsonProperty("verifyCert", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? VerifyCert { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ValueFromSource
    {
        [Newtonsoft.Json.JsonProperty("configMapKeyRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConfigMapKeySelector ConfigMapKeyRef { get; set; }

        [Newtonsoft.Json.JsonProperty("secretKeyRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector SecretKeyRef { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WatchPathConfig
    {
        [Newtonsoft.Json.JsonProperty("directory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Directory { get; set; }

        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }

        [Newtonsoft.Json.JsonProperty("pathRegexp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PathRegexp { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WebhookContext
    {
        [Newtonsoft.Json.JsonProperty("authSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector AuthSecret { get; set; }

        [Newtonsoft.Json.JsonProperty("endpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Endpoint { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Metadata { get; set; }

        [Newtonsoft.Json.JsonProperty("method", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Method { get; set; }

        /// <summary>
        /// Port on which HTTP server is listening for incoming events.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Port { get; set; }

        /// <summary>
        /// ServerCertPath refers the file that contains the cert.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("serverCertSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector ServerCertSecret { get; set; }

        [Newtonsoft.Json.JsonProperty("serverKeySecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector ServerKeySecret { get; set; }

        /// <summary>
        /// URL is the url of the server.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }

    }

    /// <summary>
    /// ArchiveStrategy describes how to archive files/directory when saving artifacts
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ArchiveStrategy
    {
        [Newtonsoft.Json.JsonProperty("none", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public NoneStrategy None { get; set; }

        [Newtonsoft.Json.JsonProperty("tar", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TarStrategy Tar { get; set; }

        [Newtonsoft.Json.JsonProperty("zip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ZipStrategy Zip { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ArchivedWorkflowDeletedResponse
    {

    }

    /// <summary>
    /// Arguments to a template
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Arguments
    {
        /// <summary>
        /// Artifacts is the list of artifacts to pass to the template or workflow
        /// </summary>
        [Newtonsoft.Json.JsonProperty("artifacts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Artifact> Artifacts { get; set; }

        /// <summary>
        /// Parameters is the list of parameters to pass to the template or workflow
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Parameter> Parameters { get; set; }

    }

    /// <summary>
    /// Artifact indicates an artifact to place at a specified path
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Artifact
    {
        /// <summary>
        /// Archive controls how the artifact will be saved to the artifact repository.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("archive", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ArchiveStrategy Archive { get; set; }

        /// <summary>
        /// ArchiveLogs indicates if the container logs should be archived
        /// </summary>
        [Newtonsoft.Json.JsonProperty("archiveLogs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ArchiveLogs { get; set; }

        /// <summary>
        /// Artifactory contains artifactory artifact location details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("artifactory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ArtifactoryArtifact Artifactory { get; set; }

        /// <summary>
        /// From allows an artifact to reference an artifact from a previous step
        /// </summary>
        [Newtonsoft.Json.JsonProperty("from", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string From { get; set; }

        /// <summary>
        /// FromExpression, if defined, is evaluated to specify the value for the artifact
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fromExpression", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FromExpression { get; set; }

        /// <summary>
        /// GCS contains GCS artifact location details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gcs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GCSArtifact Gcs { get; set; }

        /// <summary>
        /// Git contains git artifact location details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("git", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GitArtifact2 Git { get; set; }

        /// <summary>
        /// GlobalName exports an output artifact to the global scope, making it available as '{{io.argoproj.workflow.v1alpha1.outputs.artifacts.XXXX}} and in workflow.status.outputs.artifacts
        /// </summary>
        [Newtonsoft.Json.JsonProperty("globalName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GlobalName { get; set; }

        /// <summary>
        /// HDFS contains HDFS artifact location details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hdfs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HDFSArtifact Hdfs { get; set; }

        /// <summary>
        /// HTTP contains HTTP artifact location details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("http", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HTTPArtifact Http { get; set; }

        /// <summary>
        /// mode bits to use on this file, must be a value between 0 and 0777 set when loading input artifacts.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Mode { get; set; }

        /// <summary>
        /// name of the artifact. must be unique within a template's inputs/outputs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Make Artifacts optional, if Artifacts doesn't generate or exist
        /// </summary>
        [Newtonsoft.Json.JsonProperty("optional", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Optional { get; set; }

        /// <summary>
        /// OSS contains OSS artifact location details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("oss", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OSSArtifact Oss { get; set; }

        /// <summary>
        /// Path is the container path to the artifact
        /// </summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }

        /// <summary>
        /// Raw contains raw artifact location details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("raw", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RawArtifact Raw { get; set; }

        /// <summary>
        /// If mode is set, apply the permission recursively into the artifact if it is a folder
        /// </summary>
        [Newtonsoft.Json.JsonProperty("recurseMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RecurseMode { get; set; }

        /// <summary>
        /// S3 contains S3 artifact location details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("s3", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public S3Artifact2 S3 { get; set; }

        /// <summary>
        /// SubPath allows an artifact to be sourced from a subpath within the specified source
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subPath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SubPath { get; set; }

    }

    /// <summary>
    /// ArtifactLocation describes a location for a single or multiple artifacts. It is used as single artifact in the context of inputs/outputs (e.g. outputs.artifacts.artname). It is also used to describe the location of multiple artifacts such as the archive location of a single workflow step, which the executor will use as a default location to store its files.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ArtifactLocation2
    {
        /// <summary>
        /// ArchiveLogs indicates if the container logs should be archived
        /// </summary>
        [Newtonsoft.Json.JsonProperty("archiveLogs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ArchiveLogs { get; set; }

        /// <summary>
        /// Artifactory contains artifactory artifact location details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("artifactory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ArtifactoryArtifact Artifactory { get; set; }

        /// <summary>
        /// GCS contains GCS artifact location details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gcs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GCSArtifact Gcs { get; set; }

        /// <summary>
        /// Git contains git artifact location details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("git", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GitArtifact2 Git { get; set; }

        /// <summary>
        /// HDFS contains HDFS artifact location details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hdfs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HDFSArtifact Hdfs { get; set; }

        /// <summary>
        /// HTTP contains HTTP artifact location details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("http", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HTTPArtifact Http { get; set; }

        /// <summary>
        /// OSS contains OSS artifact location details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("oss", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OSSArtifact Oss { get; set; }

        /// <summary>
        /// Raw contains raw artifact location details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("raw", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RawArtifact Raw { get; set; }

        /// <summary>
        /// S3 contains S3 artifact location details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("s3", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public S3Artifact2 S3 { get; set; }

    }

    /// <summary>
    /// ArtifactPaths expands a step from a collection of artifacts
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ArtifactPaths
    {
        /// <summary>
        /// Archive controls how the artifact will be saved to the artifact repository.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("archive", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ArchiveStrategy Archive { get; set; }

        /// <summary>
        /// ArchiveLogs indicates if the container logs should be archived
        /// </summary>
        [Newtonsoft.Json.JsonProperty("archiveLogs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ArchiveLogs { get; set; }

        /// <summary>
        /// Artifactory contains artifactory artifact location details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("artifactory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ArtifactoryArtifact Artifactory { get; set; }

        /// <summary>
        /// From allows an artifact to reference an artifact from a previous step
        /// </summary>
        [Newtonsoft.Json.JsonProperty("from", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string From { get; set; }

        /// <summary>
        /// FromExpression, if defined, is evaluated to specify the value for the artifact
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fromExpression", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FromExpression { get; set; }

        /// <summary>
        /// GCS contains GCS artifact location details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gcs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GCSArtifact Gcs { get; set; }

        /// <summary>
        /// Git contains git artifact location details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("git", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GitArtifact2 Git { get; set; }

        /// <summary>
        /// GlobalName exports an output artifact to the global scope, making it available as '{{io.argoproj.workflow.v1alpha1.outputs.artifacts.XXXX}} and in workflow.status.outputs.artifacts
        /// </summary>
        [Newtonsoft.Json.JsonProperty("globalName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GlobalName { get; set; }

        /// <summary>
        /// HDFS contains HDFS artifact location details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hdfs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HDFSArtifact Hdfs { get; set; }

        /// <summary>
        /// HTTP contains HTTP artifact location details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("http", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HTTPArtifact Http { get; set; }

        /// <summary>
        /// mode bits to use on this file, must be a value between 0 and 0777 set when loading input artifacts.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Mode { get; set; }

        /// <summary>
        /// name of the artifact. must be unique within a template's inputs/outputs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Make Artifacts optional, if Artifacts doesn't generate or exist
        /// </summary>
        [Newtonsoft.Json.JsonProperty("optional", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Optional { get; set; }

        /// <summary>
        /// OSS contains OSS artifact location details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("oss", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OSSArtifact Oss { get; set; }

        /// <summary>
        /// Path is the container path to the artifact
        /// </summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }

        /// <summary>
        /// Raw contains raw artifact location details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("raw", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RawArtifact Raw { get; set; }

        /// <summary>
        /// If mode is set, apply the permission recursively into the artifact if it is a folder
        /// </summary>
        [Newtonsoft.Json.JsonProperty("recurseMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RecurseMode { get; set; }

        /// <summary>
        /// S3 contains S3 artifact location details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("s3", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public S3Artifact2 S3 { get; set; }

        /// <summary>
        /// SubPath allows an artifact to be sourced from a subpath within the specified source
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subPath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SubPath { get; set; }

    }

    /// <summary>
    /// ArtifactRepository represents an artifact repository in which a controller will store its artifacts
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ArtifactRepository
    {
        /// <summary>
        /// ArchiveLogs enables log archiving
        /// </summary>
        [Newtonsoft.Json.JsonProperty("archiveLogs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ArchiveLogs { get; set; }

        /// <summary>
        /// Artifactory stores artifacts to JFrog Artifactory
        /// </summary>
        [Newtonsoft.Json.JsonProperty("artifactory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ArtifactoryArtifactRepository Artifactory { get; set; }

        /// <summary>
        /// GCS stores artifact in a GCS object store
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gcs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GCSArtifactRepository Gcs { get; set; }

        /// <summary>
        /// HDFS stores artifacts in HDFS
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hdfs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HDFSArtifactRepository Hdfs { get; set; }

        /// <summary>
        /// OSS stores artifact in a OSS-compliant object store
        /// </summary>
        [Newtonsoft.Json.JsonProperty("oss", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OSSArtifactRepository Oss { get; set; }

        /// <summary>
        /// S3 stores artifact in a S3-compliant object store
        /// </summary>
        [Newtonsoft.Json.JsonProperty("s3", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public S3ArtifactRepository S3 { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ArtifactRepositoryRef
    {
        /// <summary>
        /// The name of the config map. Defaults to "artifact-repositories".
        /// </summary>
        [Newtonsoft.Json.JsonProperty("configMap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConfigMap { get; set; }

        /// <summary>
        /// The config map key. Defaults to the value of the "workflows.argoproj.io/default-artifact-repository" annotation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ArtifactRepositoryRefStatus
    {
        /// <summary>
        /// The repository the workflow will use. This maybe empty before v3.1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("artifactRepository", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ArtifactRepository ArtifactRepository { get; set; }

        /// <summary>
        /// The name of the config map. Defaults to "artifact-repositories".
        /// </summary>
        [Newtonsoft.Json.JsonProperty("configMap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConfigMap { get; set; }

        /// <summary>
        /// If this ref represents the default artifact repository, rather than a config map.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("default", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Default { get; set; }

        /// <summary>
        /// The config map key. Defaults to the value of the "workflows.argoproj.io/default-artifact-repository" annotation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }

        /// <summary>
        /// The namespace of the config map. Defaults to the workflow's namespace, or the controller's namespace (if found).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

    }

    /// <summary>
    /// ArtifactoryArtifact is the location of an artifactory artifact
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ArtifactoryArtifact
    {
        /// <summary>
        /// PasswordSecret is the secret selector to the repository password
        /// </summary>
        [Newtonsoft.Json.JsonProperty("passwordSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector PasswordSecret { get; set; }

        /// <summary>
        /// URL of the artifact
        /// </summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Url { get; set; }

        /// <summary>
        /// UsernameSecret is the secret selector to the repository username
        /// </summary>
        [Newtonsoft.Json.JsonProperty("usernameSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector UsernameSecret { get; set; }

    }

    /// <summary>
    /// ArtifactoryArtifactRepository defines the controller configuration for an artifactory artifact repository
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ArtifactoryArtifactRepository
    {
        /// <summary>
        /// PasswordSecret is the secret selector to the repository password
        /// </summary>
        [Newtonsoft.Json.JsonProperty("passwordSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector PasswordSecret { get; set; }

        /// <summary>
        /// RepoURL is the url for artifactory repo.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("repoURL", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RepoURL { get; set; }

        /// <summary>
        /// UsernameSecret is the secret selector to the repository username
        /// </summary>
        [Newtonsoft.Json.JsonProperty("usernameSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector UsernameSecret { get; set; }

    }

    /// <summary>
    /// Backoff is a backoff strategy to use within retryStrategy
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Backoff3
    {
        /// <summary>
        /// Duration is the amount to back off. Default unit is seconds, but could also be a duration (e.g. "2m", "1h")
        /// </summary>
        [Newtonsoft.Json.JsonProperty("duration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Duration { get; set; }

        /// <summary>
        /// Factor is a factor to multiply the base duration after each failed retry
        /// </summary>
        [Newtonsoft.Json.JsonProperty("factor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Factor { get; set; }

        /// <summary>
        /// MaxDuration is the maximum amount of time allowed for the backoff strategy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maxDuration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MaxDuration { get; set; }

    }

    /// <summary>
    /// Cache is the configuration for the type of cache to be used
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Cache
    {
        /// <summary>
        /// ConfigMap sets a ConfigMap-based cache
        /// </summary>
        [Newtonsoft.Json.JsonProperty("configMap", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ConfigMapKeySelector ConfigMap { get; set; } = new ConfigMapKeySelector();

    }

    /// <summary>
    /// ClusterWorkflowTemplate is the definition of a workflow template resource in cluster scope
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ClusterWorkflowTemplate
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apiVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kind { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ObjectMeta Metadata { get; set; } = new ObjectMeta();

        [Newtonsoft.Json.JsonProperty("spec", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public WorkflowSpec Spec { get; set; } = new WorkflowSpec();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ClusterWorkflowTemplateCreateRequest
    {
        [Newtonsoft.Json.JsonProperty("createOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CreateOptions CreateOptions { get; set; }

        [Newtonsoft.Json.JsonProperty("template", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ClusterWorkflowTemplate Template { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ClusterWorkflowTemplateDeleteResponse
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ClusterWorkflowTemplateLintRequest
    {
        [Newtonsoft.Json.JsonProperty("createOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CreateOptions CreateOptions { get; set; }

        [Newtonsoft.Json.JsonProperty("template", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ClusterWorkflowTemplate Template { get; set; }

    }

    /// <summary>
    /// ClusterWorkflowTemplateList is list of ClusterWorkflowTemplate resources
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ClusterWorkflowTemplateList
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apiVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ApiVersion { get; set; }

        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ClusterWorkflowTemplate> Items { get; set; } = new System.Collections.ObjectModel.Collection<ClusterWorkflowTemplate>();

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kind { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ListMeta Metadata { get; set; } = new ListMeta();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ClusterWorkflowTemplateUpdateRequest
    {
        /// <summary>
        /// DEPRECATED: This field is ignored.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("template", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ClusterWorkflowTemplate Template { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Condition2
    {
        /// <summary>
        /// Message is the condition message
        /// </summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        /// <summary>
        /// Status is the status of the condition
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Status { get; set; }

        /// <summary>
        /// Type is the type of condition
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ContainerNode
    {
        /// <summary>
        /// Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// </summary>
        [Newtonsoft.Json.JsonProperty("args", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Args { get; set; }

        /// <summary>
        /// Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// </summary>
        [Newtonsoft.Json.JsonProperty("command", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Command { get; set; }

        [Newtonsoft.Json.JsonProperty("dependencies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Dependencies { get; set; }

        /// <summary>
        /// List of environment variables to set in the container. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("env", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<EnvVar> Env { get; set; }

        /// <summary>
        /// List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("envFrom", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<EnvFromSource> EnvFrom { get; set; }

        /// <summary>
        /// Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("image", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Image { get; set; }

        /// <summary>
        /// Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
        /// </summary>
        [Newtonsoft.Json.JsonProperty("imagePullPolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ImagePullPolicy { get; set; }

        /// <summary>
        /// Actions that the management system should take in response to container lifecycle events. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lifecycle", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Lifecycle Lifecycle { get; set; }

        /// <summary>
        /// Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
        [Newtonsoft.Json.JsonProperty("livenessProbe", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Probe LivenessProbe { get; set; }

        /// <summary>
        /// Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ContainerPort> Ports { get; set; }

        /// <summary>
        /// Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readinessProbe", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Probe ReadinessProbe { get; set; }

        /// <summary>
        /// Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceRequirements Resources { get; set; }

        /// <summary>
        /// SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        /// </summary>
        [Newtonsoft.Json.JsonProperty("securityContext", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecurityContext SecurityContext { get; set; }

        /// <summary>
        /// StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startupProbe", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Probe StartupProbe { get; set; }

        /// <summary>
        /// Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stdin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Stdin { get; set; }

        /// <summary>
        /// Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stdinOnce", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? StdinOnce { get; set; }

        /// <summary>
        /// Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("terminationMessagePath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TerminationMessagePath { get; set; }

        /// <summary>
        /// Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("terminationMessagePolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TerminationMessagePolicy { get; set; }

        /// <summary>
        /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tty", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Tty { get; set; }

        /// <summary>
        /// volumeDevices is the list of block devices to be used by the container.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeDevices", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<VolumeDevice> VolumeDevices { get; set; }

        /// <summary>
        /// Pod volumes to mount into the container's filesystem. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeMounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<VolumeMount> VolumeMounts { get; set; }

        /// <summary>
        /// Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("workingDir", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WorkingDir { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ContainerSetRetryStrategy
    {
        /// <summary>
        /// Duration is the time between each retry, examples values are "300ms", "1s" or "5m". Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h".
        /// </summary>
        [Newtonsoft.Json.JsonProperty("duration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Duration { get; set; }

        /// <summary>
        /// Nbr of retries
        /// </summary>
        [Newtonsoft.Json.JsonProperty("retries", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Retries { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ContainerSetTemplate
    {
        [Newtonsoft.Json.JsonProperty("containers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ContainerNode> Containers { get; set; } = new System.Collections.ObjectModel.Collection<ContainerNode>();

        /// <summary>
        /// RetryStrategy describes how to retry a container nodes in the container set if it fails. Nbr of retries(default 0) and sleep duration between retries(default 0s, instant retry) can be set.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("retryStrategy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ContainerSetRetryStrategy RetryStrategy { get; set; }

        [Newtonsoft.Json.JsonProperty("volumeMounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<VolumeMount> VolumeMounts { get; set; }

    }

    /// <summary>
    /// ContinueOn defines if a workflow should continue even if a task or step fails/errors. It can be specified if the workflow should continue when the pod errors, fails or both.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ContinueOn
    {
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Error { get; set; }

        [Newtonsoft.Json.JsonProperty("failed", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Failed { get; set; }

    }

    /// <summary>
    /// Counter is a Counter prometheus metric
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Counter
    {
        /// <summary>
        /// Value is the value of the metric
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CreateCronWorkflowRequest
    {
        [Newtonsoft.Json.JsonProperty("createOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CreateOptions CreateOptions { get; set; }

        [Newtonsoft.Json.JsonProperty("cronWorkflow", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CronWorkflow CronWorkflow { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

    }

    /// <summary>
    /// CreateS3BucketOptions options used to determine automatic automatic bucket-creation process
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CreateS3BucketOptions
    {
        /// <summary>
        /// ObjectLocking Enable object locking
        /// </summary>
        [Newtonsoft.Json.JsonProperty("objectLocking", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ObjectLocking { get; set; }

    }

    /// <summary>
    /// CronWorkflow is the definition of a scheduled workflow resource
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CronWorkflow
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apiVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kind { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ObjectMeta Metadata { get; set; } = new ObjectMeta();

        [Newtonsoft.Json.JsonProperty("spec", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public CronWorkflowSpec Spec { get; set; } = new CronWorkflowSpec();

        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CronWorkflowStatus Status { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CronWorkflowDeletedResponse
    {

    }

    /// <summary>
    /// CronWorkflowList is list of CronWorkflow resources
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CronWorkflowList
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apiVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ApiVersion { get; set; }

        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<CronWorkflow> Items { get; set; } = new System.Collections.ObjectModel.Collection<CronWorkflow>();

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kind { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ListMeta Metadata { get; set; } = new ListMeta();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CronWorkflowResumeRequest
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

    }

    /// <summary>
    /// CronWorkflowSpec is the specification of a CronWorkflow
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CronWorkflowSpec
    {
        /// <summary>
        /// ConcurrencyPolicy is the K8s-style concurrency policy that will be used
        /// </summary>
        [Newtonsoft.Json.JsonProperty("concurrencyPolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ConcurrencyPolicy { get; set; }

        /// <summary>
        /// FailedJobsHistoryLimit is the number of failed jobs to be kept at a time
        /// </summary>
        [Newtonsoft.Json.JsonProperty("failedJobsHistoryLimit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? FailedJobsHistoryLimit { get; set; }

        /// <summary>
        /// Schedule is a schedule to run the Workflow in Cron format
        /// </summary>
        [Newtonsoft.Json.JsonProperty("schedule", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Schedule { get; set; }

        /// <summary>
        /// StartingDeadlineSeconds is the K8s-style deadline that will limit the time a CronWorkflow will be run after its original scheduled time if it is missed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startingDeadlineSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? StartingDeadlineSeconds { get; set; }

        /// <summary>
        /// SuccessfulJobsHistoryLimit is the number of successful jobs to be kept at a time
        /// </summary>
        [Newtonsoft.Json.JsonProperty("successfulJobsHistoryLimit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SuccessfulJobsHistoryLimit { get; set; }

        /// <summary>
        /// Suspend is a flag that will stop new CronWorkflows from running if set to true
        /// </summary>
        [Newtonsoft.Json.JsonProperty("suspend", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Suspend { get; set; }

        /// <summary>
        /// Timezone is the timezone against which the cron schedule will be calculated, e.g. "Asia/Tokyo". Default is machine's local time.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timezone", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Timezone { get; set; }

        /// <summary>
        /// WorkflowMetadata contains some metadata of the workflow to be run
        /// </summary>
        [Newtonsoft.Json.JsonProperty("workflowMetadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ObjectMeta WorkflowMetadata { get; set; }

        /// <summary>
        /// WorkflowSpec is the spec of the workflow to be run
        /// </summary>
        [Newtonsoft.Json.JsonProperty("workflowSpec", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public WorkflowSpec WorkflowSpec { get; set; } = new WorkflowSpec();

    }

    /// <summary>
    /// CronWorkflowStatus is the status of a CronWorkflow
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CronWorkflowStatus
    {
        /// <summary>
        /// Active is a list of active workflows stemming from this CronWorkflow
        /// </summary>
        [Newtonsoft.Json.JsonProperty("active", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ObjectReference> Active { get; set; } = new System.Collections.ObjectModel.Collection<ObjectReference>();

        /// <summary>
        /// Conditions is a list of conditions the CronWorkflow may have
        /// </summary>
        [Newtonsoft.Json.JsonProperty("conditions", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Condition2> Conditions { get; set; } = new System.Collections.ObjectModel.Collection<Condition2>();

        /// <summary>
        /// LastScheduleTime is the last time the CronWorkflow was scheduled
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lastScheduledTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset LastScheduledTime { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CronWorkflowSuspendRequest
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

    }

    /// <summary>
    /// DAGTask represents a node in the graph during DAG execution
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DAGTask
    {
        /// <summary>
        /// Arguments are the parameter and artifact arguments to the template
        /// </summary>
        [Newtonsoft.Json.JsonProperty("arguments", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Arguments Arguments { get; set; }

        /// <summary>
        /// ContinueOn makes argo to proceed with the following step even if this step fails. Errors and Failed states can be specified
        /// </summary>
        [Newtonsoft.Json.JsonProperty("continueOn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ContinueOn ContinueOn { get; set; }

        /// <summary>
        /// Dependencies are name of other targets which this depends on
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dependencies", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Dependencies { get; set; }

        /// <summary>
        /// Depends are name of other targets which this depends on
        /// </summary>
        [Newtonsoft.Json.JsonProperty("depends", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Depends { get; set; }

        /// <summary>
        /// Hooks hold the lifecycle hook which is invoked at lifecycle of task, irrespective of the success, failure, or error status of the primary task
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hooks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, LifecycleHook> Hooks { get; set; }

        /// <summary>
        /// Inline is the template. Template must be empty if this is declared (and vice-versa).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inline", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Template2 Inline { get; set; }

        /// <summary>
        /// Name is the name of the target
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// OnExit is a template reference which is invoked at the end of the template, irrespective of the success, failure, or error of the primary template. DEPRECATED: Use Hooks[exit].Template instead.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("onExit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OnExit { get; set; }

        /// <summary>
        /// Name of template to execute
        /// </summary>
        [Newtonsoft.Json.JsonProperty("template", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Template { get; set; }

        /// <summary>
        /// TemplateRef is the reference to the template resource to execute.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("templateRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TemplateRef TemplateRef { get; set; }

        /// <summary>
        /// When is an expression in which the task should conditionally execute
        /// </summary>
        [Newtonsoft.Json.JsonProperty("when", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string When { get; set; }

        /// <summary>
        /// WithItems expands a task into multiple parallel tasks from the items in the list
        /// </summary>
        [Newtonsoft.Json.JsonProperty("withItems", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Item> WithItems { get; set; }

        /// <summary>
        /// WithParam expands a task into multiple parallel tasks from the value in the parameter, which is expected to be a JSON list.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("withParam", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WithParam { get; set; }

        /// <summary>
        /// WithSequence expands a task into a numeric sequence
        /// </summary>
        [Newtonsoft.Json.JsonProperty("withSequence", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Sequence WithSequence { get; set; }

    }

    /// <summary>
    /// DAGTemplate is a template subtype for directed acyclic graph templates
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DAGTemplate
    {
        /// <summary>
        /// This flag is for DAG logic. The DAG logic has a built-in "fail fast" feature to stop scheduling new steps, as soon as it detects that one of the DAG nodes is failed. Then it waits until all DAG nodes are completed before failing the DAG itself. The FailFast flag default is true,  if set to false, it will allow a DAG to run all branches of the DAG to completion (either success or failure), regardless of the failed outcomes of branches in the DAG. More info and example about this feature at https://github.com/argoproj/argo-workflows/issues/1442
        /// </summary>
        [Newtonsoft.Json.JsonProperty("failFast", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? FailFast { get; set; }

        /// <summary>
        /// Target are one or more names of targets to execute in a DAG
        /// </summary>
        [Newtonsoft.Json.JsonProperty("target", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Target { get; set; }

        /// <summary>
        /// Tasks are a list of DAG tasks
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tasks", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<DAGTask> Tasks { get; set; } = new System.Collections.ObjectModel.Collection<DAGTask>();

    }

    /// <summary>
    /// Data is a data template
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Data
    {
        /// <summary>
        /// Source sources external data into a data template
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public DataSource Source { get; set; } = new DataSource();

        /// <summary>
        /// Transformation applies a set of transformations
        /// </summary>
        [Newtonsoft.Json.JsonProperty("transformation", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<TransformationStep> Transformation { get; set; } = new System.Collections.ObjectModel.Collection<TransformationStep>();

    }

    /// <summary>
    /// DataSource sources external data into a data template
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DataSource
    {
        /// <summary>
        /// ArtifactPaths is a data transformation that collects a list of artifact paths
        /// </summary>
        [Newtonsoft.Json.JsonProperty("artifactPaths", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ArtifactPaths ArtifactPaths { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Event
    {
        /// <summary>
        /// Selector (https://github.com/antonmedv/expr) that we must must match the io.argoproj.workflow.v1alpha1. E.g. `payload.message == "test"`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selector", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Selector { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EventResponse
    {

    }

    /// <summary>
    /// ExecutorConfig holds configurations of an executor container.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ExecutorConfig
    {
        /// <summary>
        /// ServiceAccountName specifies the service account name of the executor container.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("serviceAccountName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ServiceAccountName { get; set; }

    }

    /// <summary>
    /// GCSArtifact is the location of a GCS artifact
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GCSArtifact
    {
        /// <summary>
        /// Bucket is the name of the bucket
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bucket", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Bucket { get; set; }

        /// <summary>
        /// Key is the path in the bucket where the artifact resides
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Key { get; set; }

        /// <summary>
        /// ServiceAccountKeySecret is the secret selector to the bucket's service account key
        /// </summary>
        [Newtonsoft.Json.JsonProperty("serviceAccountKeySecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector ServiceAccountKeySecret { get; set; }

    }

    /// <summary>
    /// GCSArtifactRepository defines the controller configuration for a GCS artifact repository
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GCSArtifactRepository
    {
        /// <summary>
        /// Bucket is the name of the bucket
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bucket", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Bucket { get; set; }

        /// <summary>
        /// KeyFormat is defines the format of how to store keys. Can reference workflow variables
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keyFormat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KeyFormat { get; set; }

        /// <summary>
        /// ServiceAccountKeySecret is the secret selector to the bucket's service account key
        /// </summary>
        [Newtonsoft.Json.JsonProperty("serviceAccountKeySecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector ServiceAccountKeySecret { get; set; }

    }

    /// <summary>
    /// Gauge is a Gauge prometheus metric
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Gauge
    {
        /// <summary>
        /// Realtime emits this metric in real time if applicable
        /// </summary>
        [Newtonsoft.Json.JsonProperty("realtime", Required = Newtonsoft.Json.Required.Always)]
        public bool Realtime { get; set; }

        /// <summary>
        /// Value is the value of the metric
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GetUserInfoResponse
    {
        [Newtonsoft.Json.JsonProperty("email", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Email { get; set; }

        [Newtonsoft.Json.JsonProperty("emailVerified", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? EmailVerified { get; set; }

        [Newtonsoft.Json.JsonProperty("groups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Groups { get; set; }

        [Newtonsoft.Json.JsonProperty("issuer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Issuer { get; set; }

        [Newtonsoft.Json.JsonProperty("serviceAccountName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ServiceAccountName { get; set; }

        [Newtonsoft.Json.JsonProperty("subject", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Subject { get; set; }

    }

    /// <summary>
    /// GitArtifact is the location of an git artifact
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GitArtifact2
    {
        /// <summary>
        /// Depth specifies clones/fetches should be shallow and include the given number of commits from the branch tip
        /// </summary>
        [Newtonsoft.Json.JsonProperty("depth", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Depth { get; set; }

        /// <summary>
        /// DisableSubmodules disables submodules during git clone
        /// </summary>
        [Newtonsoft.Json.JsonProperty("disableSubmodules", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DisableSubmodules { get; set; }

        /// <summary>
        /// Fetch specifies a number of refs that should be fetched before checkout
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fetch", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Fetch { get; set; }

        /// <summary>
        /// InsecureIgnoreHostKey disables SSH strict host key checking during git clone
        /// </summary>
        [Newtonsoft.Json.JsonProperty("insecureIgnoreHostKey", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? InsecureIgnoreHostKey { get; set; }

        /// <summary>
        /// PasswordSecret is the secret selector to the repository password
        /// </summary>
        [Newtonsoft.Json.JsonProperty("passwordSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector PasswordSecret { get; set; }

        /// <summary>
        /// Repo is the git repository
        /// </summary>
        [Newtonsoft.Json.JsonProperty("repo", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Repo { get; set; }

        /// <summary>
        /// Revision is the git commit, tag, branch to checkout
        /// </summary>
        [Newtonsoft.Json.JsonProperty("revision", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Revision { get; set; }

        /// <summary>
        /// SSHPrivateKeySecret is the secret selector to the repository ssh private key
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sshPrivateKeySecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector SshPrivateKeySecret { get; set; }

        /// <summary>
        /// UsernameSecret is the secret selector to the repository username
        /// </summary>
        [Newtonsoft.Json.JsonProperty("usernameSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector UsernameSecret { get; set; }

    }

    /// <summary>
    /// HDFSArtifact is the location of an HDFS artifact
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HDFSArtifact
    {
        /// <summary>
        /// Addresses is accessible addresses of HDFS name nodes
        /// </summary>
        [Newtonsoft.Json.JsonProperty("addresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Addresses { get; set; }

        /// <summary>
        /// Force copies a file forcibly even if it exists
        /// </summary>
        [Newtonsoft.Json.JsonProperty("force", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Force { get; set; }

        /// <summary>
        /// HDFSUser is the user to access HDFS file system. It is ignored if either ccache or keytab is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hdfsUser", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HdfsUser { get; set; }

        /// <summary>
        /// KrbCCacheSecret is the secret selector for Kerberos ccache Either ccache or keytab can be set to use Kerberos.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("krbCCacheSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector KrbCCacheSecret { get; set; }

        /// <summary>
        /// KrbConfig is the configmap selector for Kerberos config as string It must be set if either ccache or keytab is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("krbConfigConfigMap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConfigMapKeySelector KrbConfigConfigMap { get; set; }

        /// <summary>
        /// KrbKeytabSecret is the secret selector for Kerberos keytab Either ccache or keytab can be set to use Kerberos.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("krbKeytabSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector KrbKeytabSecret { get; set; }

        /// <summary>
        /// KrbRealm is the Kerberos realm used with Kerberos keytab It must be set if keytab is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("krbRealm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KrbRealm { get; set; }

        /// <summary>
        /// KrbServicePrincipalName is the principal name of Kerberos service It must be set if either ccache or keytab is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("krbServicePrincipalName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KrbServicePrincipalName { get; set; }

        /// <summary>
        /// KrbUsername is the Kerberos username used with Kerberos keytab It must be set if keytab is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("krbUsername", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KrbUsername { get; set; }

        /// <summary>
        /// Path is a file path in HDFS
        /// </summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Path { get; set; }

    }

    /// <summary>
    /// HDFSArtifactRepository defines the controller configuration for an HDFS artifact repository
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HDFSArtifactRepository
    {
        /// <summary>
        /// Addresses is accessible addresses of HDFS name nodes
        /// </summary>
        [Newtonsoft.Json.JsonProperty("addresses", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Addresses { get; set; }

        /// <summary>
        /// Force copies a file forcibly even if it exists
        /// </summary>
        [Newtonsoft.Json.JsonProperty("force", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Force { get; set; }

        /// <summary>
        /// HDFSUser is the user to access HDFS file system. It is ignored if either ccache or keytab is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hdfsUser", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HdfsUser { get; set; }

        /// <summary>
        /// KrbCCacheSecret is the secret selector for Kerberos ccache Either ccache or keytab can be set to use Kerberos.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("krbCCacheSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector KrbCCacheSecret { get; set; }

        /// <summary>
        /// KrbConfig is the configmap selector for Kerberos config as string It must be set if either ccache or keytab is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("krbConfigConfigMap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConfigMapKeySelector KrbConfigConfigMap { get; set; }

        /// <summary>
        /// KrbKeytabSecret is the secret selector for Kerberos keytab Either ccache or keytab can be set to use Kerberos.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("krbKeytabSecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector KrbKeytabSecret { get; set; }

        /// <summary>
        /// KrbRealm is the Kerberos realm used with Kerberos keytab It must be set if keytab is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("krbRealm", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KrbRealm { get; set; }

        /// <summary>
        /// KrbServicePrincipalName is the principal name of Kerberos service It must be set if either ccache or keytab is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("krbServicePrincipalName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KrbServicePrincipalName { get; set; }

        /// <summary>
        /// KrbUsername is the Kerberos username used with Kerberos keytab It must be set if keytab is used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("krbUsername", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KrbUsername { get; set; }

        /// <summary>
        /// PathFormat is defines the format of path to store a file. Can reference workflow variables
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pathFormat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PathFormat { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HTTP2
    {
        /// <summary>
        /// Body is content of the HTTP Request
        /// </summary>
        [Newtonsoft.Json.JsonProperty("body", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Body { get; set; }

        /// <summary>
        /// Headers are an optional list of headers to send with HTTP requests
        /// </summary>
        [Newtonsoft.Json.JsonProperty("headers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<HTTPHeader2> Headers { get; set; }

        /// <summary>
        /// insecureSkipVerify is a bool when if set to true will skip TLS verification for the HTTP client
        /// </summary>
        [Newtonsoft.Json.JsonProperty("insecureSkipVerify", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? InsecureSkipVerify { get; set; }

        /// <summary>
        /// Method is HTTP methods for HTTP Request
        /// </summary>
        [Newtonsoft.Json.JsonProperty("method", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Method { get; set; }

        /// <summary>
        /// SuccessCondition is an expression if evaluated to true is considered successful
        /// </summary>
        [Newtonsoft.Json.JsonProperty("successCondition", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SuccessCondition { get; set; }

        /// <summary>
        /// TimeoutSeconds is request timeout for HTTP Request. Default is 30 seconds
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timeoutSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? TimeoutSeconds { get; set; }

        /// <summary>
        /// URL of the HTTP Request
        /// </summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Url { get; set; }

    }

    /// <summary>
    /// HTTPArtifact allows an file served on HTTP to be placed as an input artifact in a container
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HTTPArtifact
    {
        /// <summary>
        /// Headers are an optional list of headers to send with HTTP requests for artifacts
        /// </summary>
        [Newtonsoft.Json.JsonProperty("headers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Header> Headers { get; set; }

        /// <summary>
        /// URL of the artifact
        /// </summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Url { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HTTPHeader2
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

        [Newtonsoft.Json.JsonProperty("valueFrom", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HTTPHeaderSource2 ValueFrom { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HTTPHeaderSource2
    {
        [Newtonsoft.Json.JsonProperty("secretKeyRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector SecretKeyRef { get; set; }

    }

    /// <summary>
    /// Header indicate a key-value request header to be used when fetching artifacts over HTTP
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Header
    {
        /// <summary>
        /// Name is the header name
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Value is the literal value to use for the header
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    /// <summary>
    /// Histogram is a Histogram prometheus metric
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Histogram
    {
        /// <summary>
        /// Buckets is a list of bucket divisors for the histogram
        /// </summary>
        [Newtonsoft.Json.JsonProperty("buckets", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<double> Buckets { get; set; } = new System.Collections.ObjectModel.Collection<double>();

        /// <summary>
        /// Value is the value of the metric
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class InfoResponse
    {
        [Newtonsoft.Json.JsonProperty("links", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Link> Links { get; set; }

        [Newtonsoft.Json.JsonProperty("managedNamespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ManagedNamespace { get; set; }

        [Newtonsoft.Json.JsonProperty("modals", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, bool> Modals { get; set; }

        [Newtonsoft.Json.JsonProperty("navColor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NavColor { get; set; }

    }

    /// <summary>
    /// Inputs are the mechanism for passing parameters, artifacts, volumes from one template to another
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Inputs
    {
        /// <summary>
        /// Artifact are a list of artifacts passed as inputs
        /// </summary>
        [Newtonsoft.Json.JsonProperty("artifacts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Artifact> Artifacts { get; set; }

        /// <summary>
        /// Parameters are a list of parameters passed as inputs
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Parameter> Parameters { get; set; }

    }

    /// <summary>
    /// Item expands a single workflow step into multiple parallel steps The value of Item can be a map, string, bool, or number
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Item
    {

    }

    /// <summary>
    /// LabelKeys is list of keys
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LabelKeys
    {
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Items { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LabelValueFrom
    {
        [Newtonsoft.Json.JsonProperty("expression", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Expression { get; set; }

    }

    /// <summary>
    /// Labels is list of workflow labels
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LabelValues
    {
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Items { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LifecycleHook
    {
        /// <summary>
        /// Arguments hold arguments to the template
        /// </summary>
        [Newtonsoft.Json.JsonProperty("arguments", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Arguments Arguments { get; set; }

        /// <summary>
        /// Expression is a condition expression for when a node will be retried. If it evaluates to false, the node will not be retried and the retry strategy will be ignored
        /// </summary>
        [Newtonsoft.Json.JsonProperty("expression", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Expression { get; set; }

        /// <summary>
        /// Template is the name of the template to execute by the hook
        /// </summary>
        [Newtonsoft.Json.JsonProperty("template", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Template { get; set; }

        /// <summary>
        /// TemplateRef is the reference to the template resource to execute by the hook
        /// </summary>
        [Newtonsoft.Json.JsonProperty("templateRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TemplateRef TemplateRef { get; set; }

    }

    /// <summary>
    /// A link to another app.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Link
    {
        /// <summary>
        /// The name of the link, E.g. "Workflow Logs" or "Pod Logs"
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// "workflow", "pod", "pod-logs", "event-source-logs", "sensor-logs" or "chat"
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scope", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Scope { get; set; }

        /// <summary>
        /// The URL. Can contain "${metadata.namespace}", "${metadata.name}", "${status.startedAt}", "${status.finishedAt}" or any other element in workflow yaml, e.g. "${io.argoproj.workflow.v1alpha1.metadata.annotations.userDefinedKey}"
        /// </summary>
        [Newtonsoft.Json.JsonProperty("url", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Url { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LintCronWorkflowRequest
    {
        [Newtonsoft.Json.JsonProperty("cronWorkflow", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CronWorkflow CronWorkflow { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LogEntry2
    {
        [Newtonsoft.Json.JsonProperty("content", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Content { get; set; }

        [Newtonsoft.Json.JsonProperty("podName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PodName { get; set; }

    }

    /// <summary>
    /// MemoizationStatus is the status of this memoized node
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class MemoizationStatus
    {
        /// <summary>
        /// Cache is the name of the cache that was used
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cacheName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string CacheName { get; set; }

        /// <summary>
        /// Hit indicates whether this node was created from a cache entry
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hit", Required = Newtonsoft.Json.Required.Always)]
        public bool Hit { get; set; }

        /// <summary>
        /// Key is the name of the key used for this node's cache
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Key { get; set; }

    }

    /// <summary>
    /// Memoization enables caching for the Outputs of the template
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Memoize
    {
        /// <summary>
        /// Cache sets and configures the kind of cache
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cache", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Cache Cache { get; set; } = new Cache();

        /// <summary>
        /// Key is the key to use as the caching key
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Key { get; set; }

        /// <summary>
        /// MaxAge is the maximum age (e.g. "180s", "24h") of an entry that is still considered valid. If an entry is older than the MaxAge, it will be ignored.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maxAge", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string MaxAge { get; set; }

    }

    /// <summary>
    /// Pod metdata
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Metadata3
    {
        [Newtonsoft.Json.JsonProperty("annotations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Annotations { get; set; }

        [Newtonsoft.Json.JsonProperty("labels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; set; }

    }

    /// <summary>
    /// MetricLabel is a single label for a prometheus metric
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class MetricLabel
    {
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Key { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    /// <summary>
    /// Metrics are a list of metrics emitted from a Workflow/Template
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Metrics
    {
        /// <summary>
        /// Prometheus is a list of prometheus metrics to be emitted
        /// </summary>
        [Newtonsoft.Json.JsonProperty("prometheus", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Prometheus> Prometheus { get; set; } = new System.Collections.ObjectModel.Collection<Prometheus>();

    }

    /// <summary>
    /// Mutex holds Mutex configuration
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Mutex
    {
        /// <summary>
        /// name of the mutex
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

    }

    /// <summary>
    /// MutexHolding describes the mutex and the object which is holding it.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class MutexHolding
    {
        /// <summary>
        /// Holder is a reference to the object which holds the Mutex. Holding Scenario:
        /// <br/>  1. Current workflow's NodeID which is holding the lock.
        /// <br/>     e.g: ${NodeID}
        /// <br/>Waiting Scenario:
        /// <br/>  1. Current workflow or other workflow NodeID which is holding the lock.
        /// <br/>     e.g: ${WorkflowName}/${NodeID}
        /// </summary>
        [Newtonsoft.Json.JsonProperty("holder", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Holder { get; set; }

        /// <summary>
        /// Reference for the mutex e.g: ${namespace}/mutex/${mutexName}
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mutex", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Mutex { get; set; }

    }

    /// <summary>
    /// MutexStatus contains which objects hold  mutex locks, and which objects this workflow is waiting on to release locks.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class MutexStatus
    {
        /// <summary>
        /// Holding is a list of mutexes and their respective objects that are held by mutex lock for this io.argoproj.workflow.v1alpha1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("holding", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MutexHolding> Holding { get; set; }

        /// <summary>
        /// Waiting is a list of mutexes and their respective objects this workflow is waiting for.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("waiting", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MutexHolding> Waiting { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NodeResult
    {
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        [Newtonsoft.Json.JsonProperty("outputs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Outputs Outputs { get; set; }

        [Newtonsoft.Json.JsonProperty("phase", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Phase { get; set; }

        [Newtonsoft.Json.JsonProperty("progress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Progress { get; set; }

    }

    /// <summary>
    /// NodeStatus contains status information about an individual node in the workflow
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NodeStatus
    {
        /// <summary>
        /// BoundaryID indicates the node ID of the associated template root node in which this node belongs to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("boundaryID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string BoundaryID { get; set; }

        /// <summary>
        /// Children is a list of child node IDs
        /// </summary>
        [Newtonsoft.Json.JsonProperty("children", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Children { get; set; }

        /// <summary>
        /// Daemoned tracks whether or not this node was daemoned and need to be terminated
        /// </summary>
        [Newtonsoft.Json.JsonProperty("daemoned", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Daemoned { get; set; }

        /// <summary>
        /// DisplayName is a human readable representation of the node. Unique within a template boundary
        /// </summary>
        [Newtonsoft.Json.JsonProperty("displayName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DisplayName { get; set; }

        /// <summary>
        /// EstimatedDuration in seconds.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("estimatedDuration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? EstimatedDuration { get; set; }

        /// <summary>
        /// Time at which this node completed
        /// </summary>
        [Newtonsoft.Json.JsonProperty("finishedAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? FinishedAt { get; set; }

        /// <summary>
        /// HostNodeName name of the Kubernetes node on which the Pod is running, if applicable
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hostNodeName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HostNodeName { get; set; }

        /// <summary>
        /// ID is a unique identifier of a node within the worklow It is implemented as a hash of the node name, which makes the ID deterministic
        /// </summary>
        [Newtonsoft.Json.JsonProperty("id", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Id { get; set; }

        /// <summary>
        /// Inputs captures input parameter values and artifact locations supplied to this template invocation
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inputs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Inputs Inputs { get; set; }

        /// <summary>
        /// MemoizationStatus holds information about cached nodes
        /// </summary>
        [Newtonsoft.Json.JsonProperty("memoizationStatus", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public MemoizationStatus MemoizationStatus { get; set; }

        /// <summary>
        /// A human readable message indicating details about why the node is in this condition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        /// <summary>
        /// Name is unique name in the node tree used to generate the node ID
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// OutboundNodes tracks the node IDs which are considered "outbound" nodes to a template invocation. For every invocation of a template, there are nodes which we considered as "outbound". Essentially, these are last nodes in the execution sequence to run, before the template is considered completed. These nodes are then connected as parents to a following step.
        /// <br/>
        /// <br/>In the case of single pod steps (i.e. container, script, resource templates), this list will be nil since the pod itself is already considered the "outbound" node. In the case of DAGs, outbound nodes are the "target" tasks (tasks with no children). In the case of steps, outbound nodes are all the containers involved in the last step group. NOTE: since templates are composable, the list of outbound nodes are carried upwards when a DAG/steps template invokes another DAG/steps template. In other words, the outbound nodes of a template, will be a superset of the outbound nodes of its last children.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("outboundNodes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> OutboundNodes { get; set; }

        /// <summary>
        /// Outputs captures output parameter values and artifact locations produced by this template invocation
        /// </summary>
        [Newtonsoft.Json.JsonProperty("outputs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Outputs Outputs { get; set; }

        /// <summary>
        /// Phase a simple, high-level summary of where the node is in its lifecycle. Can be used as a state machine.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("phase", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Phase { get; set; }

        /// <summary>
        /// PodIP captures the IP of the pod for daemoned steps
        /// </summary>
        [Newtonsoft.Json.JsonProperty("podIP", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PodIP { get; set; }

        /// <summary>
        /// Progress to completion
        /// </summary>
        [Newtonsoft.Json.JsonProperty("progress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Progress { get; set; }

        /// <summary>
        /// ResourcesDuration is indicative, but not accurate, resource duration. This is populated when the nodes completes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourcesDuration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, long> ResourcesDuration { get; set; }

        /// <summary>
        /// Time at which this node started
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startedAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? StartedAt { get; set; }

        /// <summary>
        /// SynchronizationStatus is the synchronization status of the node
        /// </summary>
        [Newtonsoft.Json.JsonProperty("synchronizationStatus", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public NodeSynchronizationStatus SynchronizationStatus { get; set; }

        /// <summary>
        /// TemplateName is the template name which this node corresponds to. Not applicable to virtual nodes (e.g. Retry, StepGroup)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("templateName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TemplateName { get; set; }

        /// <summary>
        /// TemplateRef is the reference to the template resource which this node corresponds to. Not applicable to virtual nodes (e.g. Retry, StepGroup)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("templateRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TemplateRef TemplateRef { get; set; }

        /// <summary>
        /// TemplateScope is the template scope in which the template of this node was retrieved.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("templateScope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TemplateScope { get; set; }

        /// <summary>
        /// Type indicates type of node
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }

    }

    /// <summary>
    /// NodeSynchronizationStatus stores the status of a node
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NodeSynchronizationStatus
    {
        /// <summary>
        /// Waiting is the name of the lock that this node is waiting for
        /// </summary>
        [Newtonsoft.Json.JsonProperty("waiting", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Waiting { get; set; }

    }

    /// <summary>
    /// NoneStrategy indicates to skip tar process and upload the files or directory tree as independent files. Note that if the artifact is a directory, the artifact driver must support the ability to save/load the directory appropriately.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NoneStrategy
    {

    }

    /// <summary>
    /// OSSArtifact is the location of an Alibaba Cloud OSS artifact
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OSSArtifact
    {
        /// <summary>
        /// AccessKeySecret is the secret selector to the bucket's access key
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accessKeySecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector AccessKeySecret { get; set; }

        /// <summary>
        /// Bucket is the name of the bucket
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bucket", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Bucket { get; set; }

        /// <summary>
        /// CreateBucketIfNotPresent tells the driver to attempt to create the OSS bucket for output artifacts, if it doesn't exist
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createBucketIfNotPresent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CreateBucketIfNotPresent { get; set; }

        /// <summary>
        /// Endpoint is the hostname of the bucket endpoint
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Endpoint { get; set; }

        /// <summary>
        /// Key is the path in the bucket where the artifact resides
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Key { get; set; }

        /// <summary>
        /// LifecycleRule specifies how to manage bucket's lifecycle
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lifecycleRule", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OSSLifecycleRule LifecycleRule { get; set; }

        /// <summary>
        /// SecretKeySecret is the secret selector to the bucket's secret key
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secretKeySecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector SecretKeySecret { get; set; }

        /// <summary>
        /// SecurityToken is the user's temporary security token. For more details, check out: https://www.alibabacloud.com/help/doc-detail/100624.htm
        /// </summary>
        [Newtonsoft.Json.JsonProperty("securityToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SecurityToken { get; set; }

    }

    /// <summary>
    /// OSSArtifactRepository defines the controller configuration for an OSS artifact repository
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OSSArtifactRepository
    {
        /// <summary>
        /// AccessKeySecret is the secret selector to the bucket's access key
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accessKeySecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector AccessKeySecret { get; set; }

        /// <summary>
        /// Bucket is the name of the bucket
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bucket", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Bucket { get; set; }

        /// <summary>
        /// CreateBucketIfNotPresent tells the driver to attempt to create the OSS bucket for output artifacts, if it doesn't exist
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createBucketIfNotPresent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? CreateBucketIfNotPresent { get; set; }

        /// <summary>
        /// Endpoint is the hostname of the bucket endpoint
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Endpoint { get; set; }

        /// <summary>
        /// KeyFormat is defines the format of how to store keys. Can reference workflow variables
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keyFormat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KeyFormat { get; set; }

        /// <summary>
        /// LifecycleRule specifies how to manage bucket's lifecycle
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lifecycleRule", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OSSLifecycleRule LifecycleRule { get; set; }

        /// <summary>
        /// SecretKeySecret is the secret selector to the bucket's secret key
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secretKeySecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector SecretKeySecret { get; set; }

        /// <summary>
        /// SecurityToken is the user's temporary security token. For more details, check out: https://www.alibabacloud.com/help/doc-detail/100624.htm
        /// </summary>
        [Newtonsoft.Json.JsonProperty("securityToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SecurityToken { get; set; }

    }

    /// <summary>
    /// OSSLifecycleRule specifies how to manage bucket's lifecycle
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OSSLifecycleRule
    {
        /// <summary>
        /// MarkDeletionAfterDays is the number of days before we delete objects in the bucket
        /// </summary>
        [Newtonsoft.Json.JsonProperty("markDeletionAfterDays", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MarkDeletionAfterDays { get; set; }

        /// <summary>
        /// MarkInfrequentAccessAfterDays is the number of days before we convert the objects in the bucket to Infrequent Access (IA) storage type
        /// </summary>
        [Newtonsoft.Json.JsonProperty("markInfrequentAccessAfterDays", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? MarkInfrequentAccessAfterDays { get; set; }

    }

    /// <summary>
    /// Outputs hold parameters, artifacts, and results from a step
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Outputs
    {
        /// <summary>
        /// Artifacts holds the list of output artifacts produced by a step
        /// </summary>
        [Newtonsoft.Json.JsonProperty("artifacts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Artifact> Artifacts { get; set; }

        /// <summary>
        /// ExitCode holds the exit code of a script template
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exitCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ExitCode { get; set; }

        /// <summary>
        /// Parameters holds the list of output parameters produced by a step
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Parameter> Parameters { get; set; }

        /// <summary>
        /// Result holds the result (stdout) of a script template
        /// </summary>
        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Result { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ParallelSteps : System.Collections.ObjectModel.Collection<WorkflowStep>
    {

    }

    /// <summary>
    /// Parameter indicate a passed string parameter to a service template with an optional default value
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Parameter
    {
        /// <summary>
        /// Default is the default value to use for an input parameter if a value was not supplied
        /// </summary>
        [Newtonsoft.Json.JsonProperty("default", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Default { get; set; }

        /// <summary>
        /// Description is the parameter description
        /// </summary>
        [Newtonsoft.Json.JsonProperty("description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Description { get; set; }

        /// <summary>
        /// Enum holds a list of string values to choose from, for the actual value of the parameter
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enum", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Enum { get; set; }

        /// <summary>
        /// GlobalName exports an output parameter to the global scope, making it available as '{{io.argoproj.workflow.v1alpha1.outputs.parameters.XXXX}} and in workflow.status.outputs.parameters
        /// </summary>
        [Newtonsoft.Json.JsonProperty("globalName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GlobalName { get; set; }

        /// <summary>
        /// Name is the parameter name
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Value is the literal value to use for the parameter. If specified in the context of an input parameter, the value takes precedence over any passed values
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

        /// <summary>
        /// ValueFrom is the source for the output parameter's value
        /// </summary>
        [Newtonsoft.Json.JsonProperty("valueFrom", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ValueFrom ValueFrom { get; set; }

    }

    /// <summary>
    /// Plugin is an Object with exactly one key
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Plugin
    {

    }

    /// <summary>
    /// PodGC describes how to delete completed pods as they complete
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PodGC
    {
        /// <summary>
        /// LabelSelector is the label selector to check if the pods match the labels before being added to the pod GC queue.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("labelSelector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LabelSelector LabelSelector { get; set; }

        /// <summary>
        /// Strategy is the strategy to use. One of "OnPodCompletion", "OnPodSuccess", "OnWorkflowCompletion", "OnWorkflowSuccess"
        /// </summary>
        [Newtonsoft.Json.JsonProperty("strategy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Strategy { get; set; }

    }

    /// <summary>
    /// Prometheus is a prometheus metric to be emitted
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Prometheus
    {
        /// <summary>
        /// Counter is a counter metric
        /// </summary>
        [Newtonsoft.Json.JsonProperty("counter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Counter Counter { get; set; }

        /// <summary>
        /// Gauge is a gauge metric
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gauge", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Gauge Gauge { get; set; }

        /// <summary>
        /// Help is a string that describes the metric
        /// </summary>
        [Newtonsoft.Json.JsonProperty("help", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Help { get; set; }

        /// <summary>
        /// Histogram is a histogram metric
        /// </summary>
        [Newtonsoft.Json.JsonProperty("histogram", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Histogram Histogram { get; set; }

        /// <summary>
        /// Labels is a list of metric labels
        /// </summary>
        [Newtonsoft.Json.JsonProperty("labels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<MetricLabel> Labels { get; set; }

        /// <summary>
        /// Name is the name of the metric
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// When is a conditional statement that decides when to emit the metric
        /// </summary>
        [Newtonsoft.Json.JsonProperty("when", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string When { get; set; }

    }

    /// <summary>
    /// RawArtifact allows raw string content to be placed as an artifact in a container
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RawArtifact
    {
        /// <summary>
        /// Data is the string contents of the artifact
        /// </summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Data { get; set; }

    }

    /// <summary>
    /// ResourceTemplate is a template subtype to manipulate kubernetes resources
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ResourceTemplate
    {
        /// <summary>
        /// Action is the action to perform to the resource. Must be one of: get, create, apply, delete, replace, patch
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Action { get; set; }

        /// <summary>
        /// FailureCondition is a label selector expression which describes the conditions of the k8s resource in which the step was considered failed
        /// </summary>
        [Newtonsoft.Json.JsonProperty("failureCondition", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FailureCondition { get; set; }

        /// <summary>
        /// Flags is a set of additional options passed to kubectl before submitting a resource I.e. to disable resource validation: flags: [
        /// <br/>	"--validate=false"  # disable resource validation
        /// <br/>]
        /// </summary>
        [Newtonsoft.Json.JsonProperty("flags", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Flags { get; set; }

        /// <summary>
        /// Manifest contains the kubernetes manifest
        /// </summary>
        [Newtonsoft.Json.JsonProperty("manifest", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Manifest { get; set; }

        /// <summary>
        /// MergeStrategy is the strategy used to merge a patch. It defaults to "strategic" Must be one of: strategic, merge, json
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mergeStrategy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MergeStrategy { get; set; }

        /// <summary>
        /// SetOwnerReference sets the reference to the workflow on the OwnerReference of generated resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("setOwnerReference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? SetOwnerReference { get; set; }

        /// <summary>
        /// SuccessCondition is a label selector expression which describes the conditions of the k8s resource in which it is acceptable to proceed to the following step
        /// </summary>
        [Newtonsoft.Json.JsonProperty("successCondition", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SuccessCondition { get; set; }

    }

    /// <summary>
    /// RetryAffinity prevents running steps on the same host.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RetryAffinity
    {
        [Newtonsoft.Json.JsonProperty("nodeAntiAffinity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RetryNodeAntiAffinity NodeAntiAffinity { get; set; }

    }

    /// <summary>
    /// RetryNodeAntiAffinity is a placeholder for future expansion, only empty nodeAntiAffinity is allowed. In order to prevent running steps on the same host, it uses "kubernetes.io/hostname".
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RetryNodeAntiAffinity
    {

    }

    /// <summary>
    /// RetryStrategy provides controls on how to retry a workflow step
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RetryStrategy
    {
        /// <summary>
        /// Affinity prevents running workflow's step on the same host
        /// </summary>
        [Newtonsoft.Json.JsonProperty("affinity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RetryAffinity Affinity { get; set; }

        /// <summary>
        /// Backoff is a backoff strategy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("backoff", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Backoff3 Backoff { get; set; }

        /// <summary>
        /// Expression is a condition expression for when a node will be retried. If it evaluates to false, the node will not be retried and the retry strategy will be ignored
        /// </summary>
        [Newtonsoft.Json.JsonProperty("expression", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Expression { get; set; }

        /// <summary>
        /// Limit is the maximum number of attempts when retrying a container
        /// </summary>
        [Newtonsoft.Json.JsonProperty("limit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Limit { get; set; }

        /// <summary>
        /// RetryPolicy is a policy of NodePhase statuses that will be retried
        /// </summary>
        [Newtonsoft.Json.JsonProperty("retryPolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RetryPolicy { get; set; }

    }

    /// <summary>
    /// S3Artifact is the location of an S3 artifact
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class S3Artifact2
    {
        /// <summary>
        /// AccessKeySecret is the secret selector to the bucket's access key
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accessKeySecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector AccessKeySecret { get; set; }

        /// <summary>
        /// Bucket is the name of the bucket
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bucket", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Bucket { get; set; }

        /// <summary>
        /// CreateBucketIfNotPresent tells the driver to attempt to create the S3 bucket for output artifacts, if it doesn't exist. Setting Enabled Encryption will apply either SSE-S3 to the bucket if KmsKeyId is not set or SSE-KMS if it is.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createBucketIfNotPresent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CreateS3BucketOptions CreateBucketIfNotPresent { get; set; }

        [Newtonsoft.Json.JsonProperty("encryptionOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public S3EncryptionOptions EncryptionOptions { get; set; }

        /// <summary>
        /// Endpoint is the hostname of the bucket endpoint
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Endpoint { get; set; }

        /// <summary>
        /// Insecure will connect to the service with TLS
        /// </summary>
        [Newtonsoft.Json.JsonProperty("insecure", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Insecure { get; set; }

        /// <summary>
        /// Key is the key in the bucket where the artifact resides
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }

        /// <summary>
        /// Region contains the optional bucket region
        /// </summary>
        [Newtonsoft.Json.JsonProperty("region", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Region { get; set; }

        /// <summary>
        /// RoleARN is the Amazon Resource Name (ARN) of the role to assume.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("roleARN", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RoleARN { get; set; }

        /// <summary>
        /// SecretKeySecret is the secret selector to the bucket's secret key
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secretKeySecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector SecretKeySecret { get; set; }

        /// <summary>
        /// UseSDKCreds tells the driver to figure out credentials based on sdk defaults.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("useSDKCreds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? UseSDKCreds { get; set; }

    }

    /// <summary>
    /// S3ArtifactRepository defines the controller configuration for an S3 artifact repository
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class S3ArtifactRepository
    {
        /// <summary>
        /// AccessKeySecret is the secret selector to the bucket's access key
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accessKeySecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector AccessKeySecret { get; set; }

        /// <summary>
        /// Bucket is the name of the bucket
        /// </summary>
        [Newtonsoft.Json.JsonProperty("bucket", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Bucket { get; set; }

        /// <summary>
        /// CreateBucketIfNotPresent tells the driver to attempt to create the S3 bucket for output artifacts, if it doesn't exist. Setting Enabled Encryption will apply either SSE-S3 to the bucket if KmsKeyId is not set or SSE-KMS if it is.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("createBucketIfNotPresent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CreateS3BucketOptions CreateBucketIfNotPresent { get; set; }

        [Newtonsoft.Json.JsonProperty("encryptionOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public S3EncryptionOptions EncryptionOptions { get; set; }

        /// <summary>
        /// Endpoint is the hostname of the bucket endpoint
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endpoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Endpoint { get; set; }

        /// <summary>
        /// Insecure will connect to the service with TLS
        /// </summary>
        [Newtonsoft.Json.JsonProperty("insecure", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Insecure { get; set; }

        /// <summary>
        /// KeyFormat is defines the format of how to store keys. Can reference workflow variables
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keyFormat", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KeyFormat { get; set; }

        /// <summary>
        /// KeyPrefix is prefix used as part of the bucket key in which the controller will store artifacts. DEPRECATED. Use KeyFormat instead
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keyPrefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KeyPrefix { get; set; }

        /// <summary>
        /// Region contains the optional bucket region
        /// </summary>
        [Newtonsoft.Json.JsonProperty("region", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Region { get; set; }

        /// <summary>
        /// RoleARN is the Amazon Resource Name (ARN) of the role to assume.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("roleARN", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RoleARN { get; set; }

        /// <summary>
        /// SecretKeySecret is the secret selector to the bucket's secret key
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secretKeySecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector SecretKeySecret { get; set; }

        /// <summary>
        /// UseSDKCreds tells the driver to figure out credentials based on sdk defaults.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("useSDKCreds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? UseSDKCreds { get; set; }

    }

    /// <summary>
    /// S3EncryptionOptions used to determine encryption options during s3 operations
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class S3EncryptionOptions
    {
        /// <summary>
        /// EnableEncryption tells the driver to encrypt objects if set to true. If kmsKeyId and serverSideCustomerKeySecret are not set, SSE-S3 will be used
        /// </summary>
        [Newtonsoft.Json.JsonProperty("enableEncryption", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? EnableEncryption { get; set; }

        /// <summary>
        /// KmsEncryptionContext is a json blob that contains an encryption context. See https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context for more information
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kmsEncryptionContext", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KmsEncryptionContext { get; set; }

        /// <summary>
        /// KMSKeyId tells the driver to encrypt the object using the specified KMS Key.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kmsKeyId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string KmsKeyId { get; set; }

        /// <summary>
        /// ServerSideCustomerKeySecret tells the driver to encrypt the output artifacts using SSE-C with the specified secret.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("serverSideCustomerKeySecret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector ServerSideCustomerKeySecret { get; set; }

    }

    /// <summary>
    /// ScriptTemplate is a template subtype to enable scripting through code steps
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ScriptTemplate
    {
        /// <summary>
        /// Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// </summary>
        [Newtonsoft.Json.JsonProperty("args", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Args { get; set; }

        /// <summary>
        /// Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// </summary>
        [Newtonsoft.Json.JsonProperty("command", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Command { get; set; }

        /// <summary>
        /// List of environment variables to set in the container. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("env", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<EnvVar> Env { get; set; }

        /// <summary>
        /// List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("envFrom", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<EnvFromSource> EnvFrom { get; set; }

        /// <summary>
        /// Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("image", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Image { get; set; }

        /// <summary>
        /// Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
        /// </summary>
        [Newtonsoft.Json.JsonProperty("imagePullPolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ImagePullPolicy { get; set; }

        /// <summary>
        /// Actions that the management system should take in response to container lifecycle events. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lifecycle", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Lifecycle Lifecycle { get; set; }

        /// <summary>
        /// Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
        [Newtonsoft.Json.JsonProperty("livenessProbe", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Probe LivenessProbe { get; set; }

        /// <summary>
        /// Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ContainerPort> Ports { get; set; }

        /// <summary>
        /// Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readinessProbe", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Probe ReadinessProbe { get; set; }

        /// <summary>
        /// Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceRequirements Resources { get; set; }

        /// <summary>
        /// SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        /// </summary>
        [Newtonsoft.Json.JsonProperty("securityContext", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecurityContext SecurityContext { get; set; }

        /// <summary>
        /// Source contains the source code of the script to execute
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Source { get; set; }

        /// <summary>
        /// StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startupProbe", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Probe StartupProbe { get; set; }

        /// <summary>
        /// Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stdin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Stdin { get; set; }

        /// <summary>
        /// Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stdinOnce", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? StdinOnce { get; set; }

        /// <summary>
        /// Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("terminationMessagePath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TerminationMessagePath { get; set; }

        /// <summary>
        /// Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("terminationMessagePolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TerminationMessagePolicy { get; set; }

        /// <summary>
        /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tty", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Tty { get; set; }

        /// <summary>
        /// volumeDevices is the list of block devices to be used by the container.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeDevices", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<VolumeDevice> VolumeDevices { get; set; }

        /// <summary>
        /// Pod volumes to mount into the container's filesystem. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeMounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<VolumeMount> VolumeMounts { get; set; }

        /// <summary>
        /// Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("workingDir", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WorkingDir { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SemaphoreHolding
    {
        /// <summary>
        /// Holders stores the list of current holder names in the io.argoproj.workflow.v1alpha1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("holders", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Holders { get; set; }

        /// <summary>
        /// Semaphore stores the semaphore name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("semaphore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Semaphore { get; set; }

    }

    /// <summary>
    /// SemaphoreRef is a reference of Semaphore
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SemaphoreRef
    {
        /// <summary>
        /// ConfigMapKeyRef is configmap selector for Semaphore configuration
        /// </summary>
        [Newtonsoft.Json.JsonProperty("configMapKeyRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConfigMapKeySelector ConfigMapKeyRef { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SemaphoreStatus
    {
        /// <summary>
        /// Holding stores the list of resource acquired synchronization lock for workflows.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("holding", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SemaphoreHolding> Holding { get; set; }

        /// <summary>
        /// Waiting indicates the list of current synchronization lock holders.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("waiting", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<SemaphoreHolding> Waiting { get; set; }

    }

    /// <summary>
    /// Sequence expands a workflow step into numeric range
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Sequence
    {
        /// <summary>
        /// Count is number of elements in the sequence (default: 0). Not to be used with end
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Count { get; set; }

        /// <summary>
        /// Number at which to end the sequence (default: 0). Not to be used with Count
        /// </summary>
        [Newtonsoft.Json.JsonProperty("end", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string End { get; set; }

        /// <summary>
        /// Format is a printf format string to format the value in the sequence
        /// </summary>
        [Newtonsoft.Json.JsonProperty("format", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Format { get; set; }

        /// <summary>
        /// Number at which to start the sequence (default: 0)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("start", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Start { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Submit
    {
        /// <summary>
        /// Arguments extracted from the event and then set as arguments to the workflow created.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("arguments", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Arguments Arguments { get; set; }

        /// <summary>
        /// Metadata optional means to customize select fields of the workflow metadata
        /// </summary>
        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ObjectMeta Metadata { get; set; }

        /// <summary>
        /// WorkflowTemplateRef the workflow template to submit
        /// </summary>
        [Newtonsoft.Json.JsonProperty("workflowTemplateRef", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public WorkflowTemplateRef WorkflowTemplateRef { get; set; } = new WorkflowTemplateRef();

    }

    /// <summary>
    /// SubmitOpts are workflow submission options
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SubmitOpts
    {
        /// <summary>
        /// Annotations adds to metadata.labels
        /// </summary>
        [Newtonsoft.Json.JsonProperty("annotations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Annotations { get; set; }

        /// <summary>
        /// DryRun validates the workflow on the client-side without creating it. This option is not supported in API
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dryRun", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? DryRun { get; set; }

        /// <summary>
        /// Entrypoint overrides spec.entrypoint
        /// </summary>
        [Newtonsoft.Json.JsonProperty("entryPoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EntryPoint { get; set; }

        /// <summary>
        /// GenerateName overrides metadata.generateName
        /// </summary>
        [Newtonsoft.Json.JsonProperty("generateName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GenerateName { get; set; }

        /// <summary>
        /// Labels adds to metadata.labels
        /// </summary>
        [Newtonsoft.Json.JsonProperty("labels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Labels { get; set; }

        /// <summary>
        /// Name overrides metadata.name
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// OwnerReference creates a metadata.ownerReference
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ownerReference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OwnerReference OwnerReference { get; set; }

        /// <summary>
        /// ParameterFile holds a reference to a parameter file. This option is not supported in API
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameterFile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ParameterFile { get; set; }

        /// <summary>
        /// Parameters passes input parameters to workflow
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Parameters { get; set; }

        /// <summary>
        /// Set the podPriorityClassName of the workflow
        /// </summary>
        [Newtonsoft.Json.JsonProperty("podPriorityClassName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PodPriorityClassName { get; set; }

        /// <summary>
        /// Priority is used if controller is configured to process limited number of workflows in parallel, higher priority workflows are processed first.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("priority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Priority { get; set; }

        /// <summary>
        /// ServerDryRun validates the workflow on the server-side without creating it
        /// </summary>
        [Newtonsoft.Json.JsonProperty("serverDryRun", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ServerDryRun { get; set; }

        /// <summary>
        /// ServiceAccount runs all pods in the workflow using specified ServiceAccount.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("serviceAccount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ServiceAccount { get; set; }

    }

    /// <summary>
    /// SuppliedValueFrom is a placeholder for a value to be filled in directly, either through the CLI, API, etc.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SuppliedValueFrom
    {

    }

    /// <summary>
    /// SuspendTemplate is a template subtype to suspend a workflow at a predetermined point in time
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SuspendTemplate
    {
        /// <summary>
        /// Duration is the seconds to wait before automatically resuming a template
        /// </summary>
        [Newtonsoft.Json.JsonProperty("duration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Duration { get; set; }

    }

    /// <summary>
    /// Synchronization holds synchronization lock configuration
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Synchronization
    {
        /// <summary>
        /// Mutex holds the Mutex lock details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mutex", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Mutex Mutex { get; set; }

        /// <summary>
        /// Semaphore holds the Semaphore configuration
        /// </summary>
        [Newtonsoft.Json.JsonProperty("semaphore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SemaphoreRef Semaphore { get; set; }

    }

    /// <summary>
    /// SynchronizationStatus stores the status of semaphore and mutex.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SynchronizationStatus
    {
        /// <summary>
        /// Mutex stores this workflow's mutex holder details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mutex", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public MutexStatus Mutex { get; set; }

        /// <summary>
        /// Semaphore stores this workflow's Semaphore holder details
        /// </summary>
        [Newtonsoft.Json.JsonProperty("semaphore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SemaphoreStatus Semaphore { get; set; }

    }

    /// <summary>
    /// TTLStrategy is the strategy for the time to live depending on if the workflow succeeded or failed
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TTLStrategy
    {
        /// <summary>
        /// SecondsAfterCompletion is the number of seconds to live after completion
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secondsAfterCompletion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SecondsAfterCompletion { get; set; }

        /// <summary>
        /// SecondsAfterFailure is the number of seconds to live after failure
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secondsAfterFailure", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SecondsAfterFailure { get; set; }

        /// <summary>
        /// SecondsAfterSuccess is the number of seconds to live after success
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secondsAfterSuccess", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SecondsAfterSuccess { get; set; }

    }

    /// <summary>
    /// TarStrategy will tar and gzip the file or directory when saving
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TarStrategy
    {
        /// <summary>
        /// CompressionLevel specifies the gzip compression level to use for the artifact. Defaults to gzip.DefaultCompression.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("compressionLevel", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? CompressionLevel { get; set; }

    }

    /// <summary>
    /// Template is a reusable and composable unit of execution in a workflow
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Template2
    {
        /// <summary>
        /// Optional duration in seconds relative to the StartTime that the pod may be active on a node before the system actively tries to terminate the pod; value must be positive integer This field is only applicable to container and script templates.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("activeDeadlineSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ActiveDeadlineSeconds { get; set; }

        /// <summary>
        /// Affinity sets the pod's scheduling constraints Overrides the affinity set at the workflow level (if any)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("affinity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Affinity Affinity { get; set; }

        /// <summary>
        /// Location in which all files related to the step will be stored (logs, artifacts, etc...). Can be overridden by individual items in Outputs. If omitted, will use the default artifact repository location configured in the controller, appended with the &lt;workflowname&gt;/&lt;nodename&gt; in the key.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("archiveLocation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ArtifactLocation2 ArchiveLocation { get; set; }

        /// <summary>
        /// AutomountServiceAccountToken indicates whether a service account token should be automatically mounted in pods. ServiceAccountName of ExecutorConfig must be specified if this value is false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("automountServiceAccountToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AutomountServiceAccountToken { get; set; }

        /// <summary>
        /// Container is the main container image to run in the pod
        /// </summary>
        [Newtonsoft.Json.JsonProperty("container", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Container2 Container { get; set; }

        /// <summary>
        /// ContainerSet groups multiple containers within a single pod.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("containerSet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ContainerSetTemplate ContainerSet { get; set; }

        /// <summary>
        /// Deamon will allow a workflow to proceed to the next step so long as the container reaches readiness
        /// </summary>
        [Newtonsoft.Json.JsonProperty("daemon", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Daemon { get; set; }

        /// <summary>
        /// DAG template subtype which runs a DAG
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dag", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DAGTemplate Dag { get; set; }

        /// <summary>
        /// Data is a data template
        /// </summary>
        [Newtonsoft.Json.JsonProperty("data", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Data Data { get; set; }

        /// <summary>
        /// Executor holds configurations of the executor container.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("executor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ExecutorConfig Executor { get; set; }

        /// <summary>
        /// FailFast, if specified, will fail this template if any of its child pods has failed. This is useful for when this template is expanded with `withItems`, etc.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("failFast", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? FailFast { get; set; }

        /// <summary>
        /// HostAliases is an optional list of hosts and IPs that will be injected into the pod spec
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hostAliases", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<HostAlias> HostAliases { get; set; }

        /// <summary>
        /// HTTP makes a HTTP request
        /// </summary>
        [Newtonsoft.Json.JsonProperty("http", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HTTP2 Http { get; set; }

        /// <summary>
        /// InitContainers is a list of containers which run before the main container.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("initContainers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<UserContainer> InitContainers { get; set; }

        /// <summary>
        /// Inputs describe what inputs parameters and artifacts are supplied to this template
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inputs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Inputs Inputs { get; set; }

        /// <summary>
        /// Memoize allows templates to use outputs generated from already executed templates
        /// </summary>
        [Newtonsoft.Json.JsonProperty("memoize", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Memoize Memoize { get; set; }

        /// <summary>
        /// Metdata sets the pods's metadata, i.e. annotations and labels
        /// </summary>
        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Metadata3 Metadata { get; set; }

        /// <summary>
        /// Metrics are a list of metrics emitted from this template
        /// </summary>
        [Newtonsoft.Json.JsonProperty("metrics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Metrics Metrics { get; set; }

        /// <summary>
        /// Name is the name of the template
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// NodeSelector is a selector to schedule this step of the workflow to be run on the selected node(s). Overrides the selector set at the workflow level.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nodeSelector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> NodeSelector { get; set; }

        /// <summary>
        /// Outputs describe the parameters and artifacts that this template produces
        /// </summary>
        [Newtonsoft.Json.JsonProperty("outputs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Outputs Outputs { get; set; }

        /// <summary>
        /// Parallelism limits the max total parallel pods that can execute at the same time within the boundaries of this template invocation. If additional steps/dag templates are invoked, the pods created by those templates will not be counted towards this total.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parallelism", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Parallelism { get; set; }

        /// <summary>
        /// Plugin is a plugin template
        /// </summary>
        [Newtonsoft.Json.JsonProperty("plugin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Plugin Plugin { get; set; }

        /// <summary>
        /// PodSpecPatch holds strategic merge patch to apply against the pod spec. Allows parameterization of container fields which are not strings (e.g. resource limits).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("podSpecPatch", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PodSpecPatch { get; set; }

        /// <summary>
        /// Priority to apply to workflow pods.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("priority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Priority { get; set; }

        /// <summary>
        /// PriorityClassName to apply to workflow pods.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("priorityClassName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PriorityClassName { get; set; }

        /// <summary>
        /// Resource template subtype which can run k8s resources
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceTemplate Resource { get; set; }

        /// <summary>
        /// RetryStrategy describes how to retry a template when it fails
        /// </summary>
        [Newtonsoft.Json.JsonProperty("retryStrategy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RetryStrategy RetryStrategy { get; set; }

        /// <summary>
        /// If specified, the pod will be dispatched by specified scheduler. Or it will be dispatched by workflow scope scheduler if specified. If neither specified, the pod will be dispatched by default scheduler.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("schedulerName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SchedulerName { get; set; }

        /// <summary>
        /// Script runs a portion of code against an interpreter
        /// </summary>
        [Newtonsoft.Json.JsonProperty("script", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ScriptTemplate Script { get; set; }

        /// <summary>
        /// SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("securityContext", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PodSecurityContext SecurityContext { get; set; }

        /// <summary>
        /// ServiceAccountName to apply to workflow pods
        /// </summary>
        [Newtonsoft.Json.JsonProperty("serviceAccountName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ServiceAccountName { get; set; }

        /// <summary>
        /// Sidecars is a list of containers which run alongside the main container Sidecars are automatically killed when the main container completes
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sidecars", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<UserContainer> Sidecars { get; set; }

        /// <summary>
        /// Steps define a series of sequential/parallel workflow steps
        /// </summary>
        [Newtonsoft.Json.JsonProperty("steps", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ParallelSteps> Steps { get; set; }

        /// <summary>
        /// Suspend template subtype which can suspend a workflow when reaching the step
        /// </summary>
        [Newtonsoft.Json.JsonProperty("suspend", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SuspendTemplate Suspend { get; set; }

        /// <summary>
        /// Synchronization holds synchronization lock configuration for this template
        /// </summary>
        [Newtonsoft.Json.JsonProperty("synchronization", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Synchronization Synchronization { get; set; }

        /// <summary>
        /// Timeout allows to set the total node execution timeout duration counting from the node's start time. This duration also includes time in which the node spends in Pending state. This duration may not be applied to Step or DAG templates.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timeout", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Timeout { get; set; }

        /// <summary>
        /// Tolerations to apply to workflow pods.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tolerations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Toleration> Tolerations { get; set; }

        /// <summary>
        /// Volumes is a list of volumes that can be mounted by containers in a template.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Volume> Volumes { get; set; }

    }

    /// <summary>
    /// TemplateRef is a reference of template resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TemplateRef
    {
        /// <summary>
        /// ClusterScope indicates the referred template is cluster scoped (i.e. a ClusterWorkflowTemplate).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("clusterScope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ClusterScope { get; set; }

        /// <summary>
        /// Name is the resource name of the template.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Template is the name of referred template in the resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("template", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Template { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TransformationStep
    {
        /// <summary>
        /// Expression defines an expr expression to apply
        /// </summary>
        [Newtonsoft.Json.JsonProperty("expression", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Expression { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UpdateCronWorkflowRequest
    {
        [Newtonsoft.Json.JsonProperty("cronWorkflow", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CronWorkflow CronWorkflow { get; set; }

        /// <summary>
        /// DEPRECATED: This field is ignored.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

    }

    /// <summary>
    /// UserContainer is a container specified by a user.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UserContainer
    {
        /// <summary>
        /// Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// </summary>
        [Newtonsoft.Json.JsonProperty("args", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Args { get; set; }

        /// <summary>
        /// Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// </summary>
        [Newtonsoft.Json.JsonProperty("command", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Command { get; set; }

        /// <summary>
        /// List of environment variables to set in the container. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("env", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<EnvVar> Env { get; set; }

        /// <summary>
        /// List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("envFrom", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<EnvFromSource> EnvFrom { get; set; }

        /// <summary>
        /// Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("image", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Image { get; set; }

        /// <summary>
        /// Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
        /// </summary>
        [Newtonsoft.Json.JsonProperty("imagePullPolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ImagePullPolicy { get; set; }

        /// <summary>
        /// Actions that the management system should take in response to container lifecycle events. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lifecycle", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Lifecycle Lifecycle { get; set; }

        /// <summary>
        /// Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
        [Newtonsoft.Json.JsonProperty("livenessProbe", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Probe LivenessProbe { get; set; }

        /// <summary>
        /// MirrorVolumeMounts will mount the same volumes specified in the main container to the container (including artifacts), at the same mountPaths. This enables dind daemon to partially see the same filesystem as the main container in order to use features such as docker volume binding
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mirrorVolumeMounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? MirrorVolumeMounts { get; set; }

        /// <summary>
        /// Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ContainerPort> Ports { get; set; }

        /// <summary>
        /// Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readinessProbe", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Probe ReadinessProbe { get; set; }

        /// <summary>
        /// Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceRequirements Resources { get; set; }

        /// <summary>
        /// SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        /// </summary>
        [Newtonsoft.Json.JsonProperty("securityContext", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecurityContext SecurityContext { get; set; }

        /// <summary>
        /// StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startupProbe", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Probe StartupProbe { get; set; }

        /// <summary>
        /// Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stdin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Stdin { get; set; }

        /// <summary>
        /// Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stdinOnce", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? StdinOnce { get; set; }

        /// <summary>
        /// Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("terminationMessagePath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TerminationMessagePath { get; set; }

        /// <summary>
        /// Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("terminationMessagePolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TerminationMessagePolicy { get; set; }

        /// <summary>
        /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tty", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Tty { get; set; }

        /// <summary>
        /// volumeDevices is the list of block devices to be used by the container.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeDevices", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<VolumeDevice> VolumeDevices { get; set; }

        /// <summary>
        /// Pod volumes to mount into the container's filesystem. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeMounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<VolumeMount> VolumeMounts { get; set; }

        /// <summary>
        /// Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("workingDir", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WorkingDir { get; set; }

    }

    /// <summary>
    /// ValueFrom describes a location in which to obtain the value to a parameter
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ValueFrom
    {
        /// <summary>
        /// ConfigMapKeyRef is configmap selector for input parameter configuration
        /// </summary>
        [Newtonsoft.Json.JsonProperty("configMapKeyRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConfigMapKeySelector ConfigMapKeyRef { get; set; }

        /// <summary>
        /// Default specifies a value to be used if retrieving the value from the specified source fails
        /// </summary>
        [Newtonsoft.Json.JsonProperty("default", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Default { get; set; }

        /// <summary>
        /// Selector (https://github.com/antonmedv/expr) that is evaluated against the event to get the value of the parameter. E.g. `payload.message`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("event", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Event { get; set; }

        /// <summary>
        /// Expression, if defined, is evaluated to specify the value for the parameter
        /// </summary>
        [Newtonsoft.Json.JsonProperty("expression", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Expression { get; set; }

        /// <summary>
        /// JQFilter expression against the resource object in resource templates
        /// </summary>
        [Newtonsoft.Json.JsonProperty("jqFilter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JqFilter { get; set; }

        /// <summary>
        /// JSONPath of a resource to retrieve an output parameter value from in resource templates
        /// </summary>
        [Newtonsoft.Json.JsonProperty("jsonPath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string JsonPath { get; set; }

        /// <summary>
        /// Parameter reference to a step or dag task in which to retrieve an output parameter value from (e.g. '{{steps.mystep.outputs.myparam}}')
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parameter", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Parameter { get; set; }

        /// <summary>
        /// Path in the container to retrieve an output parameter value from in container templates
        /// </summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }

        /// <summary>
        /// Supplied value to be filled in directly, either through the CLI, API, etc.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("supplied", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SuppliedValueFrom Supplied { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Version
    {
        [Newtonsoft.Json.JsonProperty("buildDate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string BuildDate { get; set; }

        [Newtonsoft.Json.JsonProperty("compiler", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Compiler { get; set; }

        [Newtonsoft.Json.JsonProperty("gitCommit", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string GitCommit { get; set; }

        [Newtonsoft.Json.JsonProperty("gitTag", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string GitTag { get; set; }

        [Newtonsoft.Json.JsonProperty("gitTreeState", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string GitTreeState { get; set; }

        [Newtonsoft.Json.JsonProperty("goVersion", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string GoVersion { get; set; }

        [Newtonsoft.Json.JsonProperty("platform", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Platform { get; set; }

        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Version1 { get; set; }

    }

    /// <summary>
    /// VolumeClaimGC describes how to delete volumes from completed Workflows
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class VolumeClaimGC
    {
        /// <summary>
        /// Strategy is the strategy to use. One of "OnWorkflowCompletion", "OnWorkflowSuccess"
        /// </summary>
        [Newtonsoft.Json.JsonProperty("strategy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Strategy { get; set; }

    }

    /// <summary>
    /// Workflow is the definition of a workflow resource
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Workflow
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apiVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kind { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ObjectMeta Metadata { get; set; } = new ObjectMeta();

        [Newtonsoft.Json.JsonProperty("spec", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public WorkflowSpec Spec { get; set; } = new WorkflowSpec();

        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WorkflowStatus Status { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowCreateRequest
    {
        [Newtonsoft.Json.JsonProperty("createOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CreateOptions CreateOptions { get; set; }

        /// <summary>
        /// This field is no longer used.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("instanceID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InstanceID { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

        [Newtonsoft.Json.JsonProperty("serverDryRun", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ServerDryRun { get; set; }

        [Newtonsoft.Json.JsonProperty("workflow", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Workflow Workflow { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowDeleteResponse
    {

    }

    /// <summary>
    /// WorkflowEventBinding is the definition of an event resource
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowEventBinding
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apiVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kind { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ObjectMeta Metadata { get; set; } = new ObjectMeta();

        [Newtonsoft.Json.JsonProperty("spec", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public WorkflowEventBindingSpec Spec { get; set; } = new WorkflowEventBindingSpec();

    }

    /// <summary>
    /// WorkflowEventBindingList is list of event resources
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowEventBindingList
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apiVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ApiVersion { get; set; }

        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<WorkflowEventBinding> Items { get; set; } = new System.Collections.ObjectModel.Collection<WorkflowEventBinding>();

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kind { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ListMeta Metadata { get; set; } = new ListMeta();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowEventBindingSpec
    {
        /// <summary>
        /// Event is the event to bind to
        /// </summary>
        [Newtonsoft.Json.JsonProperty("event", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Event Event { get; set; } = new Event();

        /// <summary>
        /// Submit is the workflow template to submit
        /// </summary>
        [Newtonsoft.Json.JsonProperty("submit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Submit Submit { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowLintRequest
    {
        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

        [Newtonsoft.Json.JsonProperty("workflow", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Workflow Workflow { get; set; }

    }

    /// <summary>
    /// WorkflowList is list of Workflow resources
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowList
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apiVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ApiVersion { get; set; }

        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Workflow> Items { get; set; } = new System.Collections.ObjectModel.Collection<Workflow>();

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kind { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ListMeta Metadata { get; set; } = new ListMeta();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowMetadata
    {
        [Newtonsoft.Json.JsonProperty("annotations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Annotations { get; set; }

        [Newtonsoft.Json.JsonProperty("labels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; set; }

        [Newtonsoft.Json.JsonProperty("labelsFrom", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, LabelValueFrom> LabelsFrom { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowResubmitRequest
    {
        [Newtonsoft.Json.JsonProperty("memoized", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Memoized { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowResumeRequest
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

        [Newtonsoft.Json.JsonProperty("nodeFieldSelector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NodeFieldSelector { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowRetryRequest
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

        [Newtonsoft.Json.JsonProperty("nodeFieldSelector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NodeFieldSelector { get; set; }

        [Newtonsoft.Json.JsonProperty("restartSuccessful", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RestartSuccessful { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowSetRequest
    {
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

        [Newtonsoft.Json.JsonProperty("nodeFieldSelector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NodeFieldSelector { get; set; }

        [Newtonsoft.Json.JsonProperty("outputParameters", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OutputParameters { get; set; }

        [Newtonsoft.Json.JsonProperty("phase", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Phase { get; set; }

    }

    /// <summary>
    /// WorkflowSpec is the specification of a Workflow.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowSpec
    {
        /// <summary>
        /// Optional duration in seconds relative to the workflow start time which the workflow is allowed to run before the controller terminates the io.argoproj.workflow.v1alpha1. A value of zero is used to terminate a Running workflow
        /// </summary>
        [Newtonsoft.Json.JsonProperty("activeDeadlineSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ActiveDeadlineSeconds { get; set; }

        /// <summary>
        /// Affinity sets the scheduling constraints for all pods in the io.argoproj.workflow.v1alpha1. Can be overridden by an affinity specified in the template
        /// </summary>
        [Newtonsoft.Json.JsonProperty("affinity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Affinity Affinity { get; set; }

        /// <summary>
        /// ArchiveLogs indicates if the container logs should be archived
        /// </summary>
        [Newtonsoft.Json.JsonProperty("archiveLogs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ArchiveLogs { get; set; }

        /// <summary>
        /// Arguments contain the parameters and artifacts sent to the workflow entrypoint Parameters are referencable globally using the 'workflow' variable prefix. e.g. {{io.argoproj.workflow.v1alpha1.parameters.myparam}}
        /// </summary>
        [Newtonsoft.Json.JsonProperty("arguments", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Arguments Arguments { get; set; }

        /// <summary>
        /// ArtifactRepositoryRef specifies the configMap name and key containing the artifact repository config.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("artifactRepositoryRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ArtifactRepositoryRef ArtifactRepositoryRef { get; set; }

        /// <summary>
        /// AutomountServiceAccountToken indicates whether a service account token should be automatically mounted in pods. ServiceAccountName of ExecutorConfig must be specified if this value is false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("automountServiceAccountToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AutomountServiceAccountToken { get; set; }

        /// <summary>
        /// PodDNSConfig defines the DNS parameters of a pod in addition to those generated from DNSPolicy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dnsConfig", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PodDNSConfig DnsConfig { get; set; }

        /// <summary>
        /// Set DNS policy for the pod. Defaults to "ClusterFirst". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dnsPolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DnsPolicy { get; set; }

        /// <summary>
        /// Entrypoint is a template reference to the starting point of the io.argoproj.workflow.v1alpha1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("entrypoint", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Entrypoint { get; set; }

        /// <summary>
        /// Executor holds configurations of executor containers of the io.argoproj.workflow.v1alpha1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("executor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ExecutorConfig Executor { get; set; }

        /// <summary>
        /// Hooks holds the lifecycle hook which is invoked at lifecycle of step, irrespective of the success, failure, or error status of the primary step
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hooks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, LifecycleHook> Hooks { get; set; }

        [Newtonsoft.Json.JsonProperty("hostAliases", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<HostAlias> HostAliases { get; set; }

        /// <summary>
        /// Host networking requested for this workflow pod. Default to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hostNetwork", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? HostNetwork { get; set; }

        /// <summary>
        /// ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet. More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
        /// </summary>
        [Newtonsoft.Json.JsonProperty("imagePullSecrets", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LocalObjectReference> ImagePullSecrets { get; set; }

        /// <summary>
        /// Metrics are a list of metrics emitted from this Workflow
        /// </summary>
        [Newtonsoft.Json.JsonProperty("metrics", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Metrics Metrics { get; set; }

        /// <summary>
        /// NodeSelector is a selector which will result in all pods of the workflow to be scheduled on the selected node(s). This is able to be overridden by a nodeSelector specified in the template.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nodeSelector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> NodeSelector { get; set; }

        /// <summary>
        /// OnExit is a template reference which is invoked at the end of the workflow, irrespective of the success, failure, or error of the primary io.argoproj.workflow.v1alpha1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("onExit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OnExit { get; set; }

        /// <summary>
        /// Parallelism limits the max total parallel pods that can execute at the same time in a workflow
        /// </summary>
        [Newtonsoft.Json.JsonProperty("parallelism", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Parallelism { get; set; }

        /// <summary>
        /// PodDisruptionBudget holds the number of concurrent disruptions that you allow for Workflow's Pods. Controller will automatically add the selector with workflow name, if selector is empty. Optional: Defaults to empty.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("podDisruptionBudget", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PodDisruptionBudgetSpec PodDisruptionBudget { get; set; }

        /// <summary>
        /// PodGC describes the strategy to use when to deleting completed pods
        /// </summary>
        [Newtonsoft.Json.JsonProperty("podGC", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PodGC PodGC { get; set; }

        /// <summary>
        /// PodMetadata defines additional metadata that should be applied to workflow pods
        /// </summary>
        [Newtonsoft.Json.JsonProperty("podMetadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Metadata3 PodMetadata { get; set; }

        /// <summary>
        /// Priority to apply to workflow pods.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("podPriority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? PodPriority { get; set; }

        /// <summary>
        /// PriorityClassName to apply to workflow pods.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("podPriorityClassName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PodPriorityClassName { get; set; }

        /// <summary>
        /// PodSpecPatch holds strategic merge patch to apply against the pod spec. Allows parameterization of container fields which are not strings (e.g. resource limits).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("podSpecPatch", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PodSpecPatch { get; set; }

        /// <summary>
        /// Priority is used if controller is configured to process limited number of workflows in parallel. Workflows with higher priority are processed first.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("priority", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Priority { get; set; }

        /// <summary>
        /// RetryStrategy for all templates in the io.argoproj.workflow.v1alpha1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("retryStrategy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RetryStrategy RetryStrategy { get; set; }

        /// <summary>
        /// Set scheduler name for all pods. Will be overridden if container/script template's scheduler name is set. Default scheduler will be used if neither specified.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("schedulerName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SchedulerName { get; set; }

        /// <summary>
        /// SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("securityContext", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PodSecurityContext SecurityContext { get; set; }

        /// <summary>
        /// ServiceAccountName is the name of the ServiceAccount to run all pods of the workflow as.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("serviceAccountName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ServiceAccountName { get; set; }

        /// <summary>
        /// Shutdown will shutdown the workflow according to its ShutdownStrategy
        /// </summary>
        [Newtonsoft.Json.JsonProperty("shutdown", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Shutdown { get; set; }

        /// <summary>
        /// Suspend will suspend the workflow and prevent execution of any future steps in the workflow
        /// </summary>
        [Newtonsoft.Json.JsonProperty("suspend", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Suspend { get; set; }

        /// <summary>
        /// Synchronization holds synchronization lock configuration for this Workflow
        /// </summary>
        [Newtonsoft.Json.JsonProperty("synchronization", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Synchronization Synchronization { get; set; }

        /// <summary>
        /// TemplateDefaults holds default template values that will apply to all templates in the Workflow, unless overridden on the template-level
        /// </summary>
        [Newtonsoft.Json.JsonProperty("templateDefaults", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Template2 TemplateDefaults { get; set; }

        /// <summary>
        /// Templates is a list of workflow templates used in a workflow
        /// </summary>
        [Newtonsoft.Json.JsonProperty("templates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Template2> Templates { get; set; }

        /// <summary>
        /// Tolerations to apply to workflow pods.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tolerations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Toleration> Tolerations { get; set; }

        /// <summary>
        /// TTLStrategy limits the lifetime of a Workflow that has finished execution depending on if it Succeeded or Failed. If this struct is set, once the Workflow finishes, it will be deleted after the time to live expires. If this field is unset, the controller config map will hold the default values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ttlStrategy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TTLStrategy TtlStrategy { get; set; }

        /// <summary>
        /// VolumeClaimGC describes the strategy to use when to deleting volumes from completed workflows
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeClaimGC", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public VolumeClaimGC VolumeClaimGC { get; set; }

        /// <summary>
        /// VolumeClaimTemplates is a list of claims that containers are allowed to reference. The Workflow controller will create the claims at the beginning of the workflow and delete the claims upon completion of the workflow
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeClaimTemplates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PersistentVolumeClaim> VolumeClaimTemplates { get; set; }

        /// <summary>
        /// Volumes is a list of volumes that can be mounted by containers in a io.argoproj.workflow.v1alpha1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Volume> Volumes { get; set; }

        /// <summary>
        /// WorkflowMetadata contains some metadata of the workflow to be refer
        /// </summary>
        [Newtonsoft.Json.JsonProperty("workflowMetadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WorkflowMetadata WorkflowMetadata { get; set; }

        /// <summary>
        /// WorkflowTemplateRef holds a reference to a WorkflowTemplate for execution
        /// </summary>
        [Newtonsoft.Json.JsonProperty("workflowTemplateRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WorkflowTemplateRef WorkflowTemplateRef { get; set; }

    }

    /// <summary>
    /// WorkflowStatus contains overall status information about a workflow
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowStatus
    {
        /// <summary>
        /// ArtifactRepositoryRef is used to cache the repository to use so we do not need to determine it everytime we reconcile.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("artifactRepositoryRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ArtifactRepositoryRefStatus ArtifactRepositoryRef { get; set; }

        /// <summary>
        /// Compressed and base64 decoded Nodes map
        /// </summary>
        [Newtonsoft.Json.JsonProperty("compressedNodes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CompressedNodes { get; set; }

        /// <summary>
        /// Conditions is a list of conditions the Workflow may have
        /// </summary>
        [Newtonsoft.Json.JsonProperty("conditions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Condition2> Conditions { get; set; }

        /// <summary>
        /// EstimatedDuration in seconds.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("estimatedDuration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? EstimatedDuration { get; set; }

        /// <summary>
        /// Time at which this workflow completed
        /// </summary>
        [Newtonsoft.Json.JsonProperty("finishedAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? FinishedAt { get; set; }

        /// <summary>
        /// A human readable message indicating details about why the workflow is in this condition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        /// <summary>
        /// Nodes is a mapping between a node ID and the node's status.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nodes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, NodeStatus> Nodes { get; set; }

        /// <summary>
        /// Whether on not node status has been offloaded to a database. If exists, then Nodes and CompressedNodes will be empty. This will actually be populated with a hash of the offloaded data.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("offloadNodeStatusVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OffloadNodeStatusVersion { get; set; }

        /// <summary>
        /// Outputs captures output values and artifact locations produced by the workflow via global outputs
        /// </summary>
        [Newtonsoft.Json.JsonProperty("outputs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Outputs Outputs { get; set; }

        /// <summary>
        /// PersistentVolumeClaims tracks all PVCs that were created as part of the io.argoproj.workflow.v1alpha1. The contents of this list are drained at the end of the workflow.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("persistentVolumeClaims", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Volume> PersistentVolumeClaims { get; set; }

        /// <summary>
        /// Phase a simple, high-level summary of where the workflow is in its lifecycle.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("phase", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Phase { get; set; }

        /// <summary>
        /// Progress to completion
        /// </summary>
        [Newtonsoft.Json.JsonProperty("progress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Progress { get; set; }

        /// <summary>
        /// ResourcesDuration is the total for the workflow
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourcesDuration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, long> ResourcesDuration { get; set; }

        /// <summary>
        /// Time at which this workflow started
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startedAt", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? StartedAt { get; set; }

        /// <summary>
        /// StoredTemplates is a mapping between a template ref and the node's status.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("storedTemplates", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, Template2> StoredTemplates { get; set; }

        /// <summary>
        /// StoredWorkflowSpec stores the WorkflowTemplate spec for future execution.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("storedWorkflowTemplateSpec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WorkflowSpec StoredWorkflowTemplateSpec { get; set; }

        /// <summary>
        /// Synchronization stores the status of synchronization locks
        /// </summary>
        [Newtonsoft.Json.JsonProperty("synchronization", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SynchronizationStatus Synchronization { get; set; }

    }

    /// <summary>
    /// WorkflowStep is a reference to a template to execute in a series of step
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowStep
    {
        /// <summary>
        /// Arguments hold arguments to the template
        /// </summary>
        [Newtonsoft.Json.JsonProperty("arguments", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Arguments Arguments { get; set; }

        /// <summary>
        /// ContinueOn makes argo to proceed with the following step even if this step fails. Errors and Failed states can be specified
        /// </summary>
        [Newtonsoft.Json.JsonProperty("continueOn", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ContinueOn ContinueOn { get; set; }

        /// <summary>
        /// Hooks holds the lifecycle hook which is invoked at lifecycle of step, irrespective of the success, failure, or error status of the primary step
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hooks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, LifecycleHook> Hooks { get; set; }

        /// <summary>
        /// Inline is the template. Template must be empty if this is declared (and vice-versa).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("inline", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Template2 Inline { get; set; }

        /// <summary>
        /// Name of the step
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// OnExit is a template reference which is invoked at the end of the template, irrespective of the success, failure, or error of the primary template. DEPRECATED: Use Hooks[exit].Template instead.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("onExit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string OnExit { get; set; }

        /// <summary>
        /// Template is the name of the template to execute as the step
        /// </summary>
        [Newtonsoft.Json.JsonProperty("template", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Template { get; set; }

        /// <summary>
        /// TemplateRef is the reference to the template resource to execute as the step.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("templateRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TemplateRef TemplateRef { get; set; }

        /// <summary>
        /// When is an expression in which the step should conditionally execute
        /// </summary>
        [Newtonsoft.Json.JsonProperty("when", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string When { get; set; }

        /// <summary>
        /// WithItems expands a step into multiple parallel steps from the items in the list
        /// </summary>
        [Newtonsoft.Json.JsonProperty("withItems", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Item> WithItems { get; set; }

        /// <summary>
        /// WithParam expands a step into multiple parallel steps from the value in the parameter, which is expected to be a JSON list.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("withParam", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WithParam { get; set; }

        /// <summary>
        /// WithSequence expands a step into a numeric sequence
        /// </summary>
        [Newtonsoft.Json.JsonProperty("withSequence", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Sequence WithSequence { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowStopRequest
    {
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

        [Newtonsoft.Json.JsonProperty("nodeFieldSelector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NodeFieldSelector { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowSubmitRequest
    {
        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

        [Newtonsoft.Json.JsonProperty("resourceKind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceKind { get; set; }

        [Newtonsoft.Json.JsonProperty("resourceName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceName { get; set; }

        [Newtonsoft.Json.JsonProperty("submitOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SubmitOpts SubmitOptions { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowSuspendRequest
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowTaskSetSpec
    {
        [Newtonsoft.Json.JsonProperty("tasks", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, Template2> Tasks { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowTaskSetStatus
    {
        [Newtonsoft.Json.JsonProperty("nodes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, NodeResult> Nodes { get; set; }

    }

    /// <summary>
    /// WorkflowTemplate is the definition of a workflow template resource
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowTemplate
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apiVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kind { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ObjectMeta Metadata { get; set; } = new ObjectMeta();

        [Newtonsoft.Json.JsonProperty("spec", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public WorkflowSpec Spec { get; set; } = new WorkflowSpec();

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowTemplateCreateRequest
    {
        [Newtonsoft.Json.JsonProperty("createOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CreateOptions CreateOptions { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

        [Newtonsoft.Json.JsonProperty("template", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WorkflowTemplate Template { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowTemplateDeleteResponse
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowTemplateLintRequest
    {
        [Newtonsoft.Json.JsonProperty("createOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CreateOptions CreateOptions { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

        [Newtonsoft.Json.JsonProperty("template", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WorkflowTemplate Template { get; set; }

    }

    /// <summary>
    /// WorkflowTemplateList is list of WorkflowTemplate resources
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowTemplateList
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apiVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ApiVersion { get; set; }

        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<WorkflowTemplate> Items { get; set; } = new System.Collections.ObjectModel.Collection<WorkflowTemplate>();

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.io.k8s.community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kind { get; set; }

        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ListMeta Metadata { get; set; } = new ListMeta();

    }

    /// <summary>
    /// WorkflowTemplateRef is a reference to a WorkflowTemplate resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowTemplateRef
    {
        /// <summary>
        /// ClusterScope indicates the referred template is cluster scoped (i.e. a ClusterWorkflowTemplate).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("clusterScope", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ClusterScope { get; set; }

        /// <summary>
        /// Name is the resource name of the workflow template.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowTemplateUpdateRequest
    {
        /// <summary>
        /// DEPRECATED: This field is ignored.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

        [Newtonsoft.Json.JsonProperty("template", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WorkflowTemplate Template { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowTerminateRequest
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WorkflowWatchEvent
    {
        [Newtonsoft.Json.JsonProperty("object", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Workflow Object { get; set; }

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    /// <summary>
    /// ZipStrategy will unzip zipped input artifacts
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ZipStrategy
    {

    }

    /// <summary>
    /// Represents a Persistent Disk resource in AWS.
    /// <br/>
    /// <br/>An AWS EBS disk must exist before mounting to a container. The disk must also be in the same AWS zone as the kubelet. An AWS EBS disk can only be mounted as read/write once. AWS EBS volumes support ownership management and SELinux relabeling.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AWSElasticBlockStoreVolumeSource
    {
        /// <summary>
        /// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }

        /// <summary>
        /// The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("partition", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Partition { get; set; }

        /// <summary>
        /// Specify "true" to force and set the ReadOnly property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }

        /// <summary>
        /// Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeID", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string VolumeID { get; set; }

    }

    /// <summary>
    /// Affinity is a group of affinity scheduling rules.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Affinity
    {
        /// <summary>
        /// Describes node affinity scheduling rules for the pod.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nodeAffinity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public NodeAffinity NodeAffinity { get; set; }

        /// <summary>
        /// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("podAffinity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PodAffinity PodAffinity { get; set; }

        /// <summary>
        /// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("podAntiAffinity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PodAntiAffinity PodAntiAffinity { get; set; }

    }

    /// <summary>
    /// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AzureDiskVolumeSource
    {
        /// <summary>
        /// Host Caching mode: None, Read Only, Read Write.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cachingMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CachingMode { get; set; }

        /// <summary>
        /// The Name of the data disk in the blob storage
        /// </summary>
        [Newtonsoft.Json.JsonProperty("diskName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string DiskName { get; set; }

        /// <summary>
        /// The URI the data disk in the blob storage
        /// </summary>
        [Newtonsoft.Json.JsonProperty("diskURI", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string DiskURI { get; set; }

        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }

        /// <summary>
        /// Expected values Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kind { get; set; }

        /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }

    }

    /// <summary>
    /// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AzureFileVolumeSource
    {
        /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }

        /// <summary>
        /// the name of secret that contains Azure Storage Account Name and Key
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secretName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string SecretName { get; set; }

        /// <summary>
        /// Share Name
        /// </summary>
        [Newtonsoft.Json.JsonProperty("shareName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ShareName { get; set; }

    }

    /// <summary>
    /// Represents a source location of a volume to mount, managed by an external CSI driver
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CSIVolumeSource
    {
        /// <summary>
        /// Driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("driver", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Driver { get; set; }

        /// <summary>
        /// Filesystem type to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }

        /// <summary>
        /// NodePublishSecretRef is a reference to the secret object containing sensitive information to pass to the CSI driver to complete the CSI NodePublishVolume and NodeUnpublishVolume calls. This field is optional, and  may be empty if no secret is required. If the secret object contains more than one secret, all secret references are passed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nodePublishSecretRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LocalObjectReference NodePublishSecretRef { get; set; }

        /// <summary>
        /// Specifies a read-only configuration for the volume. Defaults to false (read/write).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }

        /// <summary>
        /// VolumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeAttributes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> VolumeAttributes { get; set; }

    }

    /// <summary>
    /// Adds and removes POSIX capabilities from running containers.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Capabilities
    {
        /// <summary>
        /// Added capabilities
        /// </summary>
        [Newtonsoft.Json.JsonProperty("add", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Add { get; set; }

        /// <summary>
        /// Removed capabilities
        /// </summary>
        [Newtonsoft.Json.JsonProperty("drop", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Drop { get; set; }

    }

    /// <summary>
    /// Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not support ownership management or SELinux relabeling.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CephFSVolumeSource
    {
        /// <summary>
        /// Required: Monitors is a collection of Ceph monitors More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
        [Newtonsoft.Json.JsonProperty("monitors", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Monitors { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>
        /// Optional: Used as the mounted root, rather than the full Ceph tree, default is /
        /// </summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }

        /// <summary>
        /// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }

        /// <summary>
        /// Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secretFile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SecretFile { get; set; }

        /// <summary>
        /// Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secretRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LocalObjectReference SecretRef { get; set; }

        /// <summary>
        /// Optional: User is the rados user name, default is admin More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
        /// </summary>
        [Newtonsoft.Json.JsonProperty("user", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string User { get; set; }

    }

    /// <summary>
    /// Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting to a container. The volume must also be in the same region as the kubelet. Cinder volumes support ownership management and SELinux relabeling.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CinderVolumeSource
    {
        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }

        /// <summary>
        /// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }

        /// <summary>
        /// Optional: points to a secret object containing parameters used to connect to OpenStack.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secretRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LocalObjectReference SecretRef { get; set; }

        /// <summary>
        /// volume id used to identify the volume in cinder. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeID", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string VolumeID { get; set; }

    }

    /// <summary>
    /// ConfigMapEnvSource selects a ConfigMap to populate the environment variables with.
    /// <br/>
    /// <br/>The contents of the target ConfigMap's Data field will represent the key-value pairs as environment variables.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConfigMapEnvSource
    {
        /// <summary>
        /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Specify whether the ConfigMap must be defined
        /// </summary>
        [Newtonsoft.Json.JsonProperty("optional", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Optional { get; set; }

    }

    /// <summary>
    /// Selects a key from a ConfigMap.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConfigMapKeySelector
    {
        /// <summary>
        /// The key to select.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Key { get; set; }

        /// <summary>
        /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Specify whether the ConfigMap or its key must be defined
        /// </summary>
        [Newtonsoft.Json.JsonProperty("optional", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Optional { get; set; }

    }

    /// <summary>
    /// Adapts a ConfigMap into a projected volume.
    /// <br/>
    /// <br/>The contents of the target ConfigMap's Data field will be presented in a projected volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. Note that this is identical to a configmap volume source without the default mode.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConfigMapProjection
    {
        /// <summary>
        /// If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyToPath> Items { get; set; }

        /// <summary>
        /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Specify whether the ConfigMap or its keys must be defined
        /// </summary>
        [Newtonsoft.Json.JsonProperty("optional", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Optional { get; set; }

    }

    /// <summary>
    /// Adapts a ConfigMap into a volume.
    /// <br/>
    /// <br/>The contents of the target ConfigMap's Data field will be presented in a volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. ConfigMap volumes support ownership management and SELinux relabeling.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ConfigMapVolumeSource
    {
        /// <summary>
        /// Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("defaultMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? DefaultMode { get; set; }

        /// <summary>
        /// If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyToPath> Items { get; set; }

        /// <summary>
        /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Specify whether the ConfigMap or its keys must be defined
        /// </summary>
        [Newtonsoft.Json.JsonProperty("optional", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Optional { get; set; }

    }

    /// <summary>
    /// A single application container that you want to run within a pod.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Container2
    {
        /// <summary>
        /// Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// </summary>
        [Newtonsoft.Json.JsonProperty("args", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Args { get; set; }

        /// <summary>
        /// Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
        /// </summary>
        [Newtonsoft.Json.JsonProperty("command", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Command { get; set; }

        /// <summary>
        /// List of environment variables to set in the container. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("env", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<EnvVar> Env { get; set; }

        /// <summary>
        /// List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("envFrom", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<EnvFromSource> EnvFrom { get; set; }

        /// <summary>
        /// Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("image", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Image { get; set; }

        /// <summary>
        /// Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
        /// <br/>
        /// <br/>Possible enum values:
        /// <br/> - `"Always"` means that kubelet always attempts to pull the latest image. Container will fail If the pull fails.
        /// <br/> - `"IfNotPresent"` means that kubelet pulls if the image isn't present on disk. Container will fail if the image isn't present and the pull fails.
        /// <br/> - `"Never"` means that kubelet never pulls an image, but only uses a local image. Container will fail if the image isn't present
        /// </summary>
        [Newtonsoft.Json.JsonProperty("imagePullPolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Container2ImagePullPolicy? ImagePullPolicy { get; set; }

        /// <summary>
        /// Actions that the management system should take in response to container lifecycle events. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lifecycle", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Lifecycle Lifecycle { get; set; }

        /// <summary>
        /// Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
        [Newtonsoft.Json.JsonProperty("livenessProbe", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Probe LivenessProbe { get; set; }

        /// <summary>
        /// Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ports", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ContainerPort> Ports { get; set; }

        /// <summary>
        /// Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readinessProbe", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Probe ReadinessProbe { get; set; }

        /// <summary>
        /// Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceRequirements Resources { get; set; }

        /// <summary>
        /// SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
        /// </summary>
        [Newtonsoft.Json.JsonProperty("securityContext", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecurityContext SecurityContext { get; set; }

        /// <summary>
        /// StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
        [Newtonsoft.Json.JsonProperty("startupProbe", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Probe StartupProbe { get; set; }

        /// <summary>
        /// Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stdin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Stdin { get; set; }

        /// <summary>
        /// Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
        /// </summary>
        [Newtonsoft.Json.JsonProperty("stdinOnce", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? StdinOnce { get; set; }

        /// <summary>
        /// Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("terminationMessagePath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TerminationMessagePath { get; set; }

        /// <summary>
        /// Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
        /// <br/>
        /// <br/>Possible enum values:
        /// <br/> - `"FallbackToLogsOnError"` will read the most recent contents of the container logs for the container status message when the container exits with an error and the terminationMessagePath has no contents.
        /// <br/> - `"File"` is the default behavior and will set the container status message to the contents of the container's terminationMessagePath when the container exits.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("terminationMessagePolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Container2TerminationMessagePolicy? TerminationMessagePolicy { get; set; }

        /// <summary>
        /// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tty", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Tty { get; set; }

        /// <summary>
        /// volumeDevices is the list of block devices to be used by the container.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeDevices", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<VolumeDevice> VolumeDevices { get; set; }

        /// <summary>
        /// Pod volumes to mount into the container's filesystem. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeMounts", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<VolumeMount> VolumeMounts { get; set; }

        /// <summary>
        /// Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("workingDir", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string WorkingDir { get; set; }

    }

    /// <summary>
    /// ContainerPort represents a network port in a single container.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ContainerPort
    {
        /// <summary>
        /// Number of port to expose on the pod's IP address. This must be a valid port number, 0 &lt; x &lt; 65536.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("containerPort", Required = Newtonsoft.Json.Required.Always)]
        public int ContainerPort1 { get; set; }

        /// <summary>
        /// What host IP to bind the external port to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hostIP", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string HostIP { get; set; }

        /// <summary>
        /// Number of port to expose on the host. If specified, this must be a valid port number, 0 &lt; x &lt; 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hostPort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? HostPort { get; set; }

        /// <summary>
        /// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
        /// <br/>
        /// <br/>Possible enum values:
        /// <br/> - `"SCTP"` is the SCTP protocol.
        /// <br/> - `"TCP"` is the TCP protocol.
        /// <br/> - `"UDP"` is the UDP protocol.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ContainerPortProtocol? Protocol { get; set; }

    }

    /// <summary>
    /// Represents downward API info for projecting into a projected volume. Note that this is identical to a downwardAPI volume source without the default mode.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DownwardAPIProjection
    {
        /// <summary>
        /// Items is a list of DownwardAPIVolume file
        /// </summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<DownwardAPIVolumeFile> Items { get; set; }

    }

    /// <summary>
    /// DownwardAPIVolumeFile represents information to create the file containing the pod field
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DownwardAPIVolumeFile
    {
        /// <summary>
        /// Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fieldRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ObjectFieldSelector FieldRef { get; set; }

        /// <summary>
        /// Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Mode { get; set; }

        /// <summary>
        /// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
        /// </summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Path { get; set; }

        /// <summary>
        /// Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourceFieldRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceFieldSelector ResourceFieldRef { get; set; }

    }

    /// <summary>
    /// DownwardAPIVolumeSource represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DownwardAPIVolumeSource
    {
        /// <summary>
        /// Optional: mode bits to use on created files by default. Must be a Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("defaultMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? DefaultMode { get; set; }

        /// <summary>
        /// Items is a list of downward API volume file
        /// </summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<DownwardAPIVolumeFile> Items { get; set; }

    }

    /// <summary>
    /// Represents an empty directory for a pod. Empty directory volumes support ownership management and SELinux relabeling.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EmptyDirVolumeSource
    {
        /// <summary>
        /// What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
        /// </summary>
        [Newtonsoft.Json.JsonProperty("medium", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Medium { get; set; }

        /// <summary>
        /// Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sizeLimit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SizeLimit { get; set; }

    }

    /// <summary>
    /// EnvFromSource represents the source of a set of ConfigMaps
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EnvFromSource
    {
        /// <summary>
        /// The ConfigMap to select from
        /// </summary>
        [Newtonsoft.Json.JsonProperty("configMapRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConfigMapEnvSource ConfigMapRef { get; set; }

        /// <summary>
        /// An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("prefix", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Prefix { get; set; }

        /// <summary>
        /// The Secret to select from
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secretRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretEnvSource SecretRef { get; set; }

    }

    /// <summary>
    /// EnvVar represents an environment variable present in a Container.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EnvVar
    {
        /// <summary>
        /// Name of the environment variable. Must be a C_IDENTIFIER.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

        /// <summary>
        /// Source for the environment variable's value. Cannot be used if value is not empty.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("valueFrom", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EnvVarSource ValueFrom { get; set; }

    }

    /// <summary>
    /// EnvVarSource represents a source for the value of an EnvVar.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EnvVarSource
    {
        /// <summary>
        /// Selects a key of a ConfigMap.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("configMapKeyRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConfigMapKeySelector ConfigMapKeyRef { get; set; }

        /// <summary>
        /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['&lt;KEY&gt;']`, `metadata.annotations['&lt;KEY&gt;']`, spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fieldRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ObjectFieldSelector FieldRef { get; set; }

        /// <summary>
        /// Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourceFieldRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceFieldSelector ResourceFieldRef { get; set; }

        /// <summary>
        /// Selects a key of a secret in the pod's namespace
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secretKeyRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretKeySelector SecretKeyRef { get; set; }

    }

    /// <summary>
    /// Represents an ephemeral volume that is handled by a normal storage driver.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EphemeralVolumeSource
    {
        /// <summary>
        /// Will be used to create a stand-alone PVC to provision the volume. The pod in which this EphemeralVolumeSource is embedded will be the owner of the PVC, i.e. the PVC will be deleted together with the pod.  The name of the PVC will be `&lt;pod name&gt;-&lt;volume name&gt;` where `&lt;volume name&gt;` is the name from the `PodSpec.Volumes` array entry. Pod validation will reject the pod if the concatenated name is not valid for a PVC (for example, too long).
        /// <br/>
        /// <br/>An existing PVC with that name that is not owned by the pod will *not* be used for the pod to avoid using an unrelated volume by mistake. Starting the pod is then blocked until the unrelated PVC is removed. If such a pre-created PVC is meant to be used by the pod, the PVC has to updated with an owner reference to the pod once the pod exists. Normally this should not be necessary, but it may be useful when manually reconstructing a broken cluster.
        /// <br/>
        /// <br/>This field is read-only and no changes will be made by Kubernetes to the PVC after it has been created.
        /// <br/>
        /// <br/>Required, must not be nil.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeClaimTemplate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PersistentVolumeClaimTemplate VolumeClaimTemplate { get; set; }

    }

    /// <summary>
    /// Event is a report of an event somewhere in the cluster.  Events have a limited retention time and triggers and messages may evolve with time.  Event consumers should not rely on the timing of an event with a given Reason reflecting a consistent underlying trigger, or the continued existence of events with that Reason.  Events should be treated as informative, best-effort, supplemental data.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Event2
    {
        /// <summary>
        /// What action was taken/failed regarding to the Regarding object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("action", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Action { get; set; }

        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apiVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ApiVersion { get; set; }

        /// <summary>
        /// The number of times this event has occurred.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Count { get; set; }

        /// <summary>
        /// Time when this Event was first observed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("eventTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? EventTime { get; set; }

        /// <summary>
        /// The time at which the event was first recorded. (Time of server receipt is in TypeMeta.)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("firstTimestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? FirstTimestamp { get; set; }

        /// <summary>
        /// The object that this event is about.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("involvedObject", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ObjectReference InvolvedObject { get; set; } = new ObjectReference();

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kind { get; set; }

        /// <summary>
        /// The time at which the most recent occurrence of this event was recorded.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lastTimestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? LastTimestamp { get; set; }

        /// <summary>
        /// A human-readable description of the status of this operation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        /// <summary>
        /// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public ObjectMeta Metadata { get; set; } = new ObjectMeta();

        /// <summary>
        /// This should be a short, machine understandable string that gives the reason for the transition into the object's current status.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Reason { get; set; }

        /// <summary>
        /// Optional secondary object for more complex actions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("related", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ObjectReference Related { get; set; }

        /// <summary>
        /// Name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reportingComponent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ReportingComponent { get; set; }

        /// <summary>
        /// ID of the controller instance, e.g. `kubelet-xyzf`.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reportingInstance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ReportingInstance { get; set; }

        /// <summary>
        /// Data about the Event series this event represents or nil if it's a singleton Event.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("series", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSeries Series { get; set; }

        /// <summary>
        /// The component reporting this event. Should be a short machine understandable string.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("source", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSource2 Source { get; set; }

        /// <summary>
        /// Type of this event (Normal, Warning), new types could be added in the future
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    /// <summary>
    /// EventSeries contain information on series of events, i.e. thing that was/is happening continuously for some time.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EventSeries
    {
        /// <summary>
        /// Number of occurrences in this series up to the last heartbeat time
        /// </summary>
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Count { get; set; }

        /// <summary>
        /// Time of the last occurrence observed
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lastObservedTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? LastObservedTime { get; set; }

    }

    /// <summary>
    /// EventSource contains information for an event.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EventSource2
    {
        /// <summary>
        /// Component from which the event is generated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("component", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Component { get; set; }

        /// <summary>
        /// Node name on which the event is generated.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("host", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Host { get; set; }

    }

    /// <summary>
    /// ExecAction describes a "run in container" action.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ExecAction
    {
        /// <summary>
        /// Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("command", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Command { get; set; }

    }

    /// <summary>
    /// Represents a Fibre Channel volume. Fibre Channel volumes can only be mounted as read/write once. Fibre Channel volumes support ownership management and SELinux relabeling.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FCVolumeSource
    {
        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }

        /// <summary>
        /// Optional: FC target lun number
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lun", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Lun { get; set; }

        /// <summary>
        /// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }

        /// <summary>
        /// Optional: FC target worldwide names (WWNs)
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetWWNs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> TargetWWNs { get; set; }

        /// <summary>
        /// Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("wwids", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Wwids { get; set; }

    }

    /// <summary>
    /// FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FlexVolumeSource
    {
        /// <summary>
        /// Driver is the name of the driver to use for this volume.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("driver", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Driver { get; set; }

        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }

        /// <summary>
        /// Optional: Extra command options if any.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("options", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Options { get; set; }

        /// <summary>
        /// Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }

        /// <summary>
        /// Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secretRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LocalObjectReference SecretRef { get; set; }

    }

    /// <summary>
    /// Represents a Flocker volume mounted by the Flocker agent. One and only one of datasetName and datasetUUID should be set. Flocker volumes do not support ownership management or SELinux relabeling.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FlockerVolumeSource
    {
        /// <summary>
        /// Name of the dataset stored as metadata -&gt; name on the dataset for Flocker should be considered as deprecated
        /// </summary>
        [Newtonsoft.Json.JsonProperty("datasetName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DatasetName { get; set; }

        /// <summary>
        /// UUID of the dataset. This is unique identifier of a Flocker dataset
        /// </summary>
        [Newtonsoft.Json.JsonProperty("datasetUUID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DatasetUUID { get; set; }

    }

    /// <summary>
    /// Represents a Persistent Disk resource in Google Compute Engine.
    /// <br/>
    /// <br/>A GCE PD must exist before mounting to a container. The disk must also be in the same GCE project and zone as the kubelet. A GCE PD can only be mounted as read/write once or read-only many times. GCE PDs support ownership management and SELinux relabeling.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GCEPersistentDiskVolumeSource
    {
        /// <summary>
        /// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }

        /// <summary>
        /// The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// </summary>
        [Newtonsoft.Json.JsonProperty("partition", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Partition { get; set; }

        /// <summary>
        /// Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pdName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string PdName { get; set; }

        /// <summary>
        /// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GRPCAction
    {
        /// <summary>
        /// Port number of the gRPC service. Number must be in the range 1 to 65535.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Always)]
        public int Port { get; set; }

        /// <summary>
        /// Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
        /// <br/>
        /// <br/>If this is not specified, the default behavior is defined by gRPC.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("service", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Service { get; set; }

    }

    /// <summary>
    /// Represents a volume that is populated with the contents of a git repository. Git repo volumes do not support ownership management. Git repo volumes support SELinux relabeling.
    /// <br/>
    /// <br/>DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GitRepoVolumeSource
    {
        /// <summary>
        /// Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("directory", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Directory { get; set; }

        /// <summary>
        /// Repository URL
        /// </summary>
        [Newtonsoft.Json.JsonProperty("repository", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Repository { get; set; }

        /// <summary>
        /// Commit hash for the specified revision.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("revision", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Revision { get; set; }

    }

    /// <summary>
    /// Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not support ownership management or SELinux relabeling.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GlusterfsVolumeSource
    {
        /// <summary>
        /// EndpointsName is the endpoint name that details Glusterfs topology. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        /// </summary>
        [Newtonsoft.Json.JsonProperty("endpoints", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Endpoints { get; set; }

        /// <summary>
        /// Path is the Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        /// </summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Path { get; set; }

        /// <summary>
        /// ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }

    }

    /// <summary>
    /// HTTPGetAction describes an action based on HTTP Get requests.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HTTPGetAction
    {
        /// <summary>
        /// Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("host", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Host { get; set; }

        /// <summary>
        /// Custom headers to set in the request. HTTP allows repeated headers.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("httpHeaders", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<HTTPHeader3> HttpHeaders { get; set; }

        /// <summary>
        /// Path to access on the HTTP server.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Path { get; set; }

        /// <summary>
        /// Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Port { get; set; }

        /// <summary>
        /// Scheme to use for connecting to the host. Defaults to HTTP.
        /// <br/>
        /// <br/>Possible enum values:
        /// <br/> - `"HTTP"` means that the scheme used will be http://
        /// <br/> - `"HTTPS"` means that the scheme used will be https://
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scheme", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public HTTPGetActionScheme? Scheme { get; set; }

    }

    /// <summary>
    /// HTTPHeader describes a custom header to be used in HTTP probes
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HTTPHeader3
    {
        /// <summary>
        /// The header field name
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// The header field value
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    /// <summary>
    /// HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's hosts file.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HostAlias
    {
        /// <summary>
        /// Hostnames for the above IP address.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hostnames", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Hostnames { get; set; }

        /// <summary>
        /// IP address of the host file entry.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ip", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ip { get; set; }

    }

    /// <summary>
    /// Represents a host path mapped into a pod. Host path volumes do not support ownership management or SELinux relabeling.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HostPathVolumeSource
    {
        /// <summary>
        /// Path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        /// </summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Path { get; set; }

        /// <summary>
        /// Type for HostPath Volume Defaults to "" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    /// <summary>
    /// Represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI volumes support ownership management and SELinux relabeling.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ISCSIVolumeSource
    {
        /// <summary>
        /// whether support iSCSI Discovery CHAP authentication
        /// </summary>
        [Newtonsoft.Json.JsonProperty("chapAuthDiscovery", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ChapAuthDiscovery { get; set; }

        /// <summary>
        /// whether support iSCSI Session CHAP authentication
        /// </summary>
        [Newtonsoft.Json.JsonProperty("chapAuthSession", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ChapAuthSession { get; set; }

        /// <summary>
        /// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }

        /// <summary>
        /// Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface &lt;target portal&gt;:&lt;volume name&gt; will be created for the connection.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("initiatorName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string InitiatorName { get; set; }

        /// <summary>
        /// Target iSCSI Qualified Name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("iqn", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Iqn { get; set; }

        /// <summary>
        /// iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("iscsiInterface", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string IscsiInterface { get; set; }

        /// <summary>
        /// iSCSI Target Lun number.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lun", Required = Newtonsoft.Json.Required.Always)]
        public int Lun { get; set; }

        /// <summary>
        /// iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("portals", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Portals { get; set; }

        /// <summary>
        /// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }

        /// <summary>
        /// CHAP Secret for iSCSI target and initiator authentication
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secretRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LocalObjectReference SecretRef { get; set; }

        /// <summary>
        /// iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetPortal", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TargetPortal { get; set; }

    }

    /// <summary>
    /// Maps a string key to a path within a volume.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class KeyToPath
    {
        /// <summary>
        /// The key to project.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Key { get; set; }

        /// <summary>
        /// Optional: mode bits used to set permissions on this file. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Mode { get; set; }

        /// <summary>
        /// The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Path { get; set; }

    }

    /// <summary>
    /// Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Lifecycle
    {
        /// <summary>
        /// PostStart is called immediately after a container is created. If the handler fails, the container is terminated and restarted according to its restart policy. Other management of the container blocks until the hook completes. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        /// </summary>
        [Newtonsoft.Json.JsonProperty("postStart", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LifecycleHandler PostStart { get; set; }

        /// <summary>
        /// PreStop is called immediately before a container is terminated due to an API request or management event such as liveness/startup probe failure, preemption, resource contention, etc. The handler is not called if the container crashes or exits. The Pod's termination grace period countdown begins before the PreStop hook is executed. Regardless of the outcome of the handler, the container will eventually terminate within the Pod's termination grace period (unless delayed by finalizers). Other management of the container blocks until the hook completes or until the termination grace period is reached. More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preStop", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LifecycleHandler PreStop { get; set; }

    }

    /// <summary>
    /// LifecycleHandler defines a specific action that should be taken in a lifecycle hook. One and only one of the fields, except TCPSocket must be specified.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LifecycleHandler
    {
        /// <summary>
        /// Exec specifies the action to take.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ExecAction Exec { get; set; }

        /// <summary>
        /// HTTPGet specifies the http request to perform.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("httpGet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HTTPGetAction HttpGet { get; set; }

        /// <summary>
        /// Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept for the backward compatibility. There are no validation of this field and lifecycle hooks will fail in runtime when tcp handler is specified.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tcpSocket", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TCPSocketAction TcpSocket { get; set; }

    }

    /// <summary>
    /// LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LocalObjectReference
    {
        /// <summary>
        /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

    }

    /// <summary>
    /// Represents an NFS mount that lasts the lifetime of a pod. NFS volumes do not support ownership management or SELinux relabeling.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NFSVolumeSource
    {
        /// <summary>
        /// Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        /// </summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Path { get; set; }

        /// <summary>
        /// ReadOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }

        /// <summary>
        /// Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        /// </summary>
        [Newtonsoft.Json.JsonProperty("server", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Server { get; set; }

    }

    /// <summary>
    /// Node affinity is a group of node affinity scheduling rules.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NodeAffinity
    {
        /// <summary>
        /// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preferredDuringSchedulingIgnoredDuringExecution", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PreferredSchedulingTerm> PreferredDuringSchedulingIgnoredDuringExecution { get; set; }

        /// <summary>
        /// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("requiredDuringSchedulingIgnoredDuringExecution", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public NodeSelector RequiredDuringSchedulingIgnoredDuringExecution { get; set; }

    }

    /// <summary>
    /// A node selector represents the union of the results of one or more label queries over a set of nodes; that is, it represents the OR of the selectors represented by the node selector terms.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NodeSelector
    {
        /// <summary>
        /// Required. A list of node selector terms. The terms are ORed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nodeSelectorTerms", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<NodeSelectorTerm> NodeSelectorTerms { get; set; } = new System.Collections.ObjectModel.Collection<NodeSelectorTerm>();

    }

    /// <summary>
    /// A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NodeSelectorRequirement
    {
        /// <summary>
        /// The label key that the selector applies to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Key { get; set; }

        /// <summary>
        /// Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
        /// <br/>
        /// <br/>Possible enum values:
        /// <br/> - `"DoesNotExist"`
        /// <br/> - `"Exists"`
        /// <br/> - `"Gt"`
        /// <br/> - `"In"`
        /// <br/> - `"Lt"`
        /// <br/> - `"NotIn"`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("operator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public NodeSelectorRequirementOperator Operator { get; set; }

        /// <summary>
        /// An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("values", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Values { get; set; }

    }

    /// <summary>
    /// A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class NodeSelectorTerm
    {
        /// <summary>
        /// A list of node selector requirements by node's labels.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("matchExpressions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<NodeSelectorRequirement> MatchExpressions { get; set; }

        /// <summary>
        /// A list of node selector requirements by node's fields.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("matchFields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<NodeSelectorRequirement> MatchFields { get; set; }

    }

    /// <summary>
    /// ObjectFieldSelector selects an APIVersioned field of an object.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ObjectFieldSelector
    {
        /// <summary>
        /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apiVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ApiVersion { get; set; }

        /// <summary>
        /// Path of the field to select in the specified API version.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fieldPath", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string FieldPath { get; set; }

    }

    /// <summary>
    /// ObjectReference contains enough information to let you inspect or modify the referred object.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ObjectReference
    {
        /// <summary>
        /// API version of the referent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apiVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ApiVersion { get; set; }

        /// <summary>
        /// If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fieldPath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FieldPath { get; set; }

        /// <summary>
        /// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kind { get; set; }

        /// <summary>
        /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        /// </summary>
        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

        /// <summary>
        /// Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourceVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceVersion { get; set; }

        /// <summary>
        /// UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Uid { get; set; }

    }

    /// <summary>
    /// PersistentVolumeClaim is a user's request for and claim to a persistent volume
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PersistentVolumeClaim
    {
        /// <summary>
        /// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apiVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ApiVersion { get; set; }

        /// <summary>
        /// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Kind { get; set; }

        /// <summary>
        /// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ObjectMeta Metadata { get; set; }

        /// <summary>
        /// Spec defines the desired characteristics of a volume requested by a pod author. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
        /// </summary>
        [Newtonsoft.Json.JsonProperty("spec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PersistentVolumeClaimSpec Spec { get; set; }

        /// <summary>
        /// Status represents the current information/status of a persistent volume claim. Read-only. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PersistentVolumeClaimStatus Status { get; set; }

    }

    /// <summary>
    /// PersistentVolumeClaimCondition contails details about state of pvc
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PersistentVolumeClaimCondition
    {
        /// <summary>
        /// Last time we probed the condition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lastProbeTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? LastProbeTime { get; set; }

        /// <summary>
        /// Last time the condition transitioned from one status to another.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lastTransitionTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? LastTransitionTime { get; set; }

        /// <summary>
        /// Human-readable message indicating details about last transition.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        /// <summary>
        /// Unique, this should be a short, machine understandable string that gives the reason for condition's last transition. If it reports "ResizeStarted" that means the underlying persistent volume is being resized.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Reason { get; set; }

        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Status { get; set; }

        /// <summary>
        ///
        /// <br/>
        /// <br/>
        /// <br/>Possible enum values:
        /// <br/> - `"FileSystemResizePending"` - controller resize is finished and a file system resize is pending on node
        /// <br/> - `"Resizing"` - a user trigger resize of pvc has been started
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PersistentVolumeClaimConditionType Type { get; set; }

    }

    /// <summary>
    /// PersistentVolumeClaimSpec describes the common attributes of storage devices and allows a Source for provider-specific attributes
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PersistentVolumeClaimSpec
    {
        /// <summary>
        /// AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accessModes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> AccessModes { get; set; }

        /// <summary>
        /// This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dataSource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TypedLocalObjectReference DataSource { get; set; }

        /// <summary>
        /// Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef
        /// <br/>  allows any non-core object, as well as PersistentVolumeClaim objects.
        /// <br/>* While DataSource ignores disallowed values (dropping them), DataSourceRef
        /// <br/>  preserves all values, and generates an error if a disallowed value is
        /// <br/>  specified.
        /// <br/>(Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("dataSourceRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TypedLocalObjectReference DataSourceRef { get; set; }

        /// <summary>
        /// Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ResourceRequirements Resources { get; set; }

        /// <summary>
        /// A label query over volumes to consider for binding.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LabelSelector Selector { get; set; }

        /// <summary>
        /// Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
        /// </summary>
        [Newtonsoft.Json.JsonProperty("storageClassName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StorageClassName { get; set; }

        /// <summary>
        /// volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VolumeMode { get; set; }

        /// <summary>
        /// VolumeName is the binding reference to the PersistentVolume backing this claim.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VolumeName { get; set; }

    }

    /// <summary>
    /// PersistentVolumeClaimStatus is the current status of a persistent volume claim.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PersistentVolumeClaimStatus
    {
        /// <summary>
        /// AccessModes contains the actual access modes the volume backing the PVC has. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        /// </summary>
        [Newtonsoft.Json.JsonProperty("accessModes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> AccessModes { get; set; }

        /// <summary>
        /// The storage resource within AllocatedResources tracks the capacity allocated to a PVC. It may be larger than the actual capacity when a volume expansion operation is requested. For storage quota, the larger value from allocatedResources and PVC.spec.resources is used. If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation. If a volume expansion capacity request is lowered, allocatedResources is only lowered if there are no expansion operations in progress and if the actual volume capacity is equal or lower than the requested capacity. This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allocatedResources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> AllocatedResources { get; set; }

        /// <summary>
        /// Represents the actual resources of the underlying volume.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("capacity", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Capacity { get; set; }

        /// <summary>
        /// Current Condition of persistent volume claim. If underlying persistent volume is being resized then the Condition will be set to 'ResizeStarted'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("conditions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PersistentVolumeClaimCondition> Conditions { get; set; }

        /// <summary>
        /// Phase represents the current phase of PersistentVolumeClaim.
        /// <br/>
        /// <br/>Possible enum values:
        /// <br/> - `"Bound"` used for PersistentVolumeClaims that are bound
        /// <br/> - `"Lost"` used for PersistentVolumeClaims that lost their underlying PersistentVolume. The claim was bound to a PersistentVolume and this volume does not exist any longer and all data on it was lost.
        /// <br/> - `"Pending"` used for PersistentVolumeClaims that are not yet bound
        /// </summary>
        [Newtonsoft.Json.JsonProperty("phase", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PersistentVolumeClaimStatusPhase? Phase { get; set; }

        /// <summary>
        /// ResizeStatus stores status of resize operation. ResizeStatus is not set by default but when expansion is complete resizeStatus is set to empty string by resize controller or kubelet. This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resizeStatus", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResizeStatus { get; set; }

    }

    /// <summary>
    /// PersistentVolumeClaimTemplate is used to produce PersistentVolumeClaim objects as part of an EphemeralVolumeSource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PersistentVolumeClaimTemplate
    {
        /// <summary>
        /// May contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("metadata", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ObjectMeta Metadata { get; set; }

        /// <summary>
        /// The specification for the PersistentVolumeClaim. The entire content is copied unchanged into the PVC that gets created from this template. The same fields as in a PersistentVolumeClaim are also valid here.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("spec", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PersistentVolumeClaimSpec Spec { get; set; } = new PersistentVolumeClaimSpec();

    }

    /// <summary>
    /// PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace. This volume finds the bound PV and mounts that volume for the pod. A PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume that is owned by someone else (the system).
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PersistentVolumeClaimVolumeSource
    {
        /// <summary>
        /// ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
        /// </summary>
        [Newtonsoft.Json.JsonProperty("claimName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ClaimName { get; set; }

        /// <summary>
        /// Will force the ReadOnly setting in VolumeMounts. Default false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }

    }

    /// <summary>
    /// Represents a Photon Controller persistent disk resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PhotonPersistentDiskVolumeSource
    {
        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }

        /// <summary>
        /// ID that identifies Photon Controller persistent disk
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pdID", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string PdID { get; set; }

    }

    /// <summary>
    /// Pod affinity is a group of inter pod affinity scheduling rules.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PodAffinity
    {
        /// <summary>
        /// The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preferredDuringSchedulingIgnoredDuringExecution", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<WeightedPodAffinityTerm> PreferredDuringSchedulingIgnoredDuringExecution { get; set; }

        /// <summary>
        /// If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("requiredDuringSchedulingIgnoredDuringExecution", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PodAffinityTerm> RequiredDuringSchedulingIgnoredDuringExecution { get; set; }

    }

    /// <summary>
    /// Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key &lt;topologyKey&gt; matches that of any node on which a pod of the set of pods is running
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PodAffinityTerm
    {
        /// <summary>
        /// A label query over a set of resources, in this case pods.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("labelSelector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LabelSelector LabelSelector { get; set; }

        /// <summary>
        /// A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means "this pod's namespace". An empty selector ({}) matches all namespaces. This field is beta-level and is only honored when PodAffinityNamespaceSelector feature is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("namespaceSelector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LabelSelector NamespaceSelector { get; set; }

        /// <summary>
        /// namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means "this pod's namespace"
        /// </summary>
        [Newtonsoft.Json.JsonProperty("namespaces", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Namespaces { get; set; }

        /// <summary>
        /// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("topologyKey", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string TopologyKey { get; set; }

    }

    /// <summary>
    /// Pod anti affinity is a group of inter pod anti affinity scheduling rules.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PodAntiAffinity
    {
        /// <summary>
        /// The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preferredDuringSchedulingIgnoredDuringExecution", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<WeightedPodAffinityTerm> PreferredDuringSchedulingIgnoredDuringExecution { get; set; }

        /// <summary>
        /// If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("requiredDuringSchedulingIgnoredDuringExecution", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PodAffinityTerm> RequiredDuringSchedulingIgnoredDuringExecution { get; set; }

    }

    /// <summary>
    /// PodDNSConfig defines the DNS parameters of a pod in addition to those generated from DNSPolicy.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PodDNSConfig
    {
        /// <summary>
        /// A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nameservers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Nameservers { get; set; }

        /// <summary>
        /// A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("options", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<PodDNSConfigOption> Options { get; set; }

        /// <summary>
        /// A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("searches", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Searches { get; set; }

    }

    /// <summary>
    /// PodDNSConfigOption defines DNS resolver options of a pod.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PodDNSConfigOption
    {
        /// <summary>
        /// Required.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

    }

    /// <summary>
    /// PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PodSecurityContext
    {
        /// <summary>
        /// A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
        /// <br/>
        /// <br/>1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
        /// <br/>
        /// <br/>If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fsGroup", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? FsGroup { get; set; }

        /// <summary>
        /// fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fsGroupChangePolicy", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsGroupChangePolicy { get; set; }

        /// <summary>
        /// The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("runAsGroup", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? RunAsGroup { get; set; }

        /// <summary>
        /// Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("runAsNonRoot", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RunAsNonRoot { get; set; }

        /// <summary>
        /// The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("runAsUser", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? RunAsUser { get; set; }

        /// <summary>
        /// The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("seLinuxOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SELinuxOptions SeLinuxOptions { get; set; }

        /// <summary>
        /// The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("seccompProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SeccompProfile SeccompProfile { get; set; }

        /// <summary>
        /// A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container. Note that this field cannot be set when spec.os.name is windows.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("supplementalGroups", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<long> SupplementalGroups { get; set; }

        /// <summary>
        /// Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sysctls", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Sysctl> Sysctls { get; set; }

        /// <summary>
        /// The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("windowsOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WindowsSecurityContextOptions WindowsOptions { get; set; }

    }

    /// <summary>
    /// PortworxVolumeSource represents a Portworx volume resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PortworxVolumeSource
    {
        /// <summary>
        /// FSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }

        /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }

        /// <summary>
        /// VolumeID uniquely identifies a Portworx volume
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeID", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string VolumeID { get; set; }

    }

    /// <summary>
    /// An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PreferredSchedulingTerm
    {
        /// <summary>
        /// A node selector term, associated with the corresponding weight.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("preference", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public NodeSelectorTerm Preference { get; set; } = new NodeSelectorTerm();

        /// <summary>
        /// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("weight", Required = Newtonsoft.Json.Required.Always)]
        public int Weight { get; set; }

    }

    /// <summary>
    /// Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Probe
    {
        /// <summary>
        /// Exec specifies the action to take.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("exec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ExecAction Exec { get; set; }

        /// <summary>
        /// Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("failureThreshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? FailureThreshold { get; set; }

        /// <summary>
        /// GRPC specifies an action involving a GRPC port. This is an alpha field and requires enabling GRPCContainerProbe feature gate.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("grpc", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GRPCAction Grpc { get; set; }

        /// <summary>
        /// HTTPGet specifies the http request to perform.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("httpGet", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HTTPGetAction HttpGet { get; set; }

        /// <summary>
        /// Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
        [Newtonsoft.Json.JsonProperty("initialDelaySeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? InitialDelaySeconds { get; set; }

        /// <summary>
        /// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("periodSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? PeriodSeconds { get; set; }

        /// <summary>
        /// Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("successThreshold", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? SuccessThreshold { get; set; }

        /// <summary>
        /// TCPSocket specifies an action involving a TCP port.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tcpSocket", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TCPSocketAction TcpSocket { get; set; }

        /// <summary>
        /// Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate. Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("terminationGracePeriodSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? TerminationGracePeriodSeconds { get; set; }

        /// <summary>
        /// Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
        /// </summary>
        [Newtonsoft.Json.JsonProperty("timeoutSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? TimeoutSeconds { get; set; }

    }

    /// <summary>
    /// Represents a projected volume source
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ProjectedVolumeSource
    {
        /// <summary>
        /// Mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("defaultMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? DefaultMode { get; set; }

        /// <summary>
        /// list of volume projections
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sources", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<VolumeProjection> Sources { get; set; }

    }

    /// <summary>
    /// Represents a Quobyte mount that lasts the lifetime of a pod. Quobyte volumes do not support ownership management or SELinux relabeling.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class QuobyteVolumeSource
    {
        /// <summary>
        /// Group to map volume access to Default is no group
        /// </summary>
        [Newtonsoft.Json.JsonProperty("group", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group { get; set; }

        /// <summary>
        /// ReadOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }

        /// <summary>
        /// Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
        /// </summary>
        [Newtonsoft.Json.JsonProperty("registry", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Registry { get; set; }

        /// <summary>
        /// Tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tenant", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Tenant { get; set; }

        /// <summary>
        /// User to map volume access to Defaults to serivceaccount user
        /// </summary>
        [Newtonsoft.Json.JsonProperty("user", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string User { get; set; }

        /// <summary>
        /// Volume is a string that references an already created Quobyte volume by name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volume", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Volume { get; set; }

    }

    /// <summary>
    /// Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support ownership management and SELinux relabeling.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RBDVolumeSource
    {
        /// <summary>
        /// Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }

        /// <summary>
        /// The rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        [Newtonsoft.Json.JsonProperty("image", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Image { get; set; }

        /// <summary>
        /// Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        [Newtonsoft.Json.JsonProperty("keyring", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Keyring { get; set; }

        /// <summary>
        /// A collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        [Newtonsoft.Json.JsonProperty("monitors", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> Monitors { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>
        /// The rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        [Newtonsoft.Json.JsonProperty("pool", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Pool { get; set; }

        /// <summary>
        /// ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }

        /// <summary>
        /// SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secretRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LocalObjectReference SecretRef { get; set; }

        /// <summary>
        /// The rados user name. Default is admin. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
        /// </summary>
        [Newtonsoft.Json.JsonProperty("user", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string User { get; set; }

    }

    /// <summary>
    /// ResourceFieldSelector represents container resources (cpu, memory) and their output format
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ResourceFieldSelector
    {
        /// <summary>
        /// Container name: required for volumes, optional for env vars
        /// </summary>
        [Newtonsoft.Json.JsonProperty("containerName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ContainerName { get; set; }

        /// <summary>
        /// Specifies the output format of the exposed resources, defaults to "1"
        /// </summary>
        [Newtonsoft.Json.JsonProperty("divisor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Divisor { get; set; }

        /// <summary>
        /// Required: resource to select
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resource", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Resource { get; set; }

    }

    /// <summary>
    /// ResourceRequirements describes the compute resource requirements.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ResourceRequirements
    {
        /// <summary>
        /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        /// </summary>
        [Newtonsoft.Json.JsonProperty("limits", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Limits { get; set; }

        /// <summary>
        /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        /// </summary>
        [Newtonsoft.Json.JsonProperty("requests", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Requests { get; set; }

    }

    /// <summary>
    /// SELinuxOptions are the labels to be applied to the container
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SELinuxOptions
    {
        /// <summary>
        /// Level is SELinux level label that applies to the container.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("level", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Level { get; set; }

        /// <summary>
        /// Role is a SELinux role label that applies to the container.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("role", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Role { get; set; }

        /// <summary>
        /// Type is a SELinux type label that applies to the container.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

        /// <summary>
        /// User is a SELinux user label that applies to the container.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("user", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string User { get; set; }

    }

    /// <summary>
    /// ScaleIOVolumeSource represents a persistent ScaleIO volume
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ScaleIOVolumeSource
    {
        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }

        /// <summary>
        /// The host address of the ScaleIO API Gateway.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gateway", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Gateway { get; set; }

        /// <summary>
        /// The name of the ScaleIO Protection Domain for the configured storage.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protectionDomain", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProtectionDomain { get; set; }

        /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }

        /// <summary>
        /// SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secretRef", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public LocalObjectReference SecretRef { get; set; } = new LocalObjectReference();

        /// <summary>
        /// Flag to enable/disable SSL communication with Gateway, default false
        /// </summary>
        [Newtonsoft.Json.JsonProperty("sslEnabled", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? SslEnabled { get; set; }

        /// <summary>
        /// Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("storageMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StorageMode { get; set; }

        /// <summary>
        /// The ScaleIO Storage Pool associated with the protection domain.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("storagePool", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StoragePool { get; set; }

        /// <summary>
        /// The name of the storage system as configured in ScaleIO.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("system", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string System { get; set; }

        /// <summary>
        /// The name of a volume already created in the ScaleIO system that is associated with this volume source.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VolumeName { get; set; }

    }

    /// <summary>
    /// SeccompProfile defines a pod/container's seccomp profile settings. Only one profile source may be set.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SeccompProfile
    {
        /// <summary>
        /// localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is "Localhost".
        /// </summary>
        [Newtonsoft.Json.JsonProperty("localhostProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string LocalhostProfile { get; set; }

        /// <summary>
        /// type indicates which kind of seccomp profile will be applied. Valid options are:
        /// <br/>
        /// <br/>Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
        /// <br/>
        /// <br/>Possible enum values:
        /// <br/> - `"Localhost"` indicates a profile defined in a file on the node should be used. The file's location relative to &lt;kubelet-root-dir&gt;/seccomp.
        /// <br/> - `"RuntimeDefault"` represents the default container runtime seccomp profile.
        /// <br/> - `"Unconfined"` indicates no seccomp profile is applied (A.K.A. unconfined).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public SeccompProfileType Type { get; set; }

    }

    /// <summary>
    /// SecretEnvSource selects a Secret to populate the environment variables with.
    /// <br/>
    /// <br/>The contents of the target Secret's Data field will represent the key-value pairs as environment variables.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SecretEnvSource
    {
        /// <summary>
        /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Specify whether the Secret must be defined
        /// </summary>
        [Newtonsoft.Json.JsonProperty("optional", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Optional { get; set; }

    }

    /// <summary>
    /// SecretKeySelector selects a key of a Secret.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SecretKeySelector
    {
        /// <summary>
        /// The key of the secret to select from.  Must be a valid secret key.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Key { get; set; }

        /// <summary>
        /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Specify whether the Secret or its key must be defined
        /// </summary>
        [Newtonsoft.Json.JsonProperty("optional", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Optional { get; set; }

    }

    /// <summary>
    /// Adapts a secret into a projected volume.
    /// <br/>
    /// <br/>The contents of the target Secret's Data field will be presented in a projected volume as files using the keys in the Data field as the file names. Note that this is identical to a secret volume source without the default mode.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SecretProjection
    {
        /// <summary>
        /// If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyToPath> Items { get; set; }

        /// <summary>
        /// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Specify whether the Secret or its key must be defined
        /// </summary>
        [Newtonsoft.Json.JsonProperty("optional", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Optional { get; set; }

    }

    /// <summary>
    /// Adapts a Secret into a volume.
    /// <br/>
    /// <br/>The contents of the target Secret's Data field will be presented in a volume as files using the keys in the Data field as the file names. Secret volumes support ownership management and SELinux relabeling.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SecretVolumeSource
    {
        /// <summary>
        /// Optional: mode bits used to set permissions on created files by default. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("defaultMode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? DefaultMode { get; set; }

        /// <summary>
        /// If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("items", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<KeyToPath> Items { get; set; }

        /// <summary>
        /// Specify whether the Secret or its keys must be defined
        /// </summary>
        [Newtonsoft.Json.JsonProperty("optional", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Optional { get; set; }

        /// <summary>
        /// Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secretName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SecretName { get; set; }

    }

    /// <summary>
    /// SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext.  When both are set, the values in SecurityContext take precedence.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SecurityContext
    {
        /// <summary>
        /// AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN Note that this field cannot be set when spec.os.name is windows.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("allowPrivilegeEscalation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AllowPrivilegeEscalation { get; set; }

        /// <summary>
        /// The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime. Note that this field cannot be set when spec.os.name is windows.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("capabilities", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Capabilities Capabilities { get; set; }

        /// <summary>
        /// Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false. Note that this field cannot be set when spec.os.name is windows.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("privileged", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Privileged { get; set; }

        /// <summary>
        /// procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("procMount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ProcMount { get; set; }

        /// <summary>
        /// Whether this container has a read-only root filesystem. Default is false. Note that this field cannot be set when spec.os.name is windows.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readOnlyRootFilesystem", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnlyRootFilesystem { get; set; }

        /// <summary>
        /// The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("runAsGroup", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? RunAsGroup { get; set; }

        /// <summary>
        /// Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("runAsNonRoot", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? RunAsNonRoot { get; set; }

        /// <summary>
        /// The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("runAsUser", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? RunAsUser { get; set; }

        /// <summary>
        /// The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is windows.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("seLinuxOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SELinuxOptions SeLinuxOptions { get; set; }

        /// <summary>
        /// The seccomp options to use by this container. If seccomp options are provided at both the pod &amp; container level, the container options override the pod options. Note that this field cannot be set when spec.os.name is windows.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("seccompProfile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SeccompProfile SeccompProfile { get; set; }

        /// <summary>
        /// The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("windowsOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WindowsSecurityContextOptions WindowsOptions { get; set; }

    }

    /// <summary>
    /// ServiceAccountTokenProjection represents a projected service account token volume. This projection can be used to insert a service account token into the pods runtime filesystem for use against APIs (Kubernetes API Server or otherwise).
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ServiceAccountTokenProjection
    {
        /// <summary>
        /// Audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("audience", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Audience { get; set; }

        /// <summary>
        /// ExpirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("expirationSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ExpirationSeconds { get; set; }

        /// <summary>
        /// Path is the path relative to the mount point of the file to project the token into.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("path", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Path { get; set; }

    }

    /// <summary>
    /// ServicePort contains information on service's port.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ServicePort
    {
        /// <summary>
        /// The application protocol for this port. This field follows standard Kubernetes label syntax. Un-prefixed names are reserved for IANA standard service names (as per RFC-6335 and http://www.iana.org/assignments/service-names). Non-standard protocols should use prefixed names such as mycompany.com/my-custom-protocol.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("appProtocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AppProtocol { get; set; }

        /// <summary>
        /// The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. When considering the endpoints for a Service, this must match the 'name' field in the EndpointPort. Optional if only one ServicePort is defined on this service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// The port on each node on which this service is exposed when type is NodePort or LoadBalancer.  Usually assigned by the system. If a value is specified, in-range, and not in use it will be used, otherwise the operation will fail.  If not specified, a port will be allocated if this Service requires one.  If this field is specified when creating a Service which does not need it, creation will fail. This field will be wiped when updating a Service to no longer need it (e.g. changing type from NodePort to ClusterIP). More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nodePort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? NodePort { get; set; }

        /// <summary>
        /// The port that will be exposed by this service.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Always)]
        public int Port { get; set; }

        /// <summary>
        /// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.
        /// <br/>
        /// <br/>Possible enum values:
        /// <br/> - `"SCTP"` is the SCTP protocol.
        /// <br/> - `"TCP"` is the TCP protocol.
        /// <br/> - `"UDP"` is the UDP protocol.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("protocol", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ServicePortProtocol? Protocol { get; set; }

        /// <summary>
        /// Number or name of the port to access on the pods targeted by the service. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME. If this is a string, it will be looked up as a named port in the target Pod's container ports. If this is not specified, the value of the 'port' field is used (an identity map). This field is ignored for services with clusterIP=None, and should be omitted or set equal to the 'port' field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
        /// </summary>
        [Newtonsoft.Json.JsonProperty("targetPort", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TargetPort { get; set; }

    }

    /// <summary>
    /// Represents a StorageOS persistent volume resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StorageOSVolumeSource
    {
        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }

        /// <summary>
        /// Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }

        /// <summary>
        /// SecretRef specifies the secret to use for obtaining the StorageOS API credentials.  If not specified, default values will be attempted.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secretRef", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LocalObjectReference SecretRef { get; set; }

        /// <summary>
        /// VolumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VolumeName { get; set; }

        /// <summary>
        /// VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to "default" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumeNamespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string VolumeNamespace { get; set; }

    }

    /// <summary>
    /// Sysctl defines a kernel parameter to be set
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Sysctl
    {
        /// <summary>
        /// Name of a property to set
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Value of a property to set
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

    }

    /// <summary>
    /// TCPSocketAction describes an action based on opening a socket
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TCPSocketAction
    {
        /// <summary>
        /// Optional: Host name to connect to, defaults to the pod IP.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("host", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Host { get; set; }

        /// <summary>
        /// Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("port", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Port { get; set; }

    }

    /// <summary>
    /// The pod this Toleration is attached to tolerates any taint that matches the triple &lt;key,value,effect&gt; using the matching operator &lt;operator&gt;.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Toleration
    {
        /// <summary>
        /// Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        /// <br/>
        /// <br/>Possible enum values:
        /// <br/> - `"NoExecute"` Evict any already-running pods that do not tolerate the taint. Currently enforced by NodeController.
        /// <br/> - `"NoSchedule"` Do not allow new pods to schedule onto the node unless they tolerate the taint, but allow all pods submitted to Kubelet without going through the scheduler to start, and allow all already-running pods to continue running. Enforced by the scheduler.
        /// <br/> - `"PreferNoSchedule"` Like TaintEffectNoSchedule, but the scheduler tries not to schedule new pods onto the node, rather than prohibiting new pods from scheduling onto the node entirely. Enforced by the scheduler.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("effect", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TolerationEffect? Effect { get; set; }

        /// <summary>
        /// Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Key { get; set; }

        /// <summary>
        /// Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
        /// <br/>
        /// <br/>Possible enum values:
        /// <br/> - `"Equal"`
        /// <br/> - `"Exists"`
        /// </summary>
        [Newtonsoft.Json.JsonProperty("operator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TolerationOperator? Operator { get; set; }

        /// <summary>
        /// TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("tolerationSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? TolerationSeconds { get; set; }

        /// <summary>
        /// Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

    }

    /// <summary>
    /// TypedLocalObjectReference contains enough information to let you locate the typed referenced object inside the same namespace.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TypedLocalObjectReference
    {
        /// <summary>
        /// APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apiGroup", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ApiGroup { get; set; }

        /// <summary>
        /// Kind is the type of resource being referenced
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Kind { get; set; }

        /// <summary>
        /// Name is the name of resource being referenced
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

    }

    /// <summary>
    /// Volume represents a named volume in a pod that may be accessed by any container in the pod.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Volume
    {
        /// <summary>
        /// AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
        /// </summary>
        [Newtonsoft.Json.JsonProperty("awsElasticBlockStore", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AWSElasticBlockStoreVolumeSource AwsElasticBlockStore { get; set; }

        /// <summary>
        /// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("azureDisk", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AzureDiskVolumeSource AzureDisk { get; set; }

        /// <summary>
        /// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("azureFile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public AzureFileVolumeSource AzureFile { get; set; }

        /// <summary>
        /// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cephfs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CephFSVolumeSource Cephfs { get; set; }

        /// <summary>
        /// Cinder represents a cinder volume attached and mounted on kubelets host machine. More info: https://examples.k8s.io/mysql-cinder-pd/README.md
        /// </summary>
        [Newtonsoft.Json.JsonProperty("cinder", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CinderVolumeSource Cinder { get; set; }

        /// <summary>
        /// ConfigMap represents a configMap that should populate this volume
        /// </summary>
        [Newtonsoft.Json.JsonProperty("configMap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConfigMapVolumeSource ConfigMap { get; set; }

        /// <summary>
        /// CSI (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("csi", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CSIVolumeSource Csi { get; set; }

        /// <summary>
        /// DownwardAPI represents downward API about the pod that should populate this volume
        /// </summary>
        [Newtonsoft.Json.JsonProperty("downwardAPI", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DownwardAPIVolumeSource DownwardAPI { get; set; }

        /// <summary>
        /// EmptyDir represents a temporary directory that shares a pod's lifetime. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
        /// </summary>
        [Newtonsoft.Json.JsonProperty("emptyDir", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EmptyDirVolumeSource EmptyDir { get; set; }

        /// <summary>
        /// Ephemeral represents a volume that is handled by a cluster storage driver. The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts, and deleted when the pod is removed.
        /// <br/>
        /// <br/>Use this if: a) the volume is only needed while the pod runs, b) features of normal volumes like restoring from snapshot or capacity
        /// <br/>   tracking are needed,
        /// <br/>c) the storage driver is specified through a storage class, and d) the storage driver supports dynamic volume provisioning through
        /// <br/>   a PersistentVolumeClaim (see EphemeralVolumeSource for more
        /// <br/>   information on the connection between this volume type
        /// <br/>   and PersistentVolumeClaim).
        /// <br/>
        /// <br/>Use PersistentVolumeClaim or one of the vendor-specific APIs for volumes that persist for longer than the lifecycle of an individual pod.
        /// <br/>
        /// <br/>Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to be used that way - see the documentation of the driver for more information.
        /// <br/>
        /// <br/>A pod can use both types of ephemeral volumes and persistent volumes at the same time.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ephemeral", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EphemeralVolumeSource Ephemeral { get; set; }

        /// <summary>
        /// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fc", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FCVolumeSource Fc { get; set; }

        /// <summary>
        /// FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("flexVolume", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FlexVolumeSource FlexVolume { get; set; }

        /// <summary>
        /// Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
        /// </summary>
        [Newtonsoft.Json.JsonProperty("flocker", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FlockerVolumeSource Flocker { get; set; }

        /// <summary>
        /// GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gcePersistentDisk", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GCEPersistentDiskVolumeSource GcePersistentDisk { get; set; }

        /// <summary>
        /// GitRepo represents a git repository at a particular revision. DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gitRepo", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GitRepoVolumeSource GitRepo { get; set; }

        /// <summary>
        /// Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/glusterfs/README.md
        /// </summary>
        [Newtonsoft.Json.JsonProperty("glusterfs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public GlusterfsVolumeSource Glusterfs { get; set; }

        /// <summary>
        /// HostPath represents a pre-existing file or directory on the host machine that is directly exposed to the container. This is generally used for system agents or other privileged things that are allowed to see the host machine. Most containers will NOT need this. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hostPath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public HostPathVolumeSource HostPath { get; set; }

        /// <summary>
        /// ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://examples.k8s.io/volumes/iscsi/README.md
        /// </summary>
        [Newtonsoft.Json.JsonProperty("iscsi", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ISCSIVolumeSource Iscsi { get; set; }

        /// <summary>
        /// Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// NFS represents an NFS mount on the host that shares a pod's lifetime More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
        /// </summary>
        [Newtonsoft.Json.JsonProperty("nfs", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public NFSVolumeSource Nfs { get; set; }

        /// <summary>
        /// PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
        /// </summary>
        [Newtonsoft.Json.JsonProperty("persistentVolumeClaim", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PersistentVolumeClaimVolumeSource PersistentVolumeClaim { get; set; }

        /// <summary>
        /// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
        /// </summary>
        [Newtonsoft.Json.JsonProperty("photonPersistentDisk", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PhotonPersistentDiskVolumeSource PhotonPersistentDisk { get; set; }

        /// <summary>
        /// PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
        /// </summary>
        [Newtonsoft.Json.JsonProperty("portworxVolume", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PortworxVolumeSource PortworxVolume { get; set; }

        /// <summary>
        /// Items for all in one resources secrets, configmaps, and downward API
        /// </summary>
        [Newtonsoft.Json.JsonProperty("projected", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProjectedVolumeSource Projected { get; set; }

        /// <summary>
        /// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
        /// </summary>
        [Newtonsoft.Json.JsonProperty("quobyte", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public QuobyteVolumeSource Quobyte { get; set; }

        /// <summary>
        /// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://examples.k8s.io/volumes/rbd/README.md
        /// </summary>
        [Newtonsoft.Json.JsonProperty("rbd", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public RBDVolumeSource Rbd { get; set; }

        /// <summary>
        /// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("scaleIO", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ScaleIOVolumeSource ScaleIO { get; set; }

        /// <summary>
        /// Secret represents a secret that should populate this volume. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretVolumeSource Secret { get; set; }

        /// <summary>
        /// StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("storageos", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StorageOSVolumeSource Storageos { get; set; }

        /// <summary>
        /// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
        /// </summary>
        [Newtonsoft.Json.JsonProperty("vsphereVolume", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public VsphereVirtualDiskVolumeSource VsphereVolume { get; set; }

    }

    /// <summary>
    /// volumeDevice describes a mapping of a raw block device within a container.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class VolumeDevice
    {
        /// <summary>
        /// devicePath is the path inside of the container that the device will be mapped to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("devicePath", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string DevicePath { get; set; }

        /// <summary>
        /// name must match the name of a persistentVolumeClaim in the pod
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

    }

    /// <summary>
    /// VolumeMount describes a mounting of a Volume within a container.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class VolumeMount
    {
        /// <summary>
        /// Path within the container at which the volume should be mounted.  Must not contain ':'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mountPath", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string MountPath { get; set; }

        /// <summary>
        /// mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("mountPropagation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MountPropagation { get; set; }

        /// <summary>
        /// This must match the Name of a Volume.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("readOnly", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? ReadOnly { get; set; }

        /// <summary>
        /// Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subPath", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SubPath { get; set; }

        /// <summary>
        /// Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subPathExpr", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SubPathExpr { get; set; }

    }

    /// <summary>
    /// Projection that may be projected along with other supported volume types
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class VolumeProjection
    {
        /// <summary>
        /// information about the configMap data to project
        /// </summary>
        [Newtonsoft.Json.JsonProperty("configMap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ConfigMapProjection ConfigMap { get; set; }

        /// <summary>
        /// information about the downwardAPI data to project
        /// </summary>
        [Newtonsoft.Json.JsonProperty("downwardAPI", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public DownwardAPIProjection DownwardAPI { get; set; }

        /// <summary>
        /// information about the secret data to project
        /// </summary>
        [Newtonsoft.Json.JsonProperty("secret", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SecretProjection Secret { get; set; }

        /// <summary>
        /// information about the serviceAccountToken data to project
        /// </summary>
        [Newtonsoft.Json.JsonProperty("serviceAccountToken", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ServiceAccountTokenProjection ServiceAccountToken { get; set; }

    }

    /// <summary>
    /// Represents a vSphere volume resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class VsphereVirtualDiskVolumeSource
    {
        /// <summary>
        /// Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FsType { get; set; }

        /// <summary>
        /// Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("storagePolicyID", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StoragePolicyID { get; set; }

        /// <summary>
        /// Storage Policy Based Management (SPBM) profile name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("storagePolicyName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StoragePolicyName { get; set; }

        /// <summary>
        /// Path that identifies vSphere volume vmdk
        /// </summary>
        [Newtonsoft.Json.JsonProperty("volumePath", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string VolumePath { get; set; }

    }

    /// <summary>
    /// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WeightedPodAffinityTerm
    {
        /// <summary>
        /// Required. A pod affinity term, associated with the corresponding weight.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("podAffinityTerm", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public PodAffinityTerm PodAffinityTerm { get; set; } = new PodAffinityTerm();

        /// <summary>
        /// weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("weight", Required = Newtonsoft.Json.Required.Always)]
        public int Weight { get; set; }

    }

    /// <summary>
    /// WindowsSecurityContextOptions contain Windows-specific options and credentials.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class WindowsSecurityContextOptions
    {
        /// <summary>
        /// GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gmsaCredentialSpec", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GmsaCredentialSpec { get; set; }

        /// <summary>
        /// GMSACredentialSpecName is the name of the GMSA credential spec to use.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("gmsaCredentialSpecName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GmsaCredentialSpecName { get; set; }

        /// <summary>
        /// HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).  In addition, if HostProcess is true then HostNetwork must also be set to true.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("hostProcess", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? HostProcess { get; set; }

        /// <summary>
        /// The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("runAsUserName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string RunAsUserName { get; set; }

    }

    /// <summary>
    /// PodDisruptionBudgetSpec is a description of a PodDisruptionBudget.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PodDisruptionBudgetSpec
    {
        /// <summary>
        /// An eviction is allowed if at most "maxUnavailable" pods selected by "selector" are unavailable after the eviction, i.e. even in absence of the evicted pod. For example, one can prevent all voluntary evictions by specifying 0. This is a mutually exclusive setting with "minAvailable".
        /// </summary>
        [Newtonsoft.Json.JsonProperty("maxUnavailable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MaxUnavailable { get; set; }

        /// <summary>
        /// An eviction is allowed if at least "minAvailable" pods selected by "selector" will still be available after the eviction, i.e. even in the absence of the evicted pod.  So for example you can prevent all voluntary evictions by specifying "100%".
        /// </summary>
        [Newtonsoft.Json.JsonProperty("minAvailable", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string MinAvailable { get; set; }

        /// <summary>
        /// Label query over pods whose evictions are managed by the disruption budget. A null selector selects no pods. An empty selector ({}) also selects no pods, which differs from standard behavior of selecting all pods. In policy/v1, an empty selector will select all pods in the namespace.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selector", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LabelSelector Selector { get; set; }

    }

    /// <summary>
    /// Condition contains details for one aspect of the current state of this API Resource.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Condition3
    {
        /// <summary>
        /// lastTransitionTime is the last time the condition transitioned from one status to another. This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("lastTransitionTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset LastTransitionTime { get; set; }

        /// <summary>
        /// message is a human readable message indicating details about the transition. This may be an empty string.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Message { get; set; }

        /// <summary>
        /// observedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("observedGeneration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? ObservedGeneration { get; set; }

        /// <summary>
        /// reason contains a programmatic identifier indicating the reason for the condition's last transition. Producers of specific condition types may define expected values and meanings for this field, and whether the values are considered a guaranteed API. The value should be a CamelCase string. This field may not be empty.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reason", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Reason { get; set; }

        /// <summary>
        /// status of the condition, one of True, False, Unknown.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Status { get; set; }

        /// <summary>
        /// type of condition in CamelCase or in foo.example.com/CamelCase.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }

    }

    /// <summary>
    /// CreateOptions may be provided when creating an API object.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CreateOptions
    {
        [Newtonsoft.Json.JsonProperty("dryRun", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> DryRun { get; set; }

        [Newtonsoft.Json.JsonProperty("fieldManager", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FieldManager { get; set; }

        [Newtonsoft.Json.JsonProperty("fieldValidation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FieldValidation { get; set; }

    }

    /// <summary>
    /// Duration is a wrapper around time.Duration which supports correct
    /// <br/>marshaling to YAML and JSON. In particular, it marshals into strings, which
    /// <br/>can be used as map keys in json.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Duration
    {
        [Newtonsoft.Json.JsonProperty("duration", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Duration1 { get; set; }

    }

    /// <summary>
    /// FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.
    /// <br/>
    /// <br/>Each key is either a '.' representing the field itself, and will always map to an empty set, or a string representing a sub-field or item. The string will follow one of these four formats: 'f:&lt;name&gt;', where &lt;name&gt; is the name of a field in a struct, or key in a map 'v:&lt;value&gt;', where &lt;value&gt; is the exact json formatted value of a list item 'i:&lt;index&gt;', where &lt;index&gt; is position of a item in a list 'k:&lt;keys&gt;', where &lt;keys&gt; is a map of  a list item's key fields to their unique values If a key maps to an empty Fields value, the field that key represents is part of the set.
    /// <br/>
    /// <br/>The exact format is defined in sigs.k8s.io/structured-merge-diff
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class FieldsV1
    {

    }

    /// <summary>
    /// +protobuf.options.(gogoproto.goproto_stringer)=false
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class GroupVersionResource
    {
        [Newtonsoft.Json.JsonProperty("group", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Group { get; set; }

        [Newtonsoft.Json.JsonProperty("resource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Resource { get; set; }

        [Newtonsoft.Json.JsonProperty("version", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Version { get; set; }

    }

    /// <summary>
    /// A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LabelSelector
    {
        /// <summary>
        /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("matchExpressions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<LabelSelectorRequirement> MatchExpressions { get; set; }

        /// <summary>
        /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("matchLabels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> MatchLabels { get; set; }

    }

    /// <summary>
    /// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LabelSelectorRequirement
    {
        /// <summary>
        /// key is the label key that the selector applies to.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("key", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Key { get; set; }

        /// <summary>
        /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("operator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Operator { get; set; }

        /// <summary>
        /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("values", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Values { get; set; }

    }

    /// <summary>
    /// ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ListMeta
    {
        /// <summary>
        /// continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("continue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Continue { get; set; }

        /// <summary>
        /// remainingItemCount is the number of subsequent items in the list which are not included in this list response. If the list request contained label or field selectors, then the number of remaining items is unknown and the field will be left unset and omitted during serialization. If the list is complete (either because it is not chunking or because this is the last chunk), then there are no more remaining items and this field will be left unset and omitted during serialization. Servers older than v1.15 do not set this field. The intended use of the remainingItemCount is *estimating* the size of a collection. Clients should not rely on the remainingItemCount to be set or to be exact.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("remainingItemCount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? RemainingItemCount { get; set; }

        /// <summary>
        /// String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourceVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceVersion { get; set; }

        /// <summary>
        /// selfLink is a URL representing this object. Populated by the system. Read-only.
        /// <br/>
        /// <br/>DEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selfLink", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SelfLink { get; set; }

    }

    /// <summary>
    /// ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ManagedFieldsEntry
    {
        /// <summary>
        /// APIVersion defines the version of this resource that this field set applies to. The format is "group/version" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apiVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ApiVersion { get; set; }

        /// <summary>
        /// FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: "FieldsV1"
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fieldsType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FieldsType { get; set; }

        /// <summary>
        /// FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("fieldsV1", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FieldsV1 FieldsV1 { get; set; }

        /// <summary>
        /// Manager is an identifier of the workflow managing these fields.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("manager", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Manager { get; set; }

        /// <summary>
        /// Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("operation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Operation { get; set; }

        /// <summary>
        /// Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("subresource", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Subresource { get; set; }

        /// <summary>
        /// Time is timestamp of when these fields were set. It should always be empty if Operation is 'Apply'
        /// </summary>
        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Time { get; set; }

    }

    /// <summary>
    /// ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ObjectMeta
    {
        /// <summary>
        /// Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
        /// </summary>
        [Newtonsoft.Json.JsonProperty("annotations", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Annotations { get; set; }

        /// <summary>
        /// The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("clusterName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ClusterName { get; set; }

        /// <summary>
        /// CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.
        /// <br/>
        /// <br/>Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Newtonsoft.Json.JsonProperty("creationTimestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? CreationTimestamp { get; set; }

        /// <summary>
        /// Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("deletionGracePeriodSeconds", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? DeletionGracePeriodSeconds { get; set; }

        /// <summary>
        /// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.
        /// <br/>
        /// <br/>Populated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        /// </summary>
        [Newtonsoft.Json.JsonProperty("deletionTimestamp", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? DeletionTimestamp { get; set; }

        /// <summary>
        /// Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("finalizers", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Finalizers { get; set; }

        /// <summary>
        /// GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
        /// <br/>
        /// <br/>If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
        /// <br/>
        /// <br/>Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
        /// </summary>
        [Newtonsoft.Json.JsonProperty("generateName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GenerateName { get; set; }

        /// <summary>
        /// A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("generation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Generation { get; set; }

        /// <summary>
        /// Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
        /// </summary>
        [Newtonsoft.Json.JsonProperty("labels", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.IDictionary<string, string> Labels { get; set; }

        /// <summary>
        /// ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like "ci-cd". The set of fields is always in the version that the workflow used when modifying the object.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("managedFields", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<ManagedFieldsEntry> ManagedFields { get; set; }

        /// <summary>
        /// Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        /// <summary>
        /// Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
        /// <br/>
        /// <br/>Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
        /// </summary>
        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

        /// <summary>
        /// List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("ownerReferences", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OwnerReference> OwnerReferences { get; set; }

        /// <summary>
        /// An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.
        /// <br/>
        /// <br/>Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        /// </summary>
        [Newtonsoft.Json.JsonProperty("resourceVersion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ResourceVersion { get; set; }

        /// <summary>
        /// SelfLink is a URL representing this object. Populated by the system. Read-only.
        /// <br/>
        /// <br/>DEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("selfLink", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SelfLink { get; set; }

        /// <summary>
        /// UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
        /// <br/>
        /// <br/>Populated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uid", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Uid { get; set; }

    }

    /// <summary>
    /// OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class OwnerReference
    {
        /// <summary>
        /// API version of the referent.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("apiVersion", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string ApiVersion { get; set; }

        /// <summary>
        /// If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("blockOwnerDeletion", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? BlockOwnerDeletion { get; set; }

        /// <summary>
        /// If true, this reference points to the managing controller.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("controller", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? Controller { get; set; }

        /// <summary>
        /// Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        /// </summary>
        [Newtonsoft.Json.JsonProperty("kind", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Kind { get; set; }

        /// <summary>
        /// Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names
        /// </summary>
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        /// <summary>
        /// UID of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#uids
        /// </summary>
        [Newtonsoft.Json.JsonProperty("uid", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Uid { get; set; }

    }

    /// <summary>
    /// StatusCause provides more information about an api.Status failure, including cases when multiple errors are encountered.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StatusCause
    {
        /// <summary>
        /// The field of the resource that has caused this error, as named by its JSON serialization. May include dot and postfix notation for nested attributes. Arrays are zero-indexed.  Fields may appear more than once in an array of causes due to fields having multiple errors. Optional.
        /// <br/>
        /// <br/>Examples:
        /// <br/>  "name" - the field "name" on the current resource
        /// <br/>  "items[0].name" - the field "name" on the first array entry in "items"
        /// </summary>
        [Newtonsoft.Json.JsonProperty("field", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Field { get; set; }

        /// <summary>
        /// A human-readable description of the cause of the error.  This field may be presented as-is to a reader.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        /// <summary>
        /// A machine-readable description of the cause of the error. If this value is empty there is no information available.
        /// </summary>
        [Newtonsoft.Json.JsonProperty("reason", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Reason { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DeletePipelineResponse
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LogEntry3
    {
        [Newtonsoft.Json.JsonProperty("msg", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Msg { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

        [Newtonsoft.Json.JsonProperty("pipelineName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string PipelineName { get; set; }

        [Newtonsoft.Json.JsonProperty("stepName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string StepName { get; set; }

        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Time { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class PipelineWatchEvent
    {
        [Newtonsoft.Json.JsonProperty("object", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Pipeline Object { get; set; }

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RestartPipelineResponse
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StepWatchEvent
    {
        [Newtonsoft.Json.JsonProperty("object", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Step Object { get; set; }

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CreateSensorRequest
    {
        [Newtonsoft.Json.JsonProperty("createOptions", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CreateOptions CreateOptions { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

        [Newtonsoft.Json.JsonProperty("sensor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Sensor Sensor { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DeleteSensorResponse
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class LogEntry4
    {
        [Newtonsoft.Json.JsonProperty("dependencyName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DependencyName { get; set; }

        [Newtonsoft.Json.JsonProperty("eventContext", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string EventContext { get; set; }

        [Newtonsoft.Json.JsonProperty("level", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Level { get; set; }

        [Newtonsoft.Json.JsonProperty("msg", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Msg { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

        [Newtonsoft.Json.JsonProperty("sensorName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SensorName { get; set; }

        [Newtonsoft.Json.JsonProperty("time", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? Time { get; set; }

        [Newtonsoft.Json.JsonProperty("triggerName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TriggerName { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SensorWatchEvent
    {
        [Newtonsoft.Json.JsonProperty("object", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Sensor Object { get; set; }

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Type { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class UpdateSensorRequest
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("namespace", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Namespace { get; set; }

        [Newtonsoft.Json.JsonProperty("sensor", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Sensor Sensor { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Response
    {
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StreamError Error { get; set; }

        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public EventSourceWatchEvent Result { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Response2
    {
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StreamError Error { get; set; }

        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LogEntry Result { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Response3
    {
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StreamError Error { get; set; }

        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Event2 Result { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Response4
    {
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StreamError Error { get; set; }

        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public PipelineWatchEvent Result { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Response5
    {
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StreamError Error { get; set; }

        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LogEntry3 Result { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Response6
    {
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StreamError Error { get; set; }

        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public SensorWatchEvent Result { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Response7
    {
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StreamError Error { get; set; }

        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LogEntry4 Result { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Response8
    {
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StreamError Error { get; set; }

        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StepWatchEvent Result { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Response9
    {
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StreamError Error { get; set; }

        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public WorkflowWatchEvent Result { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Response10
    {
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StreamError Error { get; set; }

        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LogEntry2 Result { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Response11
    {
        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public StreamError Error { get; set; }

        [Newtonsoft.Json.JsonProperty("result", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public LogEntry2 Result { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Container2ImagePullPolicy
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Always")]
        Always = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"IfNotPresent")]
        IfNotPresent = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Never")]
        Never = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Container2TerminationMessagePolicy
    {

        [System.Runtime.Serialization.EnumMember(Value = @"FallbackToLogsOnError")]
        FallbackToLogsOnError = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"File")]
        File = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ContainerPortProtocol
    {

        [System.Runtime.Serialization.EnumMember(Value = @"SCTP")]
        SCTP = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"TCP")]
        TCP = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"UDP")]
        UDP = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum HTTPGetActionScheme
    {

        [System.Runtime.Serialization.EnumMember(Value = @"HTTP")]
        HTTP = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"HTTPS")]
        HTTPS = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum NodeSelectorRequirementOperator
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DoesNotExist")]
        DoesNotExist = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Exists")]
        Exists = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Gt")]
        Gt = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"In")]
        In = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"Lt")]
        Lt = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"NotIn")]
        NotIn = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PersistentVolumeClaimConditionType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"FileSystemResizePending")]
        FileSystemResizePending = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Resizing")]
        Resizing = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PersistentVolumeClaimStatusPhase
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Bound")]
        Bound = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Lost")]
        Lost = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Pending")]
        Pending = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum SeccompProfileType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Localhost")]
        Localhost = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"RuntimeDefault")]
        RuntimeDefault = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"Unconfined")]
        Unconfined = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ServicePortProtocol
    {

        [System.Runtime.Serialization.EnumMember(Value = @"SCTP")]
        SCTP = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"TCP")]
        TCP = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"UDP")]
        UDP = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TolerationEffect
    {

        [System.Runtime.Serialization.EnumMember(Value = @"NoExecute")]
        NoExecute = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"NoSchedule")]
        NoSchedule = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"PreferNoSchedule")]
        PreferNoSchedule = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TolerationOperator
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Equal")]
        Equal = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"Exists")]
        Exists = 1,

    }



    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiException<TResult> : ApiException
    {
        public TResult Result { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore 472
#pragma warning restore 114
#pragma warning restore 108
#pragma warning restore 3016
#pragma warning restore 8603
